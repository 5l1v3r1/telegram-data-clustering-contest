<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://www.heise.de/developer/artikel/Die-Geschichte-der-Echtzeitprogrammiersprache-PEARL-4581493.html"/>
    <meta property="og:site_name" content="Developer"/>
    <meta property="article:published_time" content="2019-11-08T07:46:00+00:00"/>
    <meta property="og:title" content="Die Geschichte der Echtzeitprogrammiersprache PEARL"/>
    <meta property="og:description" content="Die einzige deutsche genormte Echtzeitprogrammiersprache PEARL gibt es nun seit rund 50 Jahren. Genau der richtige Zeitpunkt, sie anhand ihrer Entwicklung über die Jahre hinweg wieder in Erinnerung zu rufen."/>
  </head>
  <body>
    <article>
      <h1>Die Geschichte der Echtzeitprogrammiersprache PEARL</h1>
      <h2>Die einzige deutsche genormte Echtzeitprogrammiersprache PEARL gibt es nun seit rund 50 Jahren. Genau der richtige Zeitpunkt, sie anhand ihrer Entwicklung über die Jahre hinweg wieder in Erinnerung zu rufen. </h2>
      <address><time datetime="2019-11-08T07:46:00+00:00">08 Nov 2019, 07:46</time> by <a rel="author">Wolfgang A. Halang, Marcel Schaible</a></address>
      <p>Die Entwicklung der deutschen Echtzeitprogrammiersprache PEARL (Process and Experiment Automation Realtime Language) geht auf den Wunsch zurück, automatisierungs- und kerntechnische Anwendungen angemessen und mit hoher Produktivität formulieren zu können. Schon um das Jahr 1967 herum nahmen deshalb Ingenieure und Physiker von Firmen und Forschungsstellen die Arbeit an der Sprachspezifikation auf, die im April 1973 dann als erster Forschungsbericht des vom Bund geförderten Programms Prozeßdatenverarbeitung (PDV) veröffentlicht wurde.</p>
      <p>Unmittelbar danach wurden erste Übersetzer gebaut und getestet. Ebenfalls begann die Normung von PEARL, wozu 1974 der Arbeitskreis DIN/FNI AK 5.8 gegründet wurde. Aus seinen Arbeiten gingen eine einfache und eine recht komplexe Version der Sprache hervor, die in den Teilen 1 und 2 der DIN 66253 als Basic PEARL 1981 und als Full PEARL 1982 genormt wurden. Daran schloss sich 1989 der Teil 3 Mehrrechner-PEARL an – eine Sprache mit konzeptioneller Klarheit und Eleganz, die ein von anderen bisher unerreichtes Muster zur Strukturierung und Programmierung verteilter Systeme darstellt. So gibt es beispielsweise keine andere Sprache, die dynamische Rekonfiguration verteilter Systeme im Fehlerfalle explizit unterstützt.</p>
      <h4>Abgrenzung zu anderen Programmiersprachen</h4>
      <p>Von anderen höheren Programmiersprachen unterscheidet sich PEARL besonders durch die explizite Unterstützung des Zeitbegriffs. Die beiden Datentypen <code>CLOCK</code> für Zeitpunkte und <code>DURATION</code> für Zeitdauern stehen zusammen mit entsprechenden arithmetischen Operationen zur Verfügung.</p>
      <p>Während beispielsweise die Programmiersprache Ada als einzigen Zeitbezug nur die inhärent ungenaue Verzögerung des Ablaufs von Tasks kennt, die diese innerhalb ihrer Rümpfe selbst verwalten müssen, werden die Aktivierungen von PEARL-Tasks im Hauptprogramm problemorientiert eingeplant: einerseits als sporadische Reaktionen auf ankommende Unterbrechungssignale, auf Erreichen absoluter Zeitpunkte oder auf Verstreichen von Wartezeiten beziehungsweise andererseits periodisch mit in verschiedenen Formen anzugebenden Frequenzen und Geltungsdauern. Um in PEARL die periodische Aktivierung einer Task einzuplanen, reicht eine auch für Nichtfachleute verständliche und selbstdokumentierende Anweisung wie:</p>
      <pre>AT 12:00:00 ALL 1 SEC UNTIL 12:00:10 ACTIVATE Task1 PRIORITY 5;</pre>
      <p>aus. Genau wegen der Nähe von PEARL-Code zu Klartext eignet sich die Sprache nicht nur zur eigentlichen Programmierung, sondern auch zur Spezifikation von Automatisierungsanwendungen und insbesondere für die Lehre. In PEARL-Darstellung lassen sich Denkweise und Konzepte der Echtzeitprogrammierung einfach vermitteln und verstehen. Das hat positive Konsequenzen auf Qualität und Sicherheit der später von den Absolventen erstellten Systeme.</p>
      <p>Mit PEARL hatte die deutsche Informationstechnik in den 1970er-Jahren auf dem Gebiet der Echtzeitsysteme eine international führende Stellung erreicht. Denn die Sprache ist ihren Konkurrenten wegen der Klarheit und geringen Komplexität ihrer Konstrukte sowie ihrer die funktionale Sicherheit fördernden leichten Lesbarkeit und Verständlichkeit technisch überlegen. Deshalb standen ihre Konzepte auch bei der Standardisierung einer Unterprogrammbibliothek zur Erweiterung von Fortran um Echtzeitfähigkeit zu Industrial Real-Time Fortran durch den International Purdue Workshop on Industrial Computer Systems Pate. Allein das französische LTR reichte an PEARL heran, ist jedoch leider verschwunden.</p>
      <p>Auf dem Weltmarkt ist als einzige mit PEARL konkurrierende Sprache Ada verblieben, die komplex ist und deren Echtzeitfähigkeiten nur schwach ausgeprägt sind. Alle anderen Echtzeitsprachen werden nicht mehr gepflegt, meistens sogar seit mehreren Jahrzehnten nicht mehr. Und die sonst in diesem Bereich verwendeten Sprachen wie C und ihre Derivate besitzen keine originären Echtzeitkonstrukte, weshalb zur Programmierung viele explizite Betriebssystemaufrufe erforderlich sind.</p>
      <p>Dass viele andere Sprachen heute bekannter sind, liegt nach Ansicht der Autoren außerdem darin begründet, dass sich die Sprachschöpfer zu wenig für ihr Produkt stark gemacht haben und etwa Ada in militärischen Projekten vorgeschrieben ist. Auch dass Projektmanager oft Vorgaben aufgrund nichttechnischer Kriterien machen, mag ein Grund sein.</p>
      <p>Die im Laufe von 30 Jahren gemachten Erfahrungen fanden 1998 in der Norm DIN 66253-2 PEARL90 ihren Niederschlag, die die Teile 1 und 2 der DIN 66253 ablöste.</p>
      <h4>Geprüfter und nachgewiesener fehlerfreier Echtzeitbetrieb</h4>
      <p>Für den Einsatz in eingebetteten Systemen mit hohen Verlässlichkeitsanforderungen besonders hervorzuheben ist das konzeptionell auf unmittelbare Unterstützung der Echtzeitkonstrukte von PEARL zugeschnittene Realzeitbetriebssystem RTOS-UH des Instituts für Regelungstechnik der Leibniz-Universität Hannover, für das der Status der Betriebsbewährtheit durch Nachweis von über neun Millionen Stunden fehlerfreien Betriebs 18 exemplarischer Anwendungen erlangt werden konnte.</p>
      <p>Die Gesamtzahl industrieller Einsatzfälle unterschiedlicher Couleur von PEARL dürfte im oberen fünfstelligen Bereich liegen. Vorwiegend eingesetzt werden PEARL und auch RTOS-UH von auf Automatisierungstechnik spezialisierten mittelständischen Firmen und Ingenieurbüros, die mit den Werkzeugen der Sprache ihren Wettbewerbs- und Produktivitätsvorsprung realisieren wollen. Um auch das für die Automatisierungstechnik so wichtige Gebiet der speicherprogrammierbaren Steuerungen abzudecken, wurde mit PEARL-PLC eine Abbildung der Funktionsplansprache gemäß der Norm IEC 61131-3 nach PEARL realisiert.</p>
      <h3>Jüngere Entwicklungen im Kontext der Sicherheitsintegritätsstufen</h3>
      <p>2012 begann ein Arbeitskreis des gemeinsamen Fachausschusses Echtzeitsysteme der Gesellschaft<br/>für Informatik (GI), der VDI/VDE-Gesellschaft für Mess- und Automatisierungstechnik (GMA) sowie der Informationstechnischen Gesellschaft (ITG) im VDE, einen auf der PEARL90-Sprachnorm basierenden Übersetzer OpenPEARL zu entwickeln, der zusammen mit einem passenden Laufzeitsystem für Linux-Systeme frei erhältlich ist.</p>
      <p>Im Zuge dieser Arbeiten wurde die Norm kritisch gesichtet, was zur Aufdeckung von Widersprüchen und nicht eindeutigen Formulierungen sowie in der Folge zu zahlreichen Präzisierungen und Vereinfachungen der Sprache führte, die dann in OpenPEARL Einzug hielten. Erfahrungsgemäß höchst selten eingesetzte oder technisch obsolet gewordene Konstrukte wurden ebenso aus ihr entfernt wie solche, die zu fehlerträchtigen, unstrukturierten, schwer analysierbaren und nicht modular aufgebauten Programmen mit<br/>nichtdeterministischem Laufzeitverhalten führen und strenge Datentypisierung behindern.</p>
      <p>Darauf aufbauend wurde unter dem Namen SafePEARL durch Zusammenfügung und Modifikation von OpenPEARL und Mehrrechner-PEARL eine auf Sicherheit ausgerichtete Grundsprache zur Echtzeitprogrammierung sowie darin für jede der vier Sicherheitsintegritätsstufen nach der internationalen Norm IEC 61508 eine wegen der Beschränkung auf das Notwendigste leicht verständliche und somit inhärent sichere Teilsprache definiert. Deren Syntax erzwingt die Einhaltung der jeweils geltenden Einschränkungen.</p>
      <p>Die den beiden oberen Sicherheitsstufen SIL4 und SIL3 zugeordneten Teilsprachen für Ursache-/Wirkungstabellen beziehungsweise Funktions- und Ablaufpläne auf der Grundlage verifizierter Bibliotheken sind die weltweit einzigen, die hohen Sicherheitsanforderungen genügende Programme derzeit einfach und wirtschaftlich zu verifizieren gestatten.</p>
      <p>Für die unteren Sicherheitsstufen wurden textuelle Teilsprachen definiert, und zwar für SIL2 eine formaler Programmverifikation zugängliche Sprache und für SIL1 eine statische Sprache mit sicheren Konstrukten zum Einsatz im asynchronen Mehrprozessbetrieb.</p>
      <p>Weniger sichere Sprachmerkmale werden schrittweise zu höheren Sicherheitsstufen hin zur Programmformulierung nicht mehr zugelassen. Deshalb muss nicht für jede Stufe eine neue Sprache gelernt werden und Übersetzer können prüfen, ob Programme bestimmte Sicherheitsauflagen erfüllen. Das Prinzip, Teilmengen einer Sprache für kritische Anwendungen zu definieren, gestattet es, Programme nach bestimmten Sicherheitsanforderungen zu entwickeln und Codeabschnitte für sicherheitskritische und<br/>-unkritische Systemteile miteinander zu verbinden. Je sicherheitskritischer ein System ist, desto restriktivere Methoden sind einzusetzen.</p>
      <p>Zu ihrer Durchsetzung wird mit Übersetzerdirektiven das jeweils gewünschte Sicherheitsniveau vorgegeben, sodass sich alle notwendigen Prüfungen zur Übersetzungszeit durchführen lassen. In einem Codeabschnitt sind nur Konstrukte der Sprachteilmenge der bezeichneten und der höheren Sicherheitsniveaus zulässig. Codeabschnitte mit unterschiedlichen Sicherheitsanforderungen sind schachtelbar, um so transparent miteinander verbunden werden zu können.</p>
      <p>Mit SafePEARL und seinen ineinander geschachtelten, spezifischen Teilmengen für die vier Sicherheitsintegritätsstufen nach IEC 61508 entstand eine Sprache zur Programmierung eingebetteter, verteilter Echtzeitsysteme, die die bekannten Sprachmittel zur Förderung funktionaler Sicherheit in sich vereinigt und sich an der menschlichen Verständnisfähigkeit orientiert. Leitmotiv ihrer Formulierung war das Streben nach größtmöglicher Korrektheit, Konsistenz und Genauigkeit der Darstellung bei geringstmöglichem Umfang. Deshalb wurden die vier den Sicherheitsintegritätsstufen zugeordneten Teilsprachen nicht einzeln beschrieben, sondern durch untenstehende Tabelle definiert. Sie gibt an, welche Konstrukte der Grundsprache auf den Sicherheitsstufen SIL1 bis SIL4 jeweils verwendet werden dürfen. Gemäß Beschluss des DIN-Normenausschusses "NA 043-01-22 AA Programmiersprachen" ersetzt SafePEARL seit 2018 die älteren Versionen nach DIN 66253 Teil 3 und DIN 66253-2.</p>
      <table bordered="">
        <tr>
          <td align="center">Anweisung/Klausel</td>
          <td align="center">SIL0</td>
          <td align="center">SIL1</td>
          <td align="center">SIL2</td>
          <td align="center">SIL3</td>
          <td align="center">SIL4</td>
        </tr>
        <tr>
          <td align="left">GOTO, EXIT</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">(bedingte) Anweisungen und Ausdrücke</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">bedingte Anweisungen und Anweisungsauswahl</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Angabe physikalischer Einheiten</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
        </tr>
        <tr>
          <td align="left">Ursache-Wirkungstabellen</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
        </tr>
        <tr>
          <td align="left">sequentielle Ablaufpläne</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Synchronisierung mit SEMA- und BOLT-Variablen</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Synchronisierung mit LOCK- und TIMEOUT-Klausel</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Verwendung interner Signale</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Verwendung von Unterbrechungssignalen</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Verwendung von Tasks</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">mit Prioritäten</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">mit Fristenangaben und Zeitüberwachung</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">(Funktions-)Prozeduraufrufe</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Wiederholungen</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">mit MAXLOOP-Klausel</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Verwendung von Zeigern und Referenzen</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">PUT/GET, READ/WRITE, CONVERT</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">TAKE/SEND</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
        </tr>
        <tr>
          <td align="left">verteilte Systeme</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
        </tr>
        <tr>
          <td align="left">dynamische Rekonfiguration</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
        </tr>
        <tr>
          <td align="left">Botschaftenaustausch</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">+</td>
          <td align="left">-</td>
          <td align="left">-</td>
        </tr>
      </table>
      <p>Gepflegt wird PEARL durch den Fachausschuss Echtzeitsysteme, der unter anderem zweimal jährlich die Zeitschrift "EchtZeit – der Rundbrief" herausgibt und jährlich im November die Fachtagung Echtzeitsysteme durchführt. Deren Tagungsbände erscheinen im Springer-Verlag in der Reihe "Informatik aktuell". Für aktuelle Informationen zu PEARL und RTOS-UH sei auf den <a href="http://www.real-time.de/">Internet-Auftritt des Fachausschusses</a> verwiesen. Dort findet sich auch zur freien Verfügung ein PEARL-Sprachreport in englischer Sprache für den internationalen Markt und ein Verweis auf den frei verfügbaren OpenPEARL-Übersetzer. (<a href="mailto:ane@heise.de">ane</a>)</p>
      <p>
        <i>Prof. Dr. Dr. Wolfgang A. Halang <br/>hatte bis zu seiner Pensionierung den Lehrstuhl für Informationstechnik, insbesondere Realzeitsysteme, an der Fernuniversität in Hagen inne. Er beschäftigt sich mit dem Gebiet seit 1973 und ist Autor des 2018 in dritter Auflage im Springer-Verlag erschienenen Kompendiums "Sicherheitsgerichtete Echtzeitsysteme".</i>
      </p>
      <p>
        <i>Dipl.-Inform. (Univ.) Marcel Schaible <br/>beschäftigt sich seit 1984 mit Compilerbau und trug maßgeblich zur DIN-Norm für SafePEARL bei. Daneben arbeitet er als Freiberufler in der Industrie und als wissenschaftlicher Mitarbeiter an der Fernuniversität in Hagen.</i>
      </p>
      <h4>Onlinequellen</h4>
      <ul>
        <li>
          <a href="https://www.real-time.de/">Gesellschaft für Informatik – Fachausschuss Echtzeitsysteme</a>
        </li>
        <li>
          <a href="https://www.din.de/de/wdc-beuth:din21:284094216">DIN 66253 Informationsverarbeitung – Programmiersprache PEARL – SafePEARL</a>
        </li>
      </ul>
    </article>
  </body>
</html>