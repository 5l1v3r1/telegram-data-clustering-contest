<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://css-tricks.com/working-with-fusebox-and-react/"/>
    <meta property="og:site_name" content="CSS-Tricks"/>
    <meta property="article:published_time" content="2019-11-08T15:35:49+00:00"/>
    <meta property="og:title" content="Working with Fusebox and React"/>
    <meta property="og:description" content="If you are searching for an alternative bundler to webpack, you might want to take a look at FuseBox. It builds on what webpack offers — code-splitting,"/>
  </head>
  <body>
    <article>
      <h1>Working with Fusebox and React</h1>
      <p>Easily manage projects with <a href="https://synd.co/2JziuUL">monday.com</a></p>
      <p>If you are searching for an alternative bundler to webpack, you might want to take a look at <a href="https://fuse-box.org/">FuseBox</a>. It builds on what webpack offers — code-splitting, hot module reloading, dynamic imports, etc. — but code-splitting in FuseBox requires <a href="https://fuse-box.org/docs/development/configuration">zero configuration</a> by default (although webpack will offer the same as of <a href="https://medium.com/webpack/webpack-4-beta-try-it-today-6b1d27d7d7e2">version 4.0</a>).</p>
      <p>Instead, FuseBox is built for simplicity (in the form of less complicated configuration) and performance (by including aggressive caching methods). Plus, it can be extended to use <a href="https://fuse-box.org/docs/plugins/babel-plugin">tons of plugins</a> that can handle anything you need above and beyond the defaults.</p>
      <p>Oh yeah, and if you are a fan of TypeScript, you might be interested in knowing that FuseBox makes it a first-class citizen. That means you can write an application in Typescript — with no configuration! — and it will use the Typescript transpiler to compile scripts by default. Don’t plan on using Typescript? No worries, the transpiler will handle any JavaScript. Yet another bonus!</p>
      <p>To illustrate just how fast it is to to get up and running, let’s build the bones of a sample application that's usually scaffolded with <a href="https://create-react-app.dev/">create-react-app</a>. Everything we’re doing <a href="https://github.com/kinsomicrote/csstricks-fusebox-react">will be on</a> <a href="https://github.com/kinsomicrote/csstricks-fusebox-react">GitHub</a> if you want to follow along.</p>
      <p>FuseBox is not the only alternative to webpack, of course. There are plenty and, in fact, <a href="https://css-tricks.com/why-parcel-has-become-my-go-to-bundler-for-development/">Maks Akymenko has a great write-up on Parcel</a> which is another great alternative worth looking into.</p>
      <h3>The basic setup</h3>
      <p>Start by creating a new project directory and initializing it with npm:</p>
      <pre>## Create the directory <br/>mkdir csstricks-fusebox-react &amp;&amp; $_ <br/>## Initialize with npm default options <br/>npm init -y</pre>
      <p>Now we can install some dependencies. We’re going to build the app in React, so we’ll need that as well as react-dom.</p>
      <pre>npm install --save react react-dom</pre>
      <p>Next, we’ll install FuseBox and Typescript as dependencies. We’ll toss Uglify in there as well for help minifying our scripts and add support for writing styles in Sass.</p>
      <pre>npm install --save-dev fuse-box typescript uglify-js node-sass</pre>
      <p>Alright, now let’s create a <code>src</code> folder in the root of the project directory (which can be done manually). Add the following files (`app.js and <code>index.js</code>) in there, including the contents:</p>
      <pre>// App.js <br/><br/>import * as React from "react"; <br/>import * as logo from "./logo.svg"; <br/><br/>const App = () =&gt; { <br/>  return ( <br/>    &lt;div className="App"&gt; <br/>      &lt;header className="App-header"&gt; <br/>        &lt;img src={logo} className="App-logo" alt="logo" /&gt; <br/>        &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt; <br/>      &lt;/header&gt; <br/>      &lt;p className="App-intro"&gt; <br/>        To get started, edit `src/App.js` and save to reload. <br/>      &lt;/p&gt; <br/>    &lt;/div&gt; <br/>  ) <br/>}; <br/><br/>export default App;</pre>
      <p>You may have noticed that we’re importing an SVG file. You can download it directly from the <a href="https://github.com/kinsomicrote/csstricks-fusebox-react/blob/master/src/logo.svg">GitHub repo</a>.</p>
      <pre>// index.js <br/><br/>import * as React from "react"; <br/>import * as ReactDOM from "react-dom"; <br/>import App from "./App" <br/><br/>ReactDOM.render( <br/>  &lt;App /&gt;, document.getElementById('root') <br/>);</pre>
      <p>You can see that the way we handle importing files is a little different than a typical React app. That’s because FuseBox does not polyfill imports by default.</p>
      <p>So, instead of doing this:</p>
      <pre>import React from "react";</pre>
      <p>...we’re doing this:</p>
      <pre>import * as React from "react";</pre>
      <pre>&lt;!-- ./src/index.html --&gt; <br/><br/>&lt;!DOCTYPE html&gt; <br/>&lt;html lang="en"&gt; <br/>  &lt;head&gt; <br/>    &lt;title&gt;CSSTricks Fusebox React&lt;/title&gt; <br/>    $css <br/>  &lt;/head&gt; <br/><br/>  &lt;body&gt; <br/>    &lt;noscript&gt; <br/>      You need to enable JavaScript to run this app. <br/>    &lt;/noscript&gt; <br/>    &lt;div id="root"&gt;&lt;/div&gt; <br/>    $bundles <br/>  &lt;/body&gt; <br/>&lt;/html&gt;</pre>
      <p>Styling isn’t really the point of this post, but let’s drop some in there to dress things up a bit. We’ll have two stylesheets. The first is for the <code>App</code> component and saved as <code>App.css</code>.</p>
      <pre>/* App.css */ <br/><br/>.App { <br/>  text-align: center; <br/>} <br/><br/>.App-logo { <br/>  animation: App-logo-spin infinite 20s linear; <br/>  height: 80px; <br/>} <br/><br/>.App-header { <br/>  background-color: #222; <br/>  height: 150px; <br/>  padding: 20px; <br/>  color: white; <br/>} <br/><br/>.App-intro { <br/>  font-size: large; <br/>} <br/><br/>@keyframes App-logo-spin { <br/>  from { <br/>    transform: rotate(0deg); <br/>  } <br/>  to { <br/>    transform: <br/>        rotate(360deg); <br/>  } <br/>}</pre>
      <p>The second stylesheet is for <code>index.js</code> and should be saved as <code>index.css</code>:</p>
      <pre>/* index.css */ <br/>body { <br/>  margin: 0; <br/>  padding: 0; <br/>  font-family: sans-serif; <br/>}</pre>
      <p>OK, we’re all done with the initial housekeeping. On to extending FuseBox with some goodies!</p>
      <h3>Plugins and configuration</h3>
      <p>We said earlier that configuring FuseBox is designed to be way less complex than the likes of webpack — and that’s true! Create a file called <code>fuse.js</code> in the root directory of the application.</p>
      <p>We start with importing the plugins we’ll be making use of, all the plugins come from the FuseBox package we installed.</p>
      <pre>const { FuseBox, CSSPlugin, SVGPlugin, WebIndexPlugin } = require("fuse-box");</pre>
      <p>Next, we’ll initialize a FuseBox instance and tell it what we’re using as the home directory and where to put compiled assets:</p>
      <pre>const fuse = FuseBox.init({ <br/>  homeDir: "src", <br/>  output: "dist/$name.js" <br/>});</pre>
      <p>We’ll let FuseBox know that we intend to use the TypeScript compiler:</p>
      <pre>const fuse = FuseBox.init({ <br/>  homeDir: "src", <br/>  output: "dist/$name.js", <br/>  useTypescriptCompiler: true, <br/>});</pre>
      <p>We identified plugins in the first line of the configuration file, but now we’ve got to call them. We’re using the plugins pretty much as-is, but definitely check out what the <a href="https://fuse-box.org/docs/3.5.0/plugins/css-plugin">CSSPlugin</a>, <a href="https://fuse-box.org/docs/3.5.0/plugins/svg-plugin">SVGPlugin</a> and <a href="https://fuse-box.org/docs/3.5.0/plugins/web-index-plugin">WebIndexPlugin</a> have to offer if you want more fine-grained control over the options.</p>
      <pre>const fuse = FuseBox.init({ <br/>  homeDir: "src", <br/>  output: "dist/$name.js", <br/>  useTypescriptCompiler: true, <br/>  plugins: [ // HIGHLIGHT <br/>    CSSPlugin(), <br/>    SVGPlugin(), <br/>    WebIndexPlugin({ <br/>      template: "src/index.html" <br/>    }) <br/>  ] <br/>}); <br/><br/>const { FuseBox, CSSPlugin, SVGPlugin, WebIndexPlugin } = require("fuse-box"); <br/><br/>const fuse = FuseBox.init({ <br/>  homeDir: "src", <br/>  output: "dist/$name.js", <br/>  useTypescriptCompiler: true, <br/>  plugins: [ <br/>    CSSPlugin(), <br/>    SVGPlugin(), <br/>    WebIndexPlugin({ <br/>      template: "src/index.html" <br/>    }) <br/>  ] <br/>}); <br/>fuse.dev(); <br/>fuse <br/>  .bundle("app") <br/>  .instructions(`&gt;index.js`) <br/>  .hmr() <br/>  .watch() <br/><br/>fuse.run();</pre>
      <p>FuseBox lets us configure a <a href="https://fuse-box.org/docs/3.5.0/development/development-server">development server</a>. We can define ports, SSL certificates, and even open the application in a browser on build.</p>
      <p>We’ll simply use the default environment for this example:</p>
      <pre>fuse.dev();</pre>
      <p>It is important to define the development environment *before* the bundle instructions that come next:</p>
      <pre>fuse <br/>  .bundle("app") <br/>  .instructions(`&gt;index.js`) <br/>  .hmr() <br/>  .watch().</pre>
      <p>What the heck is this? When we initialized the FuseBox instance, we specified an output using <code>dist/$name.js</code>. The value for <code>$name</code> is provided by the <code>bundle()</code> method. In our case, we set the value as <code>app</code>. That means that when the application is bundled, the output destination will be <code>dist/app.js</code>.</p>
      <p>The <code><a href="https://fuse-box.org/docs/3.5.0/development/instructions#docsNav">instructions()</a></code> method defines how FuseBox should deal with the code. In our case, we’re telling it to start with <code>index.js</code> and to execute it after it’s loaded.</p>
      <p>The <code>hmr()</code> method is used for cases where we want to update the user when a file changes, this usually involves updating the browser when a file changes. Meanwhile, <code>watch()</code> re-bundles the bundled code after every saved change.</p>
      <p>With that, we’ll cap it off by launching the build process with <code>fuse.run()</code> at the end of the configuration file. Here’s everything we just covered put together:</p>
      <pre>const { FuseBox, CSSPlugin, SVGPlugin, WebIndexPlugin } = require("fuse-box"); <br/><br/>const fuse = FuseBox.init({ <br/>  homeDir: "src", <br/>  output: "dist/$name.js", <br/>  useTypescriptCompiler: true, <br/>  plugins: [ <br/>    CSSPlugin(), <br/>    SVGPlugin(), <br/>    WebIndexPlugin({ <br/>      template: "src/index.html" <br/>    }) <br/>  ] <br/>}); <br/>fuse.dev(); <br/>fuse <br/>  .bundle("app") <br/>  .instructions(`&gt;index.js`) <br/>  .hmr() <br/>  .watch() <br/><br/>fuse.run();</pre>
      <p>Now we can run the application from the terminal by running <code>node fuse</code>. This will start the build process which creates the <code>dist</code> folder that contains the bundled code and the template we specified in the configuration. After the build process is done, we can point the browser to <code>http://localhost:4444/</code> to see our app.</p>
      <h3>Running tasks with Sparky</h3>
      <p>FuseBox includes a task runner that can be used to automate a build process. It's called <a href="https://fuse-box.org/docs/task-runner/sparky">Sparky</a> and you can think of it as sorta like Grunt and Gulp, the difference being that it is built on top of FuseBox with built-in access to FuseBox plugins and the FuseBox API.</p>
      <p>We don’t have to use it, but task runners make development a lot easier by automating things we’d otherwise have to do manually and it makes sense to use what’s specifically designed for FuseBox.</p>
      <p>To use it, we’ll update the configuration we have in <code>fuse.js</code>, starting with some imports that go at the top of the file:</p>
      <pre>const { src, task, context } = require("fuse-box/sparky");</pre>
      <p>Next, we’ll define a context, which will look similar to what we already have. We’re basically wrapping what we did in a context and <code>setConfig()</code>, then initializing FuseBox in the return:</p>
      <pre>context({ <br/>  setConfig() { <br/>    return FuseBox.init({ <br/>      homeDir: "src", <br/>      output: "dist/$name.js", <br/>      useTypescriptCompiler: true, <br/>      plugins: [ <br/>        CSSPlugin(), <br/>        SVGPlugin(), <br/>        WebIndexPlugin({ <br/>          template: "src/index.html" <br/>        }) <br/>      ] <br/>    }); <br/>  }, <br/>  createBundle(fuse) { <br/>    return fuse <br/>      .bundle("app") <br/>      .instructions(`&gt; index.js`) <br/>      .hmr(); <br/>  } <br/>});</pre>
      <p>It’s possible to pass a class, function or plain object to a context. In the above scenario, we’re passing functions, specifically <code>setConfig()</code> and <code>createBundle()</code>. <code>setConfig()</code> initializes FuseBox and sets up the plugins. <code>createBundle()</code> does what you might expect by the name, which is bundling the code. Again, the difference from what we did before is that we’re embedding both functionalities into different functions which are contained in the context object.</p>
      <p>We want our task runner to run tasks, right? Here are a few examples we can define:</p>
      <pre>task("clean", () =&gt; src("dist").clean("dist").exec()); <br/>task("default", ["clean"], async (context) =&gt; { <br/>  const fuse = context.setConfig(); <br/>  fuse.dev(); <br/>  context.createBundle(fuse); <br/>  await fuse.run() <br/>});</pre>
      <p>The first task will be responsible for cleaning the <code>dist</code> directory. The first argument is the name of the task, while the second is the function that gets called when the task runs.<br/>To call the first task, we can do <code>node fuse clean</code> from the terminal.</p>
      <p>When a task is named <code>default</code> (which is the first argument as in the second task), that task will be the one that gets called by default when running <code>node fuse</code> — in this case, that’s the second task in our configuration. Other tasks need to be will need to be called explicitly in terminal, like <code>node fuse</code> <code>&lt;task_name&gt;</code>.</p>
      <p>So, our second task is the default and three arguments are passed into it. The first is the name of the task (`default`), the second (<code>["clean"]</code>) is an array of dependencies that should be called before the task itself is executed, and the third is a function (<code>fuse.dev()</code>) that gets the initialized FuseBox instance and begins the bundling and build process.</p>
      <p>Now we can run things with <code>node fuse</code> in the terminal. You have the option to add these to your <code>package.json</code> file if that’s more comfortable and familiar to you. The script section would look like this:</p>
      <pre>"scripts": { <br/>  "start": "node fuse", <br/>  "clean": "node fuse clean" <br/>},</pre>
      <h3>That’s a wrap!</h3>
      <p>All in all, FuseBox is an interesting alternative to webpack for all your application bundling needs. As we saw, it offers the same sort of power that we all tend to like about webpack, but with a way less complicated configuration process that makes it much easier to get up and running, thanks to built-in Typescript support, performance considerations, and a task runner that’s designed to take advantage of the FuseBox API.</p>
      <p>What we look at was a pretty simple example. In practice, you’re likely going to be working with more complex applications, but the concepts and principles are the same. It’s nice to know that FuseBox is capable of handling more than what’s baked into it, but that the initial setup is still super streamlined.</p>
      <p>If you’re looking for more information about FuseBox, it’s <a href="https://fuse-box.org/">site</a> and <a href="https://fuse-box.org/docs/getting-started/installation">documentation</a> are obviously great starting point. the following links are also super helpful to get more perspective on how others are setting it up and using it on projects.</p>
      <ul>
        <li>
          <a href="https://auth0.com/blog/introducing-fusebox-an-alternative-to-webpack/">Introducing FuseBox, an alternative to Webpack</a>
        </li>
        <li>
          <a href="https://medium.com/fusebox/webpack-is-not-the-only-way-6ddb67e99be9">WebPack is not the only way</a>
        </li>
        <li><a href="https://www.youtube.com/watch?v=gCfWVRsWoKA">Introduction to FuseBox</a> (YouTube)</li>
      </ul>
    </article>
  </body>
</html>