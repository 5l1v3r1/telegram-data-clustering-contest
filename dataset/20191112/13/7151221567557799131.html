<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://dou.ua/lenta/articles/junior-java-interview-3/"/>
    <meta property="og:site_name" content="ДОУ"/>
    <meta property="article:published_time" content="2019-11-12T13:00:00+00:00"/>
    <meta property="og:title" content="Советы для начинающего Java-разработчика. Подготовка к собеседованию — часть 3"/>
    <meta property="og:description" content="Третья часть цикла для Junior Java Developers. Алексей Мовчан рассказывает, что нужно знать об алгоритмах, паттернах проектирования, системах контроля версий, сборке проекта. Также рассмотрим тестирование, логирование, дебаг, методологии разработки."/>
  </head>
  <body>
    <article>
      <h1>Советы для начинающего Java-разработчика. Подготовка к собеседованию — часть 3</h1>
      <address><time datetime="2019-11-12T13:00:00+00:00">12 Nov 2019, 13:00</time> by <a rel="author" href="https://dou.ua/users/oleksii-movchan/" target="_blank">Oleksii Movchan</a></address>
      <p>После обсуждения наиболее распространенных вопросов по основам Java <a href="https://dou.ua/lenta/articles/junior-java-interview-1/">в первой части</a> и двум популярным фреймворкам <a href="https://dou.ua/lenta/articles/junior-java-interview-2/">во второй части</a> статьи, разберем оставшиеся, но не менее важные инструменты и технологии.</p>
      <figure>
        <img src="https://s.dou.ua/storage-files/920_5eIM8cs.png"/>
      </figure>
      <h3>Алгоритмы</h3>
      <p>Основная тема на собеседованиях за рубежом пользуется у нас гораздо меньшей популярностью. Про подготовку к зарубежным собеседованиям на позицию разработчика написаны десятки книг и сотни статей, в которых львиную долю занимает именно постановка алгоритмического мышления и разбор популярных задач. У нас, к счастью, большой необходимости в штудировании сайтов вроде <a href="http://leetcode.com/">leetcode.com</a> нет. В противном случае время подготовки к собеседованию увеличилось бы как минимум вдвое. Впрочем, ни одно собеседование без подобных вопросов не обходится все равно.</p>
      <p>У каждого собеседующего есть свой список «удачных» задач для проверки способности последовательно и структурировано мыслить. Иногда достаточно абсурдных и мало применимых к реальным ситуациям. И если повеселивший многих вопрос из предыдущей части статьи про разницу BeanFactory и FactoryBean в спринге имеет хоть какой-то, пусть и отдаленный, практический смысл, то лично мне сложно понять смысл вопроса про палочку, которую мы разламываем в двух местах на три части, и поиск вероятности составления треугольника из этих частей. Но пути мышления собеседующих неисповедимы, поэтому будем по традиции отталкиваться от статистических данных по задаваемым вопросам.</p>
      <h4>Что спрашивают часто:</h4>
      <ul>
        <li>Что такое сложность алгоритма? Практический вариант: сравните сложность двух решений одной задачи.</li>
      </ul>
      <p>Вопрос, без которого не обойдется ни одно собеседование, поэтому остановимся на нем немного подробнее. Важно помнить, что помимо сложности по времени выполнения есть также сложность по расходуемой памяти. И не забывайте спрашивать собеседующего, важна ли она в данном случае. Это дает условный плюс в корзину претендента. А также то, что основных обозначений сложности, как функции зависимости объёма вычислений от размера входных данных, бывает несколько (tilde, big-O, big-theta, big-omega). Но спрашивают чаще всего либо про средний случай, либо про верхнюю границу выполнения — расчет для худшего случая. И какой вариант интересует собеседующего тоже нужно уточнять сразу.</p>
      <ul>
        <li>Какие знаете сортировки, которые используются в стандартных механизмах Java?</li>
      </ul>
      <p>Вопрос про QuickSort и TimSort, и их применение. Быструю сортировку желательно уметь реализовать в простом варианте для саморазвития.</p>
      <ul>
        <li>Бинарный поиск. Мастхэв, элементарный алгоритм, много кто спрашивает. Сложность знать обязательно, так же как и уметь объяснить, почему она такая.</li>
        <li>Структуры данных в Java, которые умеют сортировать под капотом. Для чего чаще всего используются? Что внутри, как происходит сортировка? При каком условии объекты, положенные внутрь, будут отсортированы правильно?</li>
        <li>Почему иногда выбор худшей по сложности сортировки выгоднее?</li>
      </ul>
      <p>С целью проверить общеобразовательный уровень могут спросить про двоичное дерево, двоичную кучу, графы. В 90% случаев всегда поверхностно: что это такое, где используются, какие бывают. Также подозрительно часто дают задачи на сортировку подсчетом.</p>
      <p>В целом, по моему личному мнению, углубленные курсы по алгоритмам не нужны за исключением частных случаев. Вышеперечисленных знаний, как базовых, достаточно.</p>
      <h3>Паттерны проектирования</h3>
      <p>Весь код, который вам придется писать в продакшене, будет частью того или иного паттерна. На начальном уровне важно разобраться в самых применяемых моделях и понимать, какая логика куда выносится и почему именно так.</p>
      <p>Спрашивать любят про разделение паттернов на категории, по каждой из которых обычно просят назвать 2-3 известных паттерна и рассказать о них. Есть <a href="https://refactoring.guru/uk/design-patterns/what-is-pattern">сайт</a> для изучения основ на абстрактных примерах. Я не очень хорошо отношусь к абстрактным примерам после своей первой книги Head First Design Patterns, но refactoring guru неплохо поясняет теоретические аспекты и необходимость использования того или иного шаблона. Практику же можно параллельно просматривать <a href="https://java-design-patterns.com/patterns/">вот здесь</a>. Хороший ресурс для добавления в закладки и постепенного изучения после трудоустройства.</p>
      <p>Если сроки поджимают, то вот небольшой список на изучение по каждой категории:</p>
      <ul>
        <li>порождающие: фабричный метод, абстрактная фабрика, билдер, синглтон;</li>
        <li>структурные: фасад, прокси, декоратор;</li>
        <li>поведенческие: шаблонный метод, наблюдатель, стратегия;</li>
        <li>дополнительно (но не менее важно): DAO, repository, MVC.</li>
      </ul>
      <p>Из GRASP-паттернов можно ознакомиться с Low Coupling и High Cohesion как основополагающими принципами. Тем более, что в отличие от GoF, их можно интуитивно понять после первого же прочтения.</p>
      <h3>Системы контроля версий</h3>
      <p>Изучение VCS (на примере Git) очень рекомендую делать на практике по принципу «прочитал — выполнил — проверил результат». На первых порах достаточно будет выучить список основных команд и для чего они нужны: push (с опциями), pull, fetch, commit, merge, rebase, squash, revert. После проверки на практике вопросы вроде «как отменить несколько коммитов» или «как собрать несколько коммитов в один» должны перестать беспокоить. Хотя последние спрашивают уже от уровня крепкого джуна и выше. Тогда же спросят про Git workflow или жизненный цикл разработки. Недоджуну достаточно понимать общие принципы совместной работы с кодом и уметь подтягивать чужие изменения, коммитить свои и делать merge. Остальное рекомендую изучать уже после трудоустройства.</p>
      <h3>Сборка проекта</h3>
      <p>Самые популярные сборщики сегодня: Maven и Gradle. Вторым воспользоваться на реальном проекте мне так и не довелось, поэтому все дальнейшее будет относиться к мавену.</p>
      <p>Сборку приходится осуществлять часто, но практически всегда это стандартный набор из 2-3 команд. Поэтому погружаться в дебри документации и выписывать нюансы сборки на начальных этапах карьеры я бы не рекомендовал.</p>
      <p>Что хотят услышать на собеседовании:</p>
      <ul>
        <li>Что вообще такое процесс сборки проекта на Java? Для чего нужна сборка? Что имеем на выходе?</li>
        <li>За что отвечает pom.xml и какая у него структура?</li>
        <li>Как организована сборка многомодульных проектов?</li>
        <li>Назовите стандартные жизненные циклы мавена и несколько фаз, которые к ним относятся.</li>
        <li>Как мавен решает проблемы с транзитивными зависимостями?</li>
      </ul>
      <h3>Веб-технологии</h3>
      <p>Java, как язык для разработки server-side приложений, не может быть отделен от веба. Поэтому основы веб-технологий спросят всегда:</p>
      <ul>
        <li>Что такое HTTP? какие у него альтернативы?</li>
        <li>Какие есть HTTP-запросы? (назвать 4 основных будет достаточно) Какая между ними разница? Любимый вопрос у всех: чем GET отличается от POST?</li>
        <li>Что такое REST? какие особенности RESTful-сервисов знаете? Про SOAP сегодня практически не спрашивают.</li>
        <li>Назовите пару контейнеров для запуска веб-приложений на Java. Что они из себя представляют? Для сравнения можно рассмотреть популярные Tomcat и Jetty.</li>
      </ul>
      <h3>Тестирование</h3>
      <p>Требования к тестированию очень сильно отличаются от проекта к проекту. Где-то разделяют принципы TDD, где-то выделяют время только на минимальное покрытие тестами в силу приоритетов по другим задачам. Бизнесу виднее (почти сарказм). Знать заранее, как будет на следующем вашем проекте нельзя, поэтому сфокусируемся на базовых моментах. Самые распространенные для тестирования фреймворки на сегодня: JUnit для юнит-тестов и Mockito для имплементации заглушек. Оба элементарно подключаются к проекту и предельно просты в вопросе понимания необходимости их использования.</p>
      <p>Что часто спрашивают:</p>
      <ul>
        <li>Какие виды тестирования знаете и чем они отличаются? Разработчику достаточно назвать модульное, интеграционное и функциональное. Если назовете нагрузочное, то необходимо заранее посмотреть в сторону такого инструмента, как JMeter, чтобы было что отвечать на дополнительные вопросы без серьезного погружения в тему.</li>
        <li>Основные аннотации в JUnit (test, before, after, beforeClass, afterClass, ignore) и их особенности.</li>
        <li>Чем отличается Mock от Spy в мокито? Приведите пример использования первого и второго (крепкий джун+).</li>
        <li>Что, если ожидаем от метода выброшенного исключения? Что, если метод не должен выполняться дольше определенного количества времени?</li>
        <li>Какие модификаторы доступа у тестовых методов в JUnit?</li>
      </ul>
      <p>У крепкого джуна могут также спросить про параметризированное/категоризированное тестирование (@RunWith аннотация). Или про нюансы тестирования методов, которые обращаются к БД.</p>
      <h3>Логирование</h3>
      <p>Тема маленькая, практический смысл большой. Присутствует на любом проекте, спрашивают очень часто. Из важного могу порекомендовать запомнить уровни логирования:</p>
      <p>ALL Логируются все сообщения<br/>TRACE Мелкое сообщение при отладке<br/>DEBUG Важные сообщения при отладке<br/>INFO Просто сообщение<br/>WARN Предупреждение<br/>ERROR Ошибка<br/>FATAL Фатальная ошибка</p>
      <p>Если выставить уровень логирования в WARN, то все менее важные, чем WARN сообщения, будут отброшены (TRACE, DEBUG, INFO). Если нужно настроить, чтобы какие-то логи писались в файл, настраивается с помощью Appenders.</p>
      <h3>Дебаг</h3>
      <p>К сожалению, огромное количество претендентов на позицию джуна сильно недооценивают значимость такого инструмента разработчика, как отладчик. А уровень владения дебагом у среднестатистического стажера лежит в плоскости «вы знаете, я обычно просто добавляю System.out, чтобы посмотреть значение переменной». И очень мало, где пишут, что джун по факту проводит за отладкой и поиском ошибок не намного меньше времени, чем за разработкой. Отсюда рекомендация: обязательно разобраться в дебаге.</p>
      <p>На примере IntelliJ IDEA: знать, какие функции в режиме отладки выполняют F7, F8, F9. Как посмотреть содержимое обрабатываемой коллекции в конкретный момент выполнения. Как изменить значение, которое передается в метод прямо в момент отладки. Попробуйте все это на практике: сложного ничего нет, а практической пользы очень много.</p>
      <h3>Методологии разработки</h3>
      <p>Так как работать разработчику приходится в команде, то и взаимодействие внутри нее всегда организовано в виде конкретного системного подхода. Сегодня балом правит Agile — набор гибких принципов, на основе которых строятся популярные методологии. Достаточно знать две самых распространенных из них: Scrum и Kanban.</p>
      <p>Scrum основан на делении всего процесса на итерации, где в конце каждой команда готова предоставить результирующую демо-версию продукта с новым готовым функционалом.</p>
      <p>У Kanban в основе визуализация процесса выполнения задач в виде трех колонок таблицы: To do, Doing, Done. Основная идея — уменьшать количество запланированных задач (куда уж банальнее) и постепенно перемещать их из колонки «To do» в «Done». Очень подходит для проектов, находящихся в стадии поддержки, где основной функционал уже разработан и остались минимальные доработки и багфиксинг.</p>
      <p>У каждой из методологий много своих терминов и нюансов, но я не уверен, что джуну это необходимо. Знакомиться с ними гораздо интереснее в процессе работы, поэтому сильно углубляться в теорию не рекомендую.</p>
      <h3>Подготовка и процесс собеседования</h3>
      <p>Перечисленных профильных знаний будет достаточно для того, чтобы уверенно держаться на любом собеседовании на позицию Junior Java Developer.</p>
      <p>По моему личному опыту, на позицию Middle они тоже не особо отличаются по сложности. Главное — понимать, что мидла от джуна отличает количество кода, который он сам писал и видел. Мидл задает на порядок меньше вопросов в процессе работы, быстрее «вкатывается» в проект, быстрее разбирается во внутренних зависимостях. Если вы считаете, что подучите чуть больше и можно попробовать себя на позицию мидла, немного приукрасив опыт в резюме, то это не так. И даже если получится пройти собеседование, то испытательный срок все покажет как есть. Помимо подтягивания теоретических навыков, на позицию мидла «с нуля» (с точки зрения опыта продакшена) можно прыгнуть только в случае работы над опенсорс проектами и самостоятельного изучения практических нюансов. Придется пережить этап, когда каждый первый ваш коммит в опенсорс будут отклонять как некачественный или незначительный.</p>
      <p>На Junior-позицию очень часто дают тестовые задания. Чаще всего, чтобы увидеть, как в вашем коде будет организовано взаимодействие между классами и какая логика куда будет вынесена. И уже потом посмотрят на выполнение программой требуемых функций. Для некоторых задач не лишним также будет наличие тестов.</p>
      <p>На джава-форумах и каналах иногда просят оценить структуру готового домашнего проекта, чтобы понять, насколько все плохо/хорошо. Я считаю это хорошим подходом. Также неплохая книга для понимания таких основ — <a href="https://www.amazon.com/Thinking-Java-4th-Bruce-Eckel/dp/0131872486">Thinking in Java</a> Эккеля.</p>
      <p>Процесс собеседования не отличается от такового на любую другую работу. Программисты любят подлавливать на неточностях, задавая вопросы из практической плоскости, если конкретная теория начинает хромать. Это иногда создает очень полезную для соискателя дискуссию.</p>
      <p>Один из качественных советов, который я получил на начальном этапе своей карьеры — самому вести разговор в ту тему, в которой разбираешься. И не давать тем самым повод собеседующему постоянно задавать ритм и направление разговора.</p>
      <p>У такой стратегии есть следствие: если вы решили блеснуть каким-то малоизвестным термином, то в подавляющем большинстве случаев готовьтесь о нем рассказать. Ведь ваш интервьюер прошел тот же самый путь обучения и приблизительно знает, в чем вы разбираетесь хорошо на конкретном этапе своего развития, а в чем не очень.</p>
      <p>На вопросы предпочтительно давать развернутые ответы, так как проверяются также навыки коммуникации. Чаще всего, перед вами сидит человек, с которым вы будете работать в одной команде. И общаться, и отвечать уже на похожие вопросы, но по проекту. Этот человек присматривается, как это будет выглядеть на ежедневной основе. Поэтому данный пункт достаточно важен.</p>
      <p>Также не стоит быть очень категоричным в ответах. Возможно JavaScript, который вы случайно упомянули в не очень хорошем свете, неожиданно используется на проекте и станет решающим фактором, который сыграет роль в принятии решения по вашему трудоустройству.</p>
      <p>Если после собеседования у вас остались вопросы, то обязательно их задавайте. Например, на какой стадии разработки находится проект в данный момент? Какие технологии стоит подтянуть до выхода на работу? У эйчара можно спросить про условия отпусков и больничных, предполагаемый карьерный рост в компании, через какой период происходит пересмотр зарплаты. Естественно, будучи джуном, сильно торговаться на этот счет не получится, но по ответам можно понять отношение компании к своим работникам и принять правильный выбор.</p>
      <h3>В завершение</h3>
      <p>Надеюсь, изложенной в данном цикле информации будет достаточно, чтобы прояснить какие-то нюансы подготовки и поспособствовать дальнейшему становлению хотя бы нескольких Java-разработчиков. Возможно он подтолкнет не сдаваться тех, кто не прошел на заветную позицию с первого раза.</p>
      <p>Дорогу осилит идущий. Удачи!</p>
      <p>При возникновении вопросов, пообщаться со мной можно в телеграме: @liohamitec</p>
      <p>Темы: <a href="https://dou.ua/lenta/tags/Java/">Java</a>, <a href="https://dou.ua/lenta/tags/junior/">junior</a>, <a href="https://dou.ua/lenta/tags/%D1%81%D0%B0%D0%BC%D0%BE%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">самообразование</a>, <a href="https://dou.ua/lenta/tags/%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">собеседование</a></p>
    </article>
  </body>
</html>