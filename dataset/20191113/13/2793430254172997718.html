<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://habr.com/en/company/mailru/blog/475686/"/>
    <meta property="og:site_name" content="Habr"/>
    <meta property="article:published_time" content="2019-11-13T13:31:14+00:00"/>
    <meta property="og:title" content="Tips and tricks from my Telegram-channel @pythonetc, October 2019"/>
    <meta property="og:description" content="It is a new selection of tips and tricks about Python and programming from my Telegram-channel @pythonetc. ← Previous publications If you want to iterate o..."/>
  </head>
  <body>
    <article>
      <h1>Tips and tricks from my Telegram-channel @pythonetc, October 2019</h1>
      <address><time datetime="2019-11-13T13:31:14+00:00">13 Nov 2019, 13:31</time> by <a rel="author" href="https://habr.com/en/users/pushtaev/" target="_blank">pushtaev</a></address>
      <figure>
        <img src="https://habrastorage.org/webt/90/ga/j4/90gaj4gu_78m4k1xjyjkdxqbxoy.jpeg"/>
      </figure>
      <p>It is a new selection of tips and tricks about Python and programming from my Telegram-channel @pythonetc.<br/><br/>←<a href="https://habr.com/en/search/?q=pythonetc#h"> Previous publications</a></p>
      <figure>
        <img src="https://habrastorage.org/getpro/habr/post_images/208/1cc/1fa/2081cc1fa6dbebbbb6ddd4108512ff5b.png"/>
      </figure>
      <p>If you want to iterate over several iterables at once, you can use the <code>zip</code> function (it has nothing to do with ZIP file format):</p>
      <pre>from datetime import timedelta<br/><br/>names = [<br/>    'Eleven. Return and Revert',<br/>    'Wilderness',<br/>    'The Menagerie Inside',<br/>    'Evaporate',<br/>]<br/><br/>years = [<br/>    2010,<br/>    2013,<br/>    2015,<br/>    2018,<br/>]<br/><br/>durations = [<br/>    timedelta(minutes=57, seconds=38),<br/>    timedelta(minutes=48, seconds=5),<br/>    timedelta(minutes=46, seconds=34),<br/>    timedelta(minutes=43, seconds=25),<br/>]<br/><br/>print('Midas Fall LPs:')<br/>for name, year, duration in zip(<br/>    names, years, durations<br/>):<br/>    print(f'  * {name} ({year}) — {duration}')</pre>
      <p>Output:</p>
      <pre>Midas Fall LPs:<br/>  * Eleven. Return and Revert (2010) — 0:57:38<br/>  * Wilderness (2013) — 0:48:05<br/>  * The Menagerie Inside (2015) — 0:46:34<br/>  * Evaporate (2018) — 0:43:25</pre>
      <figure>
        <img src="https://habrastorage.org/getpro/habr/post_images/208/1cc/1fa/2081cc1fa6dbebbbb6ddd4108512ff5b.png"/>
      </figure>
      <p>A generator can be stopped. You can explicitly call <code>g.close()</code> but usually garbage collector does that for you. Once <code>close</code> is called, the <code>GeneratorExit</code> is raised at the point where the generator function was paused:</p>
      <pre>def gen():<br/>    try:<br/>        yield 1<br/>        yield 2<br/>    finally:<br/>        print('END')<br/><br/><br/>g = gen()<br/>print(next(g))  # prints '1'<br/>g.close()  # prints 'END'</pre>
      <p>Mind three things. First, you can’t yield values while handling <code>GeneratorExit</code>:</p>
      <pre>def gen():<br/>    try:<br/>        yield 1<br/>    finally:<br/>        yield 3<br/><br/><br/>g = gen()<br/>next(g)<br/>g.close()  # RuntimeError</pre>
      <p>Second, the exception is not raised if a generator is not yet started, but the generator still becomes stopped:</p>
      <pre>def gen():<br/>    try:<br/>        yield 1<br/>    finally:<br/>        print('END')<br/><br/><br/>g = gen()<br/>g.close()  # nothing<br/>print(list(g))  # prints '[]'</pre>
      <p>Third, <code>close</code> does nothing if a generator is already finished:</p>
      <pre>def gen():<br/>    try:<br/>        yield 1<br/>        yield 2<br/>    finally:<br/>        print('END')<br/><br/><br/>g = gen()<br/>print(list(g))<br/>print('Closing now')<br/>g.close()<br/><br/># END<br/># [1, 2]<br/># Closing now</pre>
      <figure>
        <img src="https://habrastorage.org/getpro/habr/post_images/208/1cc/1fa/2081cc1fa6dbebbbb6ddd4108512ff5b.png"/>
      </figure>
      <p>f-strings allow you to specify the width for the printed value as well as other format specifiers:</p>
      <pre>&gt;&gt;&gt; x = 42<br/>&gt;&gt;&gt; f'{x:5}+{x:15f}'<br/>'   42+      42.000000'</pre>
      <p>They can also contain evaluated expressions which can be useful when width is unknown upfront:</p>
      <pre>def print_table(matrix):<br/>    cols_width = [<br/>        max(len(str(row[col])) for row in matrix)<br/>        for col in range(len(matrix[0]))<br/>    ]<br/><br/>    for row in matrix:<br/>        for i, cell in enumerate(row):<br/>            print(<br/>                f'{cell:{cols_width[i]}} ',<br/>                end=''<br/>            )<br/>        print()<br/><br/>albums = [<br/>    ['Eleven. Return and Revert', 2010],<br/>    ['Wilderness', 2013],<br/>    ['The Menagerie Inside', 2015],<br/>    ['Evaporate', 2018],<br/>]<br/><br/>print_table(albums)</pre>
      <p>Output:</p>
      <pre>Eleven. Return and Revert 2010<br/>Wilderness                2013<br/>The Menagerie Inside      2015<br/>Evaporate                 2018</pre>
      <figure>
        <img src="https://habrastorage.org/getpro/habr/post_images/208/1cc/1fa/2081cc1fa6dbebbbb6ddd4108512ff5b.png"/>
      </figure>
      <p>If your class is derived from another, the metaclass of your class have to be also derived from the metaclass of that class:</p>
      <pre>from collections import UserDict<br/>from abc import ABCMeta<br/><br/># ABCMeta is a metaclass of UserDict<br/>class MyDictMeta(ABCMeta):<br/>    def __new__(cls, name, bases, dct):<br/>        return super().__new__(cls, name, bases, dct)<br/><br/>class MyDict(UserDict, metaclass=MyDictMeta):<br/>    pass</pre>
      <p>It may be a good idea to get the metaclass of that other class automatically:</p>
      <pre>def create_my_dict_class(parents):<br/>    class MyDictMeta(*[type(c) for c in parents]):<br/>        def __new__(cls, name, bases, dct):<br/>            return super().__new__(cls, name, bases, dct)<br/><br/>    class MyDict(*parents, metaclass=MyDictMeta):<br/>        pass<br/><br/><br/>MyDict = create_my_dict_class((UserDict,))</pre>
      <figure>
        <img src="https://habrastorage.org/getpro/habr/post_images/208/1cc/1fa/2081cc1fa6dbebbbb6ddd4108512ff5b.png"/>
      </figure>
      <p><code>__init__</code> allows you to modify an object right after the creation. If you want to control what is created you should use <code>__new__</code> instead:</p>
      <pre>from typing import Tuple, Dict<br/>from cached_property import cached_property<br/><br/><br/>class Numbers:<br/>    _LOADED: Dict[Tuple[int, ...], 'Numbers'] = {}<br/><br/>    def __new__(cls, ints: Tuple[int, ...]):<br/>        if ints not in cls._LOADED:<br/>            obj = super().__new__(cls)<br/>            cls._LOADED[ints] = obj<br/><br/>        return cls._LOADED[ints]<br/><br/>    def __init__(self, ints: Tuple[int, ...]):<br/>        self._ints = ints<br/><br/>    @cached_property<br/>    def biggest(self):<br/>        print('calculating...')<br/>        return max(self._ints)<br/><br/><br/>print(Numbers((4, 3, 5)).biggest)<br/>print(Numbers((4, 3, 5)).biggest)<br/>print(Numbers((4, 3, 6)).biggest)<br/></pre>
      <related>
        <h4>Similar posts</h4>
        <a href="https://habr.com/en/post/444228/"/>
        <a href="https://habr.com/en/post/438776/"/>
        <a href="https://habr.com/en/post/436324/"/>
      </related>
    </article>
  </body>
</html>