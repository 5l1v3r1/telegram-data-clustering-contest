<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://www.heise.de/developer/artikel/Einstieg-in-SwiftUI-4594018.html"/>
    <meta property="og:site_name" content="Developer"/>
    <meta property="article:published_time" content="2019-11-22T05:05:00+00:00"/>
    <meta property="og:title" content="Einstieg in SwiftUI"/>
    <meta property="og:description" content="Mit SwiftUI möchte Apple das Erstellen von Benutzeroberflächen für die eigenen Plattformen revolutionieren. Doch kann das Vorhaben tatsächlich gelingen? Und welche Abstriche müssen Apple Developer in Kauf nehmen, wenn sie auf SwiftUI setzen?"/>
  </head>
  <body>
    <article>
      <h1>Einstieg in SwiftUI</h1>
      <h2>Mit SwiftUI möchte Apple das Erstellen von Benutzeroberflächen für die eigenen Plattformen revolutionieren. Doch kann das Vorhaben tatsächlich gelingen? Und welche Abstriche müssen Apple Developer in Kauf nehmen, wenn sie auf SwiftUI setzen? </h2>
      <address><time datetime="2019-11-22T05:05:00+00:00">22 Nov 2019, 05:05</time> by <a rel="author">Thomas Sillmann</a></address>
      <p>Vorbei sind die Zeiten, in denen man Views sowohl im Code als auch in Interface-Dateien getrennt voneinander erstellte und konfigurierte. View-Controller, die in der Regel den Großteil bisheriger App-Projekte ausmachen, sollen ebenfalls dank SwiftUI so gut wie ausgedient haben. Stattdessen kommen Views zum Einsatz, die Daten anhand ihres Status und ihrer Model-Informationen in geeigneter Form präsentieren.</p>
      <p>SwiftUI bringt ein umfangreiches Set an System-Views mit, die sich in allen aktuellen Plattformen von Apple verwenden lassen. Dazu gehören unter anderem Labels, Buttons, Switches und Listen. Abhängig vom Betriebssystem, unter dem sie verwendet werden, passt sich ihr Erscheinungsbild automatisch an. Das Erstellen der Views läuft indes (von kleineren Details abgesehen) identisch ab. Ein Button wird also mit SwiftUI immer auf die gleiche Weise für macOS, iOS, iPadOS, watchOS und tvOS gebaut.</p>
      <p>Mit SwiftUI erstellte Views basieren auf dem <code>View</code>-Protokoll. Das setzt zwingend die Implementierung einer sogenannten <code>body</code>-Property voraus. Diese enthält das Aussehen und die Funktionsweise einer View. Eine Ansicht, die ein simples "Hello world" ausgibt, lässt sich so mit folgendem Code erstellen:</p>
      <pre>struct HelloWorldView: View {<br/>    var body: some View {<br/>        Text("Hello world")<br/>    }<br/>}</pre>
      <p>Der Typ der <code>body</code>-Property entspricht <code>some View</code>. Damit bringt man zum Ausdruck, dass diese Property selbst eine View zurückliefert, ohne dass man den exakten Typ der View angibt. Bei <code>Text</code> handelt es sich um einen Typ aus dem SwiftUI-Framework, der zum Erstellen von Labels dient und beim Initialisieren einen String mit dem anzuzeigenden Text erwartet.</p>
      <p>Wie eine solche View aussieht, lässt sich direkt in Xcode 11 überprüfen. Dafür kommt ein neues Feature namens Preview zum Einsatz, das den Editor-Bereich in zwei Abschnitte aufteilt. Auf der linken Seite ist der Code zu sehen, rechts eine Vorschau der View. Um die zu erstellen, ist einmalig die Resume-Schaltfläche am oberen rechten Rand des zweiten Editor-Abschnitts zu betätigen. Xcode kompiliert daraufhin das Projekt und zeigt im Anschluss die erstellte View an (s. Abb. 1).</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/3/5/7/6/01-11d8e5c414a4d17d.png"/>
        <figcaption>Die Preview zeigt eine Vorschau von mit SwiftUI erstellten Views an (Abb. 1).</figcaption>
      </figure>
      <p>Änderungen an der View werden nun unmittelbar in der Vorschauansicht übernommen. Einzige Ausnahme bilden komplexere Änderungen innerhalb der View wie das Hinzufügen von Properties. Das erfordert ein erneutes Kompilieren des Projekts, weshalb man die Preview dann mittels erneutem Klick auf die wieder erscheinende Resume-Schaltfläche händisch aktualisieren muss.</p>
      <p>Sollte der Preview-Bereich nicht angezeigt werden, lässt er sich jederzeit über die in Xcode 11 neu eingeführten Editor Options einblenden. Dort muss die Einstellung "Canvas" aktiv sein, damit die Preview sichtbar ist. Wen sie stört, hat über diese Einstellung umgekehrt die Möglichkeit, die Preview auch vollständig auszublenden.</p>
      <h3>Views gruppieren</h3>
      <p>Im bisher gezeigten Beispiel wurde ein einfaches Label erstellt. In den meisten Fällen setzen sich Views aber aus mehreren verschiedenen Elementen zusammen, die man miteinander gruppiert. In SwiftUI setzen Entwickler eine solche Gruppierung mit Stacks um. Die gibt es in drei Ausführungen: als V-, H- und Z-Stack. Ein V-Stack ordnet Views vertikal an, ein H-Stack horizontal. Mit einem Z-Stack legt man Views hintereinander ab und stapelt sie so aufeinander (ideal beispielsweise, um einen Text über eine im Hintergrund befindliche Grafik zu legen).</p>
      <p>Um einen der genannten Stacks in SwiftUI zu erzeugen, nutzt man die zugehörigen Typen: <code>VStack</code>, <code>HStack</code> oder <code>ZStack</code>. Sie erwarten beim Erstellen neuer Instanzen ein Closure als Parameter. Darin werden alle Views untergebracht, die Teil des jeweiligen Stacks sind. Hierbei ist auch eine Verschachtelung von Stacks möglich. Beispielsweise kann ein H-Stack einen V-Stack als View enthalten und umgekehrt.</p>
      <p>Das folgende Codebeispiel demonstriert den Einsatz der genannten Stacks und stellt zugleich ein weiteres View-Element aus dem SwiftUI-Framework vor: <code>Image</code>. Wie der Name andeutet, lassen sich damit Bilder in Ansichten einbetten. Dazu können Entwickler sowohl auf Bilder innerhalb von Asset Catalogs als auch auf die Grafiken der SF-Symbols-Bibliothek zugreifen. Um letztere zu verwenden, kommt der Initializer <code>init(systemName:)</code> zum Einsatz, der die Bezeichnung des gewünschten SF-Symbols als Parameter entgegennimmt.</p>
      <pre>struct ContentView: View {<br/>    var body: some View {<br/>        VStack {<br/>            Text("Hello world")<br/>            HStack {<br/>                Text("Text with image:")<br/>                Image(systemName: "house.fill")<br/>            }<br/>            Image("Graz")<br/>        }<br/>    }<br/>}</pre>
      <p>Das Ergebnis des Codebeispiels ist in der Preview in Abbildung 2 zu sehen. Der Aufbau ist wie folgt: Herzstück der View ist ein V-Stack, der über insgesamt drei Views verfügt, die untereinander angeordnet werden. An oberster Stelle befindet sich ein Text, am Ende wird ein Bild angezeigt. Dazwischen kommt ein H-Stack zum Einsatz, der einen Text und eine Grafik aus der SF-Symbols-Bibliothek nebeneinander darstellt.</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/3/5/7/6/02-49e456fb622ea691.png"/>
        <figcaption>Mit den Stacks gruppiert man mehrere Views und ordnet sie in der gewünschten Form an (Abb. 2).</figcaption>
      </figure>
      <p>Beim Erstellen von Views in SwiftUI spielen Stacks eine essenzielle Rolle. Durch sie gruppiert man mehrere Views miteinander und ordnet sie auf die gewünschte Art und Weise an.</p>
      <h4>View-Modifikationen</h4>
      <p>Alle eingesetzten Views haben ihre Konfigurtionen bei ihrer Initialisierung erhalten. Stacks wurden hierbei die zugehörigen Ansichten übergeben, während <code>Text</code>- und <code>Image</code>-Elemente die passenden Inhalte erhielten. Um Views in SwiftUI aber weiter anzupassen – beispielsweise zum Festlegen einerTextgröße oder -farbe –, gibt es die sogenannten Modifier. Das sind Methode, die bestimmte Anpassungen an einer View durchführen. Als Ergebnis liefert ein Modifier eine neue View zurück, die die gewünschten Modifikationen enthält.</p>
      <p>Das SwiftUI-Framework enthält eine Vielzahl solcher Modifier. Welche es konkret für einen bestimmten Typ wie <code>Text</code> oder <code>Image</code> gibt, lässt sich anhand der Dokumentation ermitteln. Beispielhaft präsentiert der Artikel eine kleine Auswahl der verfügbaren Modifier. Betrachtet sei zunächst das <code>Text</code>-Element. Die folgende Liste gibt einen kleinen Überblick, welche Anpassungsmöglichkeiten unter anderem dank der verfügbaren Modifier zur Verfügung stehen:</p>
      <ul>
        <li>Ändern der Textfarbe: <code>foregroundColor(_:)</code></li>
        <li>Ändern der Schriftstärke: <code>fontWeight(_:)</code></li>
        <li>Ändern der Schriftformatierung (als Titel, Untertitel etc.): <code>font(_:)</code></li>
        <li>fett: <code>bold()</code></li>
        <li>kursiv: <code>italic()</code></li>
        <li>unterstrichen: <code>underline()</code></li>
      </ul>
      <p>Um eine der Anpassungen an einer <code>Text</code>-Instanz vorzunehmen, ruft man den gewünschten Modifier schlicht darauf auf. Um mehrere Änderungen auf einmal durchzuführen, reiht man alle zugehörigen Modifier aneinander. Möchte man so beispielsweise einen Text fett formatieren und kursiv setzen, führt man den folgenden Befehl aus:</p>
      <pre>Text("Hello world").bold().italic()</pre>
      <p>Bei der Arbeit mit SwiftUI setzt man jeden Modifier typischerweise in eine neue Zeile und rückt ihn ein. Das sorgt für eine bessere Übersichtlichkeit (dazu gleich mehr). Ein vollständiges Beispiel des Einsatzes mehrerer Modifier finden Entwickler im folgenden Codestück. Dort gibt es neben den genannten Methoden zur Anpassung von <code>Text</code>-Instanzen Modifier für die Konfiguration von Bildern. So kann man deren Größe durch den Aufruf von <code>resizable()</code> anpassen und den gewünschten Frame mit <code>frame(width:height:alignment:)</code> setzen. Um die Ecken von Grafiken abzurunden, nutzt man die Methode <code>cornerRadius(_:)</code>.</p>
      <pre>struct ContentView: View {<br/>    var body: some View {<br/>        VStack {<br/>            Text("Hello world")<br/>                .foregroundColor(.blue)<br/>                .font(.largeTitle)<br/>                .fontWeight(.heavy)<br/>                .underline()<br/>            HStack {<br/>                Text("Text with image:")<br/>                    .italic()<br/>                Image(systemName: "house.fill")<br/>                    .resizable()<br/>                    .foregroundColor(.green)<br/>                    .frame(width: 50, height: 50)<br/>            }<br/>            Image("Graz")<br/>                .cornerRadius(10.0)<br/>        }<br/>    }<br/>}<br/></pre>
      <h3>Anpassung über Library und Preview</h3>
      <p>Eine View muss man jedoch nicht ausschließlich im Code erstellen. Mit der Library von Xcode haben Entwickler Zugriff auf die verfügbaren Views und Modifier und können sie direkt daraus einer SwiftUI-View hinzufügen. Dazu ziehen sie einfach wie gewohnt das gewünschte Element direkt an die passende Stelle im Code. Views und Modifier werden hierbei getrennt voneinander in der Library aufgeführt und besitzen jeweils einen eigenen Reiter (s. Abb. 3).</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/3/5/7/6/03-c9749a580ee96c66.png"/>
        <figcaption>Über die Library haben Entwickler Zugriff auf verschiedene Views sowie Modifier, die sie direkt mittels Drag &amp; Drop im Code oder über die Preview hinzufügen können (Abb. 3).</figcaption>
      </figure>
      <p>Die Library ist übrigens nicht nur praktisch, um Elemente aus ihr via Drag &amp; Drop einer View hinzuzufügen. Sie bietet auch einen Überblick über die verfügbaren Elemente des SwiftUI-Frameworks. Insbesondere die Liste der Modifier ist für den Einstieg hilfreich, nicht zuletzt da die Library über eine Suchfunktion verfügt. Zum Beispiel lässt sich schnell ermitteln, welche Möglichkeiten zur Anpassung von Schriften in SwiftUI zur Verfügung stehen (s. Abb. 4).</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/3/5/7/6/04-8372bc741f8e128d.png"/>
        <figcaption>Dank der praktischen Suchfunktion der Library kann man unter anderem in Erfahrung bringen, welche Modifier für bestimmte Aufgaben geeignet sind (Abb. 4).</figcaption>
      </figure>
      <p>Neben der Library haben Entwickler aber auch die Möglichkeit, diverse Anpassungen an Views über die in Xcode integrierte Preview vorzunehmen. Dazu wählen sie das gewünschte Element aus (z.B. einen Text oder ein Bild) und wechseln in den Attributes Inspector. Dort findet man – ähnlich wie man das aus der Arbeit mit Storyboards kennt – diverse Konfigurationsmöglichkeiten (welche genau das sind, hängt von der gewählten View ab). Bei <code>Text</code>-Instanzen beispielsweise können Entwickler unter anderem die Farbe und Formatierung festlegen (s. Abb. 5). Auch ist es möglich, Views und Modifier aus der Library statt im Code an der gewünschten Stelle in der Preview einzufügen.</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/3/5/7/6/05-368d2854e3e62755.png"/>
        <figcaption>Nach Auswahl eines Elements können Entwickler es auch über den Attributes Inspector konfigurieren (Abb. 5).</figcaption>
      </figure>
      <p>Wer mit der Preview gearbeitet und Anpassungen vorgenommen hat, dem fällt womöglich auf, dass sich jede Änderung in der Vorschau unmittelbar auf den Code auswirkt. Ändert man beispielsweise die Farbe eines Texts über den Attributes Inspector, wird im Code der View der passende Modifier automatisch ergänzt. Diese Systematik hängt damit zusammen, dass es in SwiftUI keine Trennung zwischen Code und Interface-Dateien gibt, so wie das bei der Arbeit mit Storyboards der Fall ist. Tatsächlich zählt bei einer SwiftUI-View nur der Code. Die von Xcode generierte Preview ist ein Spiegel des Codes, und deshalb führen Anpassungen an ihr auch immer zu einer zugehörigen Anpassung des Quelltexts.</p>
      <h4>Views und ihr Status</h4>
      <p>Unter SwiftUI fällt die Rolle des View-Controllers weg. Stattdessen werden Daten, die eine View darstellen oder verarbeiten soll, direkt an diese weitergegeben. Solche Daten, die für die Darstellung einer View und für ihre Funktionsweise verantwortlich sind, bezeichnet man als "source of truth". Ihre einfachste Form stellt eine Property dar. Sie spiegelt einen Status einer View wider, der bei Initialisierung der View festgelegt wird. In Properties gespeicherte Daten werden somit also von außen gesetzt und sind anschließend unveränderbar.</p>
      <p>Ein einfaches Beispiel für den Einsatz von Daten auf Basis einer Property zeigt das folgende Codebeispiel. Die "source of truth" stellt hier die <code>title</code>-Property dar, für die ein passender Wert beim Initialisieren einer <code>ContentView</code>-Instanz zu übergeben ist. Die View zeigt ein simples Label an, dessen Inhalt sich auf die <code>title</code>-Property bezieht.</p>
      <pre>struct ContentView: View {<br/><br/>    var title: String<br/><br/>    var body: some View {<br/>        Text(title)<br/>    }<br/><br/>}<br/><br/>let myContentView = ContentView(title: "Hello world")</pre>
      <p>Wie aber geht man mit Daten um, die veränderbar sind? Als Beispiel soll eine View mit einem Text und einem Button umgesetzt werden. Der Text wird standardmäßig als Headline formatiert, lässt sich alternativ aber auch als Large Title darstellen. Diese Einstellung soll in einer Property namens <code>useLargeTitle</code> gespeichert und bei Betätigen des Buttons invertiert werden.</p>
      <p>Um das zu ermöglichen, ist eine entsprechende Property (in diesem Fall <code>useLargeTitle</code>) mit dem Property Wrapper <code>@State</code> zu deklarieren. Er bringt zum Ausdruck, dass die Property eine veränderbare Statusinformation enthält, die wichtig für die Darstellung der View ist. Das hat zur Folge, dass bei einer Änderung einer solchen <code>@State</code>-Property die View neu gezeichnet wird. Bei Betätigung des Buttons brauchen Entwickler also nur die <code>useLargeTitle</code>-Property zu ändern, und die View wird im Anschluss passend aktualisiert; ein expliziter Reload ist von Entwicklerseite nicht nötig.</p>
      <p>Zwei Dinge sind beim Einsatz von <code>@State</code> zu beachten: So deklarierte Properties müssen immer über einen Standardwert verfügen und werden typischerweise als <code>private</code> gekennzeichnet. Letzteres hängt damit zusammen, dass <code>@State</code>-Properties nur für Daten genutzt werden sollen, die explizit mit der View zusammenhängen. Sie werden also beispielsweise nicht dazu verwendet, um Informationen aus dem Model zu laden und zu speichern.</p>
      <p>Wie der Einsatz von <code>@State</code> beispielhaft aussehen kann, zeigt das nächste Codebeispiel. Die <code>useLargeTitle</code>-Property ist passend deklariert und besitzt den Standardwert <code>false</code>. In der Implementierung der <code>body</code>-Property der View wird dann innerhalb eines V-Stacks zunächst der Wert der <code>useLargeTitle</code>-Property überprüft und abhängig vom Ergebnis eine von zwei <code>Text</code>-Varianten erstellt. Im Anschluss folgt noch die Erstellung der Schaltfläche mit dem SwiftUI-Typ <code>Button</code>. Der erwartet zwei Parameter, bei denen es sich um Closures handelt. Das erste definiert die Aktionen, die bei Betätigung des Buttons ausgeführt werden sollen (in dem Fall eine Invertierung der <code>useLargeTitle</code>-Property). Das zweite Closure definiert das Aussehen des Buttons. Im Beispiel wird dazu ein simpler Text mit dem Inhalt "Change presentation" genutzt:</p>
      <pre>struct ContentView: View {<br/><br/>    @State private var useLargeTitle = false<br/><br/>    var body: some View {<br/>        VStack {<br/>            if useLargeTitle {<br/>                Text("Hello world")<br/>                    .font(.largeTitle)<br/>            } else {<br/>                Text("Hello world")<br/>                    .font(.headline)<br/>            }<br/>            Button(action: {<br/>                self.useLargeTitle.toggle()<br/>            }) {<br/>                Text("Change presentation")<br/>            }<br/>        }<br/>    }<br/><br/>}</pre>
      <p>Neben diesen beiden gezeigten Varianten gibt es noch eine dritte Möglichkeit, einen veränderbaren Status einer View abzubilden. Sie funktioniert wie der Einsatz von <code>@State</code>, allerdings mit dem Unterschied, dass die View diese Statusinformation nicht selbst hält. Sie wird stattdessen von einer anderen View gespeichert.</p>
      <p>Zum besseren Verständnis soll das Thema anhand des nächsten Beispiels erläutert werden. Basis ist die <code>ContentView</code>, die über eine <code>@State</code>-Property namens <code>isActive</code> verfügt. Anhand dieser Information wird entweder der Text "aktiv" oder "inaktiv" innerhalb der View ausgegeben.</p>
      <pre>struct ContentView: View {<br/><br/>    @State var isActive = false<br/><br/>    var body: some View {<br/>        HStack {<br/>            Text(isActive ? "Aktiv" : "Inaktiv")<br/>            StarButton(isActive: $isActive)<br/>        }<br/>    }<br/><br/>}<br/><br/>struct StarButton: View {<br/><br/>    @Binding var isActive: Bool<br/><br/>    var body: some View {<br/>        Button(action: {<br/>            self.isActive.toggle()<br/>        }) {<br/>            Image(systemName: isActive ? "star.fill" : "star")<br/>        }<br/>    }<br/><br/>}</pre>
      <p>Daneben besitzt <code>ContentView</code> ein weiteres Element, das neben dem Text angezeigt wird. Es handelt sich um eine zweite eigens kreierte View namens <code>StarButton</code>. Sie stellt eine simple Schaltfläche dar, die entweder einen gefüllten oder ungefüllten Stern anzeigt. Gespeichert ist diese Informationebenfalls in einer Property namens <code>isActive</code>. Bei Betätigung des Buttons wird der Wert jener Property invertiert.</p>
      <p>Gegeben sind somit zwei Views, die beide als Status jeweils eine eigene <code>isActive</code>-Property besitzen. In diesem Szenario ist der Wert der <code>isActive</code>-Property des <code>StarButton</code> aber einzig und allein von der <code>ContentView</code> abhängig. Sie bestimmt über ihre eigene <code>isActive</code>-Property, ob die Schaltfläche aktiv ist oder nicht. <code>StarButton</code> muss also nicht selbst diese Information speichern, sondern stattdessen auf die aus der <code>ContentView</code> zurückgreifen, sie auslesen und bei Betätigung verändern.</p>
      <p>Um das umzusetzen, nutzen Entwickler den Property-Wrapper <code>@Binding</code>. Damit deklarieren sie Properties, die einen Status einer View widerspiegeln, die entsprechende Information aber von einer anderen Stelle erhalten (in diesem Fall von der <code>ContentView</code>). Im Gegensatz zu <code>@State</code>-Properties besitzen solche auf Basis von <code>@Binding</code> keinen Standardwert und werden auch nicht als <code>private</code> gekennzeichnet (schließlich ist eine entsprechende Information für diese Properties zwingend von außen an die View übergeben).</p>
      <p><code>@Binding</code>-Properties lassen sich nur anderen Status-Properties zuweisen (also beispielsweise solche, die mit <code>@State</code> deklariert sind). Bei einer solchen Zuweisung ist zusätzlich der jeweiligen Status-Property ein <code>$</code>-Zeichen voranzustellen.</p>
      <p>Zum besseren Verständnis sollen die drei genannten Vorgehensweisen zum Abbilden eines View-Status noch einmal zusammenfasst werden:</p>
      <ul>
        <li>Property: nicht veränderbare Daten einer View. Sie werden einmalig bei der Initialisierung übergeben</li>
        <li><code>@State</code>-Property: veränderbare Daten einer View. Sie werden typischerweise als <code>private</code> deklariert und benötigen zwingend einen Standardwert.</li>
        <li><code>@Binding</code>-Property: veränderbare Daten einer View. Die entsprechende Information ist in einer anderen View gespeichert.</li>
      </ul>
      <p>Gemein ist allen drei, dass sie sich auf Daten beziehen, die eng mit der jeweiligen View verzahnt und unabhängig vom Model einer App sind.</p>
      <h3>@Binding in SwiftUI</h3>
      <p>Properties auf Basis von <code>@Binding</code> finden sich übrigens an vielen Stellen im SwiftUI-Framework wieder. Betrachtet sei hier als Beispiel die View <code>Toggle</code>, die zum Abbilden von Schaltern dient. Jede <code>Toggle</code>-Instanz benötigt eine <code>@Binding</code>-Property vom Typ <code>Bool</code> als Parameter. Diese nutzt <code>Toggle</code> dazu, einerseits die initiale Darstellung festzulegen (an oder aus) sowie bei einer Änderung die übergebene Datenbasis zu verändern.</p>
      <p>Da eine View wie <code>Toggle</code> an den unterschiedlichsten Stellen zum Einsatz kommt und hierbei immer eine andere Datenbasis nutzt, ist die Verwendung einer <code>@Binding</code>-Property ideal. So weiß <code>Toggle</code> lediglich, wo sich die Daten befinden, die für das Erscheinungsbild des Schalters verantwortlich sind, und kann diese bei Betätigen des Schalters direkt anpassen. Der praktische Einsatz von <code>Toggle</code> ist in einem kleinen Beispiel demonstriert:</p>
      <pre>struct ContentView: View {<br/><br/>    @State var isActive = false<br/><br/>    var body: some View {<br/>        Toggle(isOn: $isActive) {<br/>            Text("Schalter")<br/>        }<br/>    }<br/><br/>}</pre>
      <h4>Umgang mit externen Daten</h4>
      <p>Mit Properties, <code>@State</code> und <code>@Binding</code> haben Entwickler drei Möglichkeiten kennengelernt, um Informationen abzubilden, die direkter Teil einer View sind. Doch was ist mit jenen Daten, die nicht explizit zu einer View gehören und stattdessen aus einer externen Quelle stammen, beispielsweise dem Model einer App? Für derartige Daten kommt der Property Wrapper <code>@ObservedObject</code> zum Einsatz. Er wird genauso eingesetzt wie der Property Wrapper <code>@State</code>, nur dass die zugehörigen Daten hier aus einer externen Quelle stammen und nicht Bestandteil einer View sind.</p>
      <p>Bevor man allerdings externe Daten in SwiftUI verwenden kann, sind die noch entsprechend vorzubereiten. Dazu muss man die Daten in Form einer Klasse abbilden, die konform zum <code>ObservableObject</code>-Protokoll ist. Zusätzlich versieht man jede Property innerhalb der Klasse, bei deren Änderung eine Aktualisierung einer View erfolgen soll, mit dem Property Wrapper <code>@Published</code>. Damit besitzt das System alle Informationen, die es benötigt, um die externen Daten als Basis für SwiftUI zu nutzen. Ändern sich mit <code>@Published</code> deklarierte Properties, werden Views, die auf diesen Daten basieren, entsprechend automatisch aktualisiert.</p>
      <p>Ein Beispiel für auf die beschriebene Art und Weise angepasste externe Daten stellt die Klasse <code>Settings</code> im nächsten Codestück dar. Sie ist konform zum <code>ObservableObject</code>-Protokoll und besitzt die Property <code>username</code>, die zur Speicherung eines Nutzernamens innerhalb einer App dient. Damit bei einer Änderung des Nutzernamens Views automatisch aktualisiert werden, ist die Property passend mit <code>@Published</code> deklariert.</p>
      <pre>class Settings: ObservableObject {<br/>    @Published var username = ""<br/>}</pre>
      <p>Um diese Daten nun als Teil einer SwiftUI-View zu nutzen, erstellt man eine Property des entsprechenden Typs (in diesem Fall <code>Settings</code>) und deklariert sie mit dem Property Wrapper <code>@ObservedObject</code>. Im nächsten Beispiel ist das Prinzip zu erkennen. Die dort deklarierte <code>UsernameView</code> nimmt die Einstellungen über eine <code>settings</code>-Property entgegen und nutzt die darin enthaltene Information, um den Nutzernamen in einem Label auszugeben. Darüber hinaus verfügt die View über ein Textfeld, über das sich der Nutzername ändern lässt. Dazu wird der <code>TextField</code>-Instanz der Verweis auf den Nutzernamen als Binding übergeben; das wäre nicht möglich, wenn die <code>settings</code>-Property nicht mit dem Property Wrapper <code>@ObservedObject</code> deklariert wäre.</p>
      <pre>struct UsernameView: View {<br/><br/>    @ObservedObject var settings: Settings<br/><br/>    var body: some View {<br/>        VStack {<br/>            Text("Current username: \(settings.username)")<br/>            TextField("Username", text: $settings.username)<br/>        }<br/>    }<br/><br/>}</pre>
      <p>Eine Alternative zu <code>@ObservedObject</code> stellt der Property Wrapper <code>@EnvironmentObject</code> dar. Er hat dieselbe Aufgabe wie <code>@ObservedObject</code> und erlaubt es, externe Daten in Views zugänglich zu machen. Der Unterschied besteht darin, dass sich diese Daten beim Einsatz von <code>@EnvironmentObject</code> an einer beliebigen Stelle innerhalb eines Projekts in eine View injizieren lassen. Daten sind so nicht über mehrere View-Ebenen weiterzureichen, bis sie letztlich jene View erreicht haben, für die sie bestimmt sind.</p>
      <p>Um Daten einer View auf Basis des Property Wrapper <code>@EnvironmentObject</code> zu übergeben, kommt die Methode <code>environmentObject(_:)</code> zum Einsatz, die sich auf allen Views aufrufen lässt. Als Parameter übergibt man eine passende Dateninstanz. Wäre so beispielsweise die <code>settings</code>-Property der Structure <code>UsernameView</code> dem vorangegangenen Beispiel mit <code>@EnvironmentObject</code> deklariert, müsste man eine Instanz der View wie folgt erzeugen:</p>
      <pre>let mySettings = Settings()<br/>UsernameView().environmentObject(mySettings)</pre>
      <p>Bei der Arbeit mit <code>@EnvironmentObject</code> müssen Entwickler aber aufpassen. Der Compiler informiert sie in diesem Fall nicht, falls sie den Aufruf der <code>environmentObject(_:)</code>-Methode vergessen und so einer View möglicherweise nicht die Daten übergeben, die sie zwingend benötigt. Sollte das tatsächlich der Fall sein, führt das beim Erstellen einer entsprechenden View zu einem Absturz der Anwendung.</p>
      <h3>Fazit</h3>
      <p>SwiftUI hat das Potenzial, das Erstellen von Benutzeroberflächen für die verschiedenen Plattformen von Apple maßgeblich zu verändern. SwiftUI erhebt den Anspruch, deutlich komfortabler zu sein als die bisherige UI-Erstellung auf Basis von Views und View-Controllern. Da SwiftUI für alle Plattformen von Apple zur Verfügung steht, reicht es, wenn Entwickler einmal gelernt und verstanden haben, wie SwiftUI funktioniert. Das Wissen können sie dann für alle Apple-Plattformen nutzen.</p>
      <p>Hierbei sei eines abschließend aber noch klargestellt: SwiftUI ersetzt nicht das Erstellen individueller Views für die einzelnen Plattformen von Apple. Es liegt in der Natur der Sache, dass sich für den Fernseher optimierte Ansichten nicht einfach eins zu eins auf das kleine Display einer Apple Watch übertragen lassen. Aber dank SwiftUI kann man für alle Plattformen dasselbe Toolset für die Gestaltung von Nutzeroberflächen einsetzen, und letztlich ist das eine der größten Stärken von SwiftUI.</p>
      <p>Bleibt die Frage, ob Entwickler bereits jetzt auf SwiftUI umsatteln sollten. Die Antwort darauf lautet wohl: jein. Es scheint außer Frage zu stehen, dass SwiftUI langfristig das Framework der Wahl zum Erstellen von Nutzeroberflächen für Apple-Plattformen sein wird. Zum jetzigen Zeitpunkt allerdings fehlt es an einigen Stellen noch an Dokumentation, was die Arbeit mit dem Framework erschwert. Darüber hinaus steht SwiftUI nur für die neuesten Betriebssystemversionen (iOS 13, macOS Catalina 10.15 usw.) zur Verfügung.</p>
      <p>Wer eine App nur für die aktuellsten Plattformversionen von Apple entwickelt und sich an ein wenig Herumprobieren aufgrund fehlender Dokumentation nicht stört, kann SwiftUI sicherlich schon im Produktiveinsatz eine Chance geben. Alle anderen Entwickler sollten sich ebenfalls mit dem Framework vertraut machen und wenigstens dessen Funktionsweise verstehen, doch der praktische Einsatz kann da noch ein wenig auf sich warten lassen. (<a href="mailto:ane@heise.de">ane</a>)</p>
      <p>
        <i>Thomas Sillmann <br/>ist Autor, Apple Developer und Trainer. Mit seiner Begeisterung für das Schreiben hat er bereits mehrere Fachbücher, Fachartikel sowie Online-Kurse veröffentlicht. Thomas lebt und arbeitet in Aschaffenburg.</i>
      </p>
    </article>
  </body>
</html>