<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://habr.com/en/post/475698/"/>
    <meta property="og:site_name" content="Habr"/>
    <meta property="article:published_time" content="2019-11-14T17:45:33+00:00"/>
    <meta property="og:title" content="Down the Rabbit Hole: A Story of One varnishreload Error — part 1"/>
    <meta property="og:description" content="After hitting the keyboard buttons for the past 20 minutes, as if he was typing for his life, ghostinushanka turns to me with a half-mad look in his eyes and a..."/>
  </head>
  <body>
    <article>
      <h1>Down the Rabbit Hole: A Story of One varnishreload Error — part 1</h1>
      <address><time datetime="2019-11-14T17:45:33+00:00">14 Nov 2019, 17:45</time> by <a rel="author" href="https://habr.com/en/users/braindebug/" target="_blank">braindebug</a></address>
      <p>After hitting the keyboard buttons for the past 20 minutes, as if he was typing for his life, <a href="https://habr.com/en/users/ghostinushanka/">@ghostinushanka</a> turns to me with a half-mad look in his eyes and a sly smile, “Dude, I think I got it.</p>
      <p>Look at this” — as he points to one of the characters on screen — “I bet my red hat that if we add what I’ve just sent you here” — as he points to another place in the code — “there will be no error anymore.”<br/>Slightly puzzled and tired I modify the sed expression we’ve been figuring out for some time now, save the file and run <code>systemctl varnish reload</code>. Error message gone…</p>
      <p>“Those emails I’ve exchanged with the candidate,” my colleague continues, as his smile changes to a wide and genuine grin, “It suddenly struck me that this is the very same exact problem!”</p>
      <h3>How it all began</h3>
      <p>
        <i>This article assumes some familiarity with bash, awk and systemd. Some knowledge of Varnish is beneficial, but not required.<br/>Timestamps in example snippets have been redacted.<br/>Co-authored with <a href="https://habr.com/en/users/ghostinushanka/">@ghostinushanka</a>.</i>
      </p>
      <p>Sun shines through the wall-sized windows on yet another warm autumn morning, a cup of freshly brewed caffeinated liquid sits to the side of the keyboard, headphones vocalize the beloved symphony of sounds covering the rustle of mechanical keyboards around and the first entry in backlog on kanban board playfully displays the fateful ticket’s title “Investigate varnishreload <code>sh: echo: I/O error</code> in staging”. Whenever Varnish is concerned, there is no room for error(s), even though this particular one didn’t seem to be causing any actual problems.</p>
      <p>For those of you unacquainted with <a href="https://github.com/varnishcache/pkg-varnish-cache/blob/weekly/systemd/varnishreload">varnishreload</a>, it is simply a shell script used to reload the configuration — also called the VCL — of the <a href="https://varnish-cache.org/">Varnish caching server</a>.</p>
      <p>As the ticket's title hints, the error has been encountered on one of the staging machines and I was pretty sure the Varnish routing does work in the staging environment, so my assumption was that this has to be some minor issue. Just a user-friendly output message written to a closed stream. I grab the ticket, firmly believing I'll be able to mark it resolved in under 30 minutes, pat myself on the back for clearing yet another mundane task and get back to more important things.</p>
      <h3>Hitting the wall at 200kph</h3>
      <p>Opening the <code>varnishreload</code> file on one of the affected servers running on Debian Stretch, I find a shell script less than 200 lines long. Briefly reading through it, I see nothing dangerous that would prevent me from running the script from terminal over and over again. After all, this is staging, even if it breaks, no one is going to complain, well… not too much, that is. I run the script and observe, only to find out that there are no errors to be seen. A couple more repeated runs to make reasonably sure that I cannot reproduce the error without any extra effort and I start devising plans to tweak and bend the script's environment. Does closing STDOUT for the script altogether (with <code>&gt; &amp;-</code>) help anything? Or STDERR? Neither did.</p>
      <p>Obviously systemd mangles the environment in some way, but how, and… why? I fire up vim and edit the system’s <code>varnishreload</code>, adding <code>set -x</code> right under the shebang, hoping that the detailed script run output will shed some light.</p>
      <p>File is patched, so I reload varnish, only to see that the change had completely broken the script… Output is a complete mess displaying tons of C-style code and the default scrollback buffer is not enough to find where does it come from. I feel confused. Could setting debug option for the shell script break the program it calls? No, can’t be. A bug in the shell? Multiple possible scenarios running wildly in different directions in my mind. A cup of caffeinated beverage is instantly finished, quick trip to the kitchen for a refill and here we go again. I open the file and look closely at the shebang: <code>#!/bin/sh</code>.</p>
      <p>But <code>/bin/sh</code> is surely just a symlink to bash, so that the script is interpreted in POSIX-compliant mode, right? Wrong! The default non-interactive shell on Debian is dash, and that's exactly what <code>/bin/sh</code> <a href="https://wiki.debian.org/Shell">points at</a>.</p>
      <pre># ls -l /bin/sh<br/>lrwxrwxrwx 1 root root 4 Jan 24  2017 /bin/sh -&gt; dash</pre>
      <p>If only for debugging, I changed the shebang to <code>#!/bin/bash</code>, removed the <code>set -x</code> and tried again. Finally, a reasonable error output from the next varnish reload:</p>
      <pre>Jan 01 12:00:00 hostname varnishreload[32604]: /usr/sbin/varnishreload: line 124: echo: write error: Broken pipe<br/>Jan 01 12:00:00 hostname varnishreload[32604]: VCL 'reload_20190101_120000_32604' compiled</pre>
      <p>Line 124, now we're talking!</p>
      <pre>114 find_vcl_file() {<br/>115         VCL_SHOW=$(varnishadm vcl.show -v "$VCL_NAME" 2&gt;&amp;1) || :<br/>116         VCL_FILE=$(<br/>117                 echo "$VCL_SHOW" |<br/>118                 awk '$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}' | {<br/>119                         # all this ceremony to handle blanks in FILE<br/>120                         read -r DELIM VCL_SHOW INDEX SIZE FILE<br/>121                         echo "$FILE"<br/>122                 }<br/>123         ) || :<br/>124<br/>125         if [ -z "$VCL_FILE" ]<br/>126         then<br/>127                 echo "$VCL_SHOW" &gt;&amp;2<br/>128                 fail "failed to get the VCL file name"<br/>129         fi<br/>130<br/>131         echo "$VCL_FILE"<br/>132 }</pre>
      <p>But as it turns out, line 124 is pretty uneventful. I could only conjecture that the error was produced as part of the multiline command executing at line 116.</p>
      <p>So what does the above subshell even produce to store in the <code>VCL_FILE</code> variable? In the first part it sends the contents of the <code>VCL_SHOW</code> variable created on the line 115 into the pipe. What happens there, then?</p>
      <p>First, it uses <code>varnishadm</code>, which is a standard part of a Varnish installation used to configure Varnish without having to restart it. The subcommand <code>vcl.show -v</code> is used to print the entire VCL configuration specified by <code>${VCL_NAME}</code> to STDOUT.</p>
      <p>To display the current active VCL config as well as several previous versions of the varnish routing that are still in memory, you can use another command <code>varnishadm vcl.list</code>, whose output would be similar to the below:</p>
      <pre>discarded   cold/busy          1 reload_20190101_120000_11903<br/>discarded   cold/busy          2 reload_20190101_120000_12068<br/>discarded   cold/busy         16 reload_20190101_120000_12259<br/>discarded   cold/busy         16 reload_20190101_120000_12299<br/>discarded   cold/busy         28 reload_20190101_120000_12357<br/>active      auto/warm         32 reload_20190101_120000_12397<br/>available   auto/warm          0 reload_20190101_120000_12587</pre>
      <p>The variable <code>${VCL_NAME}</code> is set elsewhere in the <code>varnishreload</code> script to the name of the currently active VCL, if any. In this case, that would be "reload_20190101_120000_12397".</p>
      <p>Great, so <code>${VCL_SHOW}</code> now contains a full configuration for Varnish, easy enough so far. Now I finally understood why the dash output with <code>set -x</code> appeared to be so broken — it included the contents of the resulting varnish configuration.</p>
      <p>The important thing here is that the full VCL config may often be spliced together from multiple files. C-style comments are used to delineate where config files were included into other config files, which is exactly what the next line of the code snippet is all about.</p>
      <p>The syntax of the file-denoting comments has the following format</p>
      <pre>// VCL.SHOW &lt;NUM&gt; &lt;NUM&gt; &lt;FILENAME&gt;</pre>
      <p>The numbers are not important here, what we’re interested in is the filename.</p>
      <p>So what in the world is happening in the slew of commands beginning on line 116?<br/>Let's pick it apart.<br/>There are four parts to the command:</p>
      <ol>
        <li>
          <p>A simple <code>echo</code> that prints out the value of <code>${VCL_SHOW}</code></p>
          <pre>echo "$VCL_SHOW"</pre>
        </li>
        <li>
          <p><code>awk</code> that looks for a line (record) where the first field is '//' and the second is "VCL.SHOW".<br/>Awk is instructed to print the first line matching these patterns and then immediately stop processing.</p>
          <pre>awk '$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</pre>
        </li>
        <li>
          <p>A code block that reads in the whitespace-delimited fields into five variables. The fifth variable FILE gets the remainder of the line. Finally, one last echo prints the contents of the <code>${FILE}</code> variable.</p>
          <pre>{ read -r DELIM VCL_SHOW INDEX SIZE FILE; echo "$FILE" }.</pre>
        </li>
        <li>As steps 1 through 3 are all encased in a subshell, the output of <code>$FILE</code> will end up in the variable <code>VCL_FILE</code>.</li>
      </ol>
      <p>As the comment on line 119 suggests, this way of doing things serves a single purpose: to reliably handle the case where VCL would be referencing filenames with spaces.</p>
      <p>I commented out the original processing logic for the <code>${VCL_FILE}</code> and tried to tweak the chain of commands but to no reasonable end. Everything worked in my shell but never when run as a service.</p>
      <p>It seems the error is not at all replicable when run by me — meanwhile the estimated 30 minutes passed six times and a new high-priority task put everything aside. The rest of the week was quite full with different tasks, the two exceptions being an internal talk our team had about using <code>sed</code> and an interview with a promising candidate. The issue with making <code>varnishreload</code> error disappear was completely lost to the sands of time.</p>
      <h3>Your so-called sed-fu… is really… quite pathetic</h3>
      <p>One of the days of the week that followed was pretty free, so I picked the task up again. I had hoped that maybe some background process in my brain was still chipping away at the problem and I'll finally be able to crack it.</p>
      <p>Since bending the code last time didn't help, I just opted for a rewrite of line 116. The existing code was insane, anyway. There is absolutely no need to use <code>read</code> here.</p>
      <p>Looking at the error again:<br/><code>sh: echo: broken pipe</code> — echo is in two places in that command, but I suspect the very first one to be a more likelier culprit (or an accomplice). Awk doesn't inspire confidence either. Well, in case it really is the <code>awk | {read; echo}</code> construct causing all this trouble, why not use something else? Awk's not really being used to its full capabilities on that one-liner and then there is this surplus <code>read</code>.</p>
      <p>Seeing as we had an internal talk about <code>sed</code> the other week, I wanted to try my newly-acquired skills and optimize the <code>echo | awk | { read; echo }</code> into a simpler <code>echo | sed</code>. Although that’s definitely not the proper way to approach debugging, I thought I’d at least try out my sed-fu and maybe learn something new about the problem in the process. In the process, I’ve asked my colleague — the author of the sed talk — to help me come up with a more efficient sed command.</p>
      <p>I’ve dumped the <code>varnishadm vcl.show -v "$VCL_NAME"</code> into a file, so I could focus on writing sed without all the hassle around service reloads.</p>
      <p>A short primer on how exactly sed processes input can be found in <a href="https://www.gnu.org/software/sed/manual/sed.html#Execution-Cycle">its GNU manual</a>. In sed sources character <code>\n</code> is explicitly specified as the line separator.</p>
      <p>After several iterations and input from my colleague, we’ve crafted a sed expression that did produce exactly the same result as the original line 116.</p>
      <p>Let’s create a sample input file here,</p>
      <pre>&gt; cat vcl-example.vcl<br/>Text<br/>// VCL.SHOW 0 1578 file with 3 spaces.vcl<br/>More text<br/>// VCL.SHOW 0 1578 file.vcl<br/>Even more text<br/>// VCL.SHOW 0 1578 file with TWOspaces.vcl<br/>Final text</pre>
      <p>It might not be apparent from the above description, but we’re only interested in the first <code>// VCL.SHOW</code> comment, and there may be several on input. That’s exactly why awk quits after the first match.</p>
      <pre># step 1, capture just the comment lines<br/># using sed capability to specify delimiter character with ‘\#’ instead of the commonly used ‘/’ so there is no need to escape slashes themselves<br/># and the “address” capability defined as regex “// VCL.SHOW” to search for lines with specific pattern<br/># -n flag makes sure that the sed does not print all as it does by default (see above link)<br/># -E switches to the extended regex<br/>&gt; cat vcl-processor-1.sed<br/>\#// VCL.SHOW#p<br/>&gt; sed -En -f vcl-processor-1.sed vcl-example.vcl<br/>// VCL.SHOW 0 1578 file with 3 spaces.vcl<br/>// VCL.SHOW 0 1578 file.vcl<br/>// VCL.SHOW 0 1578 file with TWOspaces.vcl<br/><br/># step 2, only print out the file name<br/># using the “substitute” command with regex capture groups to print just that group<br/># and this is done only for the matches of the previous search<br/>&gt; cat vcl-processor-2.sed<br/>\#// VCL.SHOW# {<br/>    s#.* [0-9]+ [0-9]+ (.*)$#\1#<br/>    p<br/>}<br/>&gt; sed -En -f vcl-processor-2.sed vcl-example.vcl<br/>file with 3 spaces.vcl<br/>file.vcl<br/>file with TWOspaces.vcl<br/><br/># step 3, make sure to only get the first result<br/># same as with the awk before, add an immediate exit after the first processed match is printed<br/>&gt; cat vcl-processor-3.sed<br/>\#// VCL.SHOW# {<br/>    s#.* [0-9]+ [0-9]+ (.*)$#\1#<br/>    p<br/>    q<br/>}<br/>&gt; sed -En -f vcl-processor-3.sed vcl-example.vcl<br/>file with 3 spaces.vcl<br/><br/># step 4, wrap it up into a one-liner using the colon to separate commands<br/>&gt; sed -En -e '\#// VCL.SHOW#{s#.* [0-9]+ [0-9]+ (.*)$#\1#p;q;}' vcl-example.vcl<br/>file with 3 spaces.vcl</pre>
      <p>So, the contents of the varnishreload script would look something like this:</p>
      <pre>VCL_FILE="$(echo "$VCL_SHOW" | sed -En '\#// VCL.SHOW#{s#.*[0-9]+ [0-9]+ (.*)$#\1#p;q;};')"</pre>
      <p>The above logic may succinctly be expressed by:<br/>if a line matches the regex <code>// VCL.SHOW</code>, then greedily match the text including the two numbers on that line and capture whatever comes after. Emit the capture and quit.</p>
      <p>Simple, isn't it?</p>
      <p>We were happy with the sed script and the fact what original code it replaces, all test runs I’ve done produced desired results, so I have modified the <code>varnishreload</code> on the server and fired the <code>systemctl reload varnish</code> once again. The dreaded <code>echo: write error: Broken pipe</code> was smiling in our faces. The blinking cursor awaited a new command entry in the dark void of the terminal…</p>
      <related>
        <h4>Similar posts</h4>
        <a href="https://habr.com/en/post/452454/"/>
        <a href="https://habr.com/en/post/449218/"/>
        <a href="https://habr.com/en/post/448778/"/>
      </related>
    </article>
  </body>
</html>