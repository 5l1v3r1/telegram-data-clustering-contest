<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://habr.com/en/post/476494/?utm_source=habrahabr&amp;utm_medium=rss&amp;utm_campaign=476494"/>
    <meta property="og:site_name" content="Habr"/>
    <meta property="article:published_time" content="2019-11-19T11:04:55+00:00"/>
    <meta property="og:title" content="How to Implement Tinder Swipe Cards in SwiftUI"/>
    <meta property="og:description" content="In June, we heard about SwiftUI for the first time — a totally new way of creating and working with UI elements in iOS and macOS (also iPadOS) apps. It felt l..."/>
  </head>
  <body>
    <article>
      <h1>How to Implement Tinder Swipe Cards in SwiftUI</h1>
      <address><time datetime="2019-11-19T11:04:55+00:00">19 Nov 2019, 11:04</time> by <a rel="author" href="https://habr.com/en/users/florianmarcu/" target="_blank">florianmarcu</a></address>
      <p>In June, we heard about <a href="https://www.iosapptemplates.com/blog/ios-development/swiftui-introduction">SwiftUI</a> for the first time — a totally new way of creating and working with UI elements in iOS and macOS (also iPadOS) apps. It felt like Christmas in the summer. It's new, it's declarative, it's sexy! And now, just a few weeks after iOS 13 has been released, we can start to use SwiftUI in all our projects. Let's learn how to use this amazing tool that Apple gave us, to create the classic Tinder-esque Swipe Cards.<br/><br/>In this article, I would like to show you how to achieve a Tinder-like card view and behavior (swipe to action), with just a few lines of code.<br/><br/>To achieve this, we need to do the following things, in order:</p>
      <ul>
        <li>Create UserView</li>
        <li>Create NavigationView</li>
        <li>Create BottomBarView</li>
        <li>Create SwipeView</li>
        <li>Put all this together inside ContentView</li>
      </ul>
      <p>So let's get started.</p>
      <figure>
        <video src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/ezgif-6-6a1d3753a470.gif" autoplay="" loop=""/>
      </figure>
      <h3>UserView</h3>
      <p>UserView is built from two subviews, one is <i>NameView</i> which contains the user name, age, and hobbies, and the second view is just an avatar view that displays the user's profile picture.</p>
      <pre>struct NameView: View {<br/>    let name: String<br/>    let age: Int<br/>    let hobby: String<br/><br/>    var body: some View {<br/>        VStack(alignment: .leading) {<br/>            Spacer()<br/>            Text("\(name), \(age)")<br/>                .font(.title)<br/>                .fontWeight(.semibold)<br/>                .foregroundColor(.white)<br/>            Text(hobby)<br/>                .font(.system(size: 16))<br/>                .fontWeight(.regular)<br/>                .foregroundColor(.white)<br/>        }<br/>        .padding()<br/>    }<br/>}<br/></pre>
      <p>First, we need to define the <i>NameView</i>, this will represent the user name, age, and hobby. <i>NameView</i> is conforming to the <i>View</i> protocol, which is used to define custom views in SwiftUI. The view protocol has only one requirement and that's defining the body property which should return the view structure and describes its behavior. You can check more about the <i>View</i> protocol in the official <a href="https://developer.apple.com/documentation/swiftui/view">Apple documentation</a>.<br/><br/>Let's break down the objects that we use to define this <i>View</i>:</p>
      <ul>
        <li><i>VStack</i> which acts like a container for all the objects aligning them vertically</li>
        <li><i>Spacer</i> that tells SwiftUI that this view should be aligned on the bottom</li>
        <li><i>Text</i> which represents the label with name &amp; age, with the following properties:</li>
        <li>Second Text object that has similar properties and displays the user's hobby</li>
      </ul>
      <p>Please notice that we are not using a return statement here, inside the body property, but instead we are returning a VStack. SwiftUI is using the omit-return proposal implemented in Swift 5.0. You can check more about this <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0255-omit-return.md">here</a>.</p>
      <h3>AvatarView</h3>
      <p>This is how <i>AvatarView</i> is defined:</p>
      <pre>struct AvatarView: View {<br/>    let image: UIImage<br/><br/>    var body: some View {<br/>        Image(uiImage: image)<br/>            .resizable()<br/>            .overlay(<br/>                Rectangle()<br/>                    .fill(LinearGradient(gradient: Gradient(colors: [.clear, .black]),<br/>                                         startPoint: .center, endPoint: .bottom))<br/>                    .clipped()<br/>        )<br/>            .cornerRadius(12.0)<br/>    }<br/>}<br/></pre>
      <p>Let's dive into the components that are making this avatar unit:</p>
      <ul>
        <li><i>Image</i> — which displays the user's picture</li>
        <li><i>resizable</i> — this method specifies that the image should resize to fit into the place where it's embedded</li>
        <li><i>overlay(Rectangle)</i> — here we are defining gradient that will be a nice background for NameView, this gradient starts at image center and finishes at the bottom, it has clear color at the start and black at the bottom</li>
        <li><i>cornerRadius</i> — the picture will have a cornered radius</li>
      </ul>
      <p>And now let's embed these two views into a single container view, named <i>UserView</i>.</p>
      <h3>UserView</h3>
      <pre>struct UserView: View {<br/>    let userModel: UserModel<br/><br/>    var body: some View {<br/>        ZStack(alignment: .leading) {<br/>            AvatarView(image: userModel.image)<br/>            NameView(name: userModel.name, age: userModel.age, hobby: userModel.hobby)<br/>        }<br/>        .shadow(radius: 12.0)<br/>        .cornerRadius(12.0)<br/>    }<br/>}<br/></pre>
      <p>Here's what's going on:</p>
      <ul>
        <li><i>ZStack</i> — This is a stack view that will align its children's on the same axis. You can read more about ZStack <a href="https://developer.apple.com/documentation/swiftui/zstack">here</a></li>
        <li><i>AvatarView</i> — Our avatar view containing the image provided via <i>UserModel</i></li>
        <li><i>NameView</i> — Our name view displaying the name based on the user model</li>
      </ul>
      <p>After all these steps, run the app. You will get the following screen:</p>
      <figure>
        <img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/UserView.png"/>
      </figure>
      <p>Let’s add a small helper method now. Before I show you how NavigationView is defined, let's create a helper method, which looks like this:</p>
      <pre>struct ViewFactory {<br/>    static func button(_ name: String, renderingMode: Image.TemplateRenderingMode = .original) -&gt; some View {<br/>        Button(action: {}) {<br/>            Image(name)<br/>                .renderingMode(renderingMode)<br/>        }<br/>    }<br/>}<br/></pre>
      <p>Here, we have defined a button factory method, that creates a new button from a given image and a rendering mode. There is no action handler, since that falls out of scope for this article.</p>
      <h3>NavigationView</h3>
      <pre>struct NavigationView: View {<br/>    var body: some View {<br/>        HStack {<br/>            ViewFactory.button("profile_icon")<br/>            Spacer()<br/>            ViewFactory.button("fire_icon")<br/>                .scaleEffect(2)<br/>            Spacer()<br/>            ViewFactory.button("chat_icon")<br/>        }<br/>    }<br/>}<br/></pre>
      <p>SwiftUI will automatically make the <i>Spacers</i> of equal width, and it will give us the following navigation view:</p>
      <figure>
        <img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/NavigationView.png"/>
      </figure>
      <h3>BottomBarView</h3>
      <pre>struct BottomBarView: View {<br/>    var body: some View {<br/>        HStack {<br/>            ViewFactory.button("back_icon", renderingMode: .template)<br/>                .foregroundColor(.orange)<br/>                .background(<br/>                    GeometryReader { geometry in<br/>                        Circle()<br/>                            .offset(x: 2.5)<br/>                            .foregroundColor(.white)<br/>                            .shadow(color: .gray, radius: 12)<br/>                            .frame(width: geometry.size.width * 1.5, height: geometry.size.height * 1.5)<br/>                    }<br/>            )<br/>            Spacer()<br/>            ...<br/>}<br/></pre>
      <p>In the above code snippet, we've defined the first button from our bar view. Here's what's going on:</p>
      <ul>
        <li>ViewFactory.button — here we are using our helper method to define button with image with renderingMode .template which allows you to put a custom color for this image</li>
        <li><i>.foregroundColor</i> — defining the color of our view</li>
        <li><i>.background</i> — this method defines the given object's background view</li>
        <li><i>GeometryReader</i> — a container view that defines its content as a function of its own size and coordinate space. We are using this to get the current size of a button and define the background circle with the given frame. Learn more about Geometry Readers <a href="https://developer.apple.com/documentation/swiftui/geometryreader">here</a>.</li>
        <li><i>Circle</i> — defines the background shape</li>
        <li><i>.offset</i> — circle x-axis offset</li>
        <li><i>.foregroundColor</i> — circle tint color</li>
        <li><i>.shadow</i> — circle shadow</li>
        <li><i>.frame</i> — defines the circle frame using the geometry reader's size (here we are defining a background circle, 1.5x bigger than the current button)</li>
      </ul>
      <p>Now let's implement the rest of the buttons:</p>
      <pre>struct BottomBarView: View {<br/>    var body: some View {<br/>        HStack {<br/>            ViewFactory.button("back_icon", renderingMode: .template)<br/>                .foregroundColor(.orange)<br/>                .background(<br/>                    GeometryReader { geometry in<br/>                        Circle()<br/>                            .offset(x: 2.5)<br/>                            .foregroundColor(.white)<br/>                            .shadow(color: .gray, radius: 12)<br/>                            .frame(width: geometry.size.width * 1.5, height: geometry.size.height * 1.5)<br/>                    }<br/>            )<br/>            Spacer()<br/>            ViewFactory.button("close_icon", renderingMode: .template)<br/>                .foregroundColor(.red)<br/>                .background(<br/>                    GeometryReader { geometry in<br/>                        Circle().foregroundColor(.white)<br/>                            .frame(width: geometry.size.width * 2, height: geometry.size.height * 2)<br/>                            .shadow(color: .gray, radius: 12)<br/>                    }<br/>            )<br/>            Spacer()<br/>            ViewFactory.button("approve_icon", renderingMode: .template)<br/>                .foregroundColor(.green)<br/>                .background(<br/>                    GeometryReader { geometry in<br/>                        Circle()<br/>                            .foregroundColor(.white)<br/>                            .shadow(color: .gray, radius: 12)<br/>                            .frame(width: geometry.size.width * 2, height: geometry.size.height * 2)<br/>                    }<br/>            )<br/>            Spacer()<br/>            ViewFactory.button("boost_icon", renderingMode: .template)<br/>                .foregroundColor(.purple)<br/>                .background(<br/>                    GeometryReader { geometry in<br/>                        Circle()<br/>                            .foregroundColor(.white)<br/>                            .shadow(color: .gray, radius: 12)<br/>                            .frame(width: geometry.size.width * 1.5, height: geometry.size.height * 1.5)<br/>                    }<br/>            )<br/>        }<br/>        .padding([.leading, .trailing])<br/>    }<br/>}<br/></pre>
      <p>And as a result we now have this beautiful view:</p>
      <figure>
        <img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/BottomBarView.png"/>
      </figure>
      <h3>SwipeView</h3>
      <p>This section is for more advanced SwiftUI. This is really where things get interesting. We would like to implement the swipe gesture on the action view. This behavior is a nice use case for a PageViewController, but this view controller will be history soon, so this is where we can show the real power of SwiftUI.<br/><br/>So let's see how SwipeView is implemented:</p>
      <pre>struct SwipeView: View {<br/>    @State private var offset: CGFloat = 0<br/>    @State private var index = 0<br/><br/>    let users = [...]    <br/>    let spacing: CGFloat = 10<br/><br/>    var body: some View {<br/>        GeometryReader { geometry in<br/>            return ScrollView(.horizontal, showsIndicators: true) {<br/>                HStack(spacing: self.spacing) {<br/>                    ForEach(self.users) { user in<br/>                        UserView(userModel: user)<br/>                            .frame(width: geometry.size.width)<br/>                    }<br/>                }<br/>            }<br/>            .content.offset(x: self.offset)<br/>            .frame(width: geometry.size.width, alignment: .leading)<br/>            .gesture(<br/>                DragGesture()<br/>                    .onChanged({ value in<br/>                        self.offset = value.translation.width - geometry.size.width * CGFloat(self.index)<br/>                    })<br/>                    .onEnded({ value in<br/>                        if -value.predictedEndTranslation.width &gt; geometry.size.width / 2, self.index &lt; self.users.count - 1 {<br/>                            self.index += 1<br/>                        }<br/>                        if value.predictedEndTranslation.width &gt; geometry.size.width / 2, self.index &gt; 0 {<br/>                            self.index -= 1<br/>                        }<br/>                        withAnimation { self.offset = -(geometry.size.width + self.spacing) * CGFloat(self.index) }<br/>                    })<br/>            )<br/>        }<br/>    }<br/>}<br/></pre>
      <p>Here we have used a few new interesting SwiftUI concepts:</p>
      <ul>
        <li><i>@ State</i> — A persistent value of a given type, through which a view reads and monitors the value, which means that whenever this property will change, the view will be reloaded to adjust to the given state update. You can check more about State <a href="https://developer.apple.com/documentation/swiftui/state">here</a>.</li>
        <li><i>DragGesture</i> — this object will be used to recognize every swipe that user makes on screen. You can read more about this here: <a href="https://developer.apple.com/documentation/swiftui/draggesture">developer.apple.com/documentation/swiftui/draggesture</a></li>
        <li><i>@ State private var offset: CGFloat = 0</i> — this property will be used to define the current scroll view offset when users swipe over the screen</li>
        <li><i>@ State private var index = 0</i> — this property defines which user view is currently on the screen</li>
        <li><i>ScrollView</i> — horizontal scroll view without indicators, that will be a container for our user view</li>
        <li><i>HStack</i> — horizontal stack view which contains all user views</li>
        <li><i>content.offset(self.offset)</i> — it is creating a connection between the offset state and the scroll view content offset. This means that whenever the offset property will change, the scroll view offset will also be updated</li>
      </ul>
      <p>We are enumerating over the existing users by creating a <i>UserView</i> for each element:</p>
      <ul>
        <li><i>.frame</i> — here we are defining the scroll view frame that should fit the screen's width, and should be aligned properly to its container</li>
        <li><i>.gesture</i> — here we are adding our <i>DragGesture</i> object</li>
      </ul>
      <p><i>DragGesture</i> is a little complicated, but nevertheless, it adds all the pagination logic in just a few lines of code. Let's break down <i>DragGesture</i>:</p>
      <ul>
        <li><i>onChanged()</i> — this block is invoke whenever user starts and is in time of dragning gesture, here we are calculating current user view offset that follows users finger</li>
        <li><i>onEnded()</i> — here we are informed when drag gesture ends, here we need to calculate if user would like to swipe this view (left or right), or maybe this gesture was marked, and user would like to stay on this screen</li>
        <li><i>withAnimation</i> — this closure is invoked with animation, and allows to change offset smothly</li>
      </ul>
      <h3>ContentView</h3>
      <pre>struct ContentView: View {<br/>    var body: some View {<br/>        VStack {<br/>            NavigationView()<br/>                .padding(.bottom)<br/>            SwipeView()<br/>                .padding(.bottom)<br/>            BottomBarView()<br/>        }<br/>        .padding()<br/>    }<br/>}<br/></pre>
      <p>Our content view is extremely simple at this point — it composes all created the views we previously created, inside a vertical stack (<i>VStack</i>). For the <i>NavigationView</i> and <i>SwipeView</i> we have added some default padding on the bottom, and the whole <i>VStack</i> has paddings added to all edges. <br/><br/>That's it. Done. This is how our app looks like now:</p>
      <figure>
        <video src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/ezgif-6-6a1d3753a470.gif" autoplay="" loop=""/>
      </figure>
      <h3>Final thoughts</h3>
      <p>As we can see SwiftUI is very powerful tool, it gives us an easy way to define and manipulate UI in a short declarative code. <a href="https://www.instamobile.io/mobile-templates/react-native-templates-free/">React Native</a> developers would recognize this declarative paradigm right away.<br/><br/>But remember: SwiftUI is still under development and can be extremely unstable for now. If you would like to check all code base for this project you can find it on <a href="https://github.com/mrcflorian/swiftUI-tutorials">Github</a>.<br/><br/>If you have any thoughts or questions about SwiftUI, feel free to share them in comments. Also, if you've enjoyed this article, please share it with your community to help us spread the word!</p>
      <related>
        <h4>Similar posts</h4>
        <a href="https://habr.com/en/post/440920/"/>
        <a href="https://habr.com/en/post/437812/"/>
        <a href="https://habr.com/en/post/438152/"/>
      </related>
    </article>
  </body>
</html>