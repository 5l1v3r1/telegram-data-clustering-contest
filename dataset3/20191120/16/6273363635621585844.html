<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://venturebeat.com/2019/11/20/how-many-programming-languages-are-too-many/"/>
    <meta property="og:site_name" content="VentureBeat"/>
    <meta property="article:published_time" content="2019-11-20T16:09:32+00:00"/>
    <meta property="og:title" content="How many programming languages are too many?"/>
    <meta property="og:description" content="Ever organization faces a dilemma in supporting programming languages -- the desire to standardize versus recognizing the benefits of multiple languages."/>
  </head>
  <body>
    <article>
      <h1>How many programming languages are too many?</h1>
      <address><time datetime="2019-11-20T16:09:32+00:00">20 Nov 2019, 16:09</time> by <a rel="author" href="https://venturebeat.com/author/rebecca-parsons-thoughtworks/" target="_blank">Rebecca Parsons, ThoughtWorks</a></address>
      <p>
        <i>Presented by ThoughtWorks</i>
      </p>
      <hr/>
      <p>Every organization faces a dilemma when it comes to support for programming languages. On the one hand, there’s an understandable desire to standardize — a set of approved languages can help reign in maintenance costs and long-term viability. But equally, many of us recognize the benefits of using whichever language the developer feels allows them to express themselves most eloquently.</p>
      <p>It’s a dilemma that has a personal element too. Some developers want to try <a href="https://venturebeat.com/2019/04/24/how-programming-languages-have-evolved-a-2019-primer/">every new language</a> they possibly can — often out of genuine curiosity and desire to learn, while others may have half a mind on burnishing their employment prospects. For some, the joys of learning are found by going deep in one particular language, in a drive to become a specialist — or maybe they’re not confident about learning new languages.</p>
      <p>Here we explore ways of deciding how many programming languages is the right number for your organization to support. And while there’s no single answer that works for all organizations, I do believe it’s possible to get a handle on the best approach for you.</p>
      <h3>One language to rule them all</h3>
      <p>Every so often, we come across clients and developers that believe that there really is one best choice when it comes to languages. In the not-too-distant past, it was common to see organizations characterize themselves as Java or C# houses. More recently, we see this pattern with Node.js being used everywhere — with React for server-side rendering; with Kubernetes and Docker for orchestrating microservices; or using Node.js for serverless.</p>
      <p>There’s a lot to be said for having common tooling and workflows, not least in terms of maintenance and support costs. We’ve seen many large, complex organizations benefit from standardization. We’ve also seen start-ups turbo charge their growth by getting their devs to work within a common ecosystem. Even so, standardization has its limits.</p>
      <p>Having just one language seems too self-limiting. At ThoughtWorks, we’ve long been vocal supporters of the ideas of polyglot programming — we think that there are significant productivity benefits from choosing the right tool for the job.</p>
      <h3>General purpose vs special cases</h3>
      <p>As critics of polyglot programming like to point out, the choice not to impose any restrictions paves the way toward chaos. After all, your ace programmer may well have written you the most exquisite system in Clojure, but if she’s the only one that knows that language, she’ll be wasting time on maintenance rather than working on the next big project. And with scores of systems in different languages, your support costs will spiral.</p>
      <p>So, how many languages is too many?</p>
      <p>At ThoughtWorks, many of our developers are polyglots — we work for a variety of clients, so it’s useful for us to have developers that are comfortable in multiple languages. But for our clients, it may make more sense to have a favored language or perhaps a small set of languages for general purpose application development.</p>
      <p>Such choices do lead to compromises. For some large enterprises, it may be that their default choice of languages makes it more difficult and costly for individual business units to do their development.</p>
      <p>At one client we worked with, I had devs coming to me tearing their hair out in frustration over the tech stack they’d found. They were certain that we could deliver a better solution, far quicker and far cheaper by switching to a different development paradigm. And they may well have been right. But what our devs, working in one department of this massive conglomerate, perhaps didn’t appreciate was this: the cost savings the client could realize across the business by standardizing dwarfed that one project’s costs.</p>
      <p>Nonetheless, just because you standardize, it doesn’t mean you have to rule out experimentation for special cases. Take for instance, embedded systems or data science.</p>
      <p>In cases such as these, your choice of language has real world consequences. While you can build an Internet of Things solution using almost any general purpose language — these things are after all, Turing complete — it doesn’t mean you should. Using something like Rust, which is ideal for embedded systems, has huge advantages for things like memory management and power consumption which can make or break IoT solutions.</p>
      <p>It’s a similar tale when it comes to data science. Why would you not use something like Python or R? The libraries associated with these languages make it questionable to use anything else when you’re dealing with complex data projects.</p>
      <p>We think that there are other special cases too. When it comes to language choices, we’ve seen a number of clients move away from their standard set because they think it will increase their chances of recruiting talent. By showing you can provide a career path — for say Clojure developers — you can make yourself a more attractive employer. You’ll no doubt know that attracting the most talented programmers is tough. Competition is fierce. So showing that you’re a forward-thinking employer that will give developers interesting work can really help.</p>
      <p>So within this context, each organization should think about what types of applications should fall outside the general purpose realm. You can allow experimentation, and you may want to add functional languages to the repertoire of languages your organization is using.</p>
      <p>These aren’t simple choices. You need to canvass views from both those at the coalface and those in leadership. And you need to be realistic: whatever your final decisions, there are going to be compromises.</p>
      <p>At ThoughtWorks, we believe that building your own Technology Radar can help you work through this decision-making process — a living document aimed at assessing the risks and rewards of existing and nascent technologies.</p>
      <p>The act of creating your Technology Radar necessitates getting a diverse group together from across your organization and having conversations about technology. And these conversations frequently turn up things that you would otherwise miss. You might get to find out about very useful tools that are being used in pockets of the business. Maybe it will enable you to uncover problems in your stack that you had not picked up on. If you want to understand what languages you should support, it can be a great start.</p>
      <p>
        <i>Rebecca Parsons is CTO at ThoughtWorks.</i>
      </p>
      <hr/>
      <p>
        <i>Sponsored articles are content produced by a company that is either paying for the post or has a business relationship with VentureBeat, and they’re always clearly marked. Content produced by our editorial team is never influenced by advertisers or sponsors in any way. For more information, contact <a href="mailto:sales@venturebeat.com">sales@venturebeat.com</a>.</i>
      </p>
    </article>
  </body>
</html>