<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://dou.ua/lenta/articles/gradle-plugins/"/>
    <meta property="og:site_name" content="ДОУ"/>
    <meta property="article:published_time" content="2019-11-29T10:00:00+00:00"/>
    <meta property="og:title" content="Пишемо свої Gradle плагіни для автоматизації тестування"/>
    <meta property="og:description" content="У галузі тестування є потреба автоматизації задач. Gradle надає можливість реалізувати плагіни прямо в проекті з тестами, помістивши до директорії buildSrc. Так можна уникнути проблем із версіонністю і потребою в додаткових збірках на CI. Максим Барвінський, Lead Software Engineer in Test, на конкретному прикладі розглядає два Gradle плагіни, які могли би бути корисні для тестів."/>
  </head>
  <body>
    <article>
      <h1>Пишемо свої Gradle плагіни для автоматизації тестування</h1>
      <address><time datetime="2019-11-29T10:00:00+00:00">29 Nov 2019, 10:00</time> by <a rel="author" href="https://dou.ua/users/maksim-barvinskij/" target="_blank">Максим Барвінський</a></address>
      <p>Я займаю позицію Lead Software Engineer in Test в EPAM. У цій статті розглянемо, як писати свої Gradle плагіни і які проблеми цим інструментом можна вирішити. У галузі автоматизації тестування, як, напевно, і в розробці загалом, часто зустрічаються рутинні задачі, які спочатку виконуються вручну, а потім люди втомлюються і якось їх автоматизують. Для цього зазвичай у хід ідуть скриптові мови програмування, які є в арсеналі у виконавця: Python, Bash, Excel VBA — кого вже як життя покидало.</p>
      <p>Переважно ці рішення є ефективними, але але якщо у вас тести написані на Java і проект збирається за допомогою Gradle, то для деяких таких задач варто розглянути варіант написання свого Gradle плагіна, а саме для тих, які логічно було би прив’язати до компіляції проекту. У цій статті я наведу приклади такого рішення, які застосовую у власній практиці.</p>
      <p>Наведені приклади також можна застосувати і до збірок Maven — там теж є плагіни, тільки Maven плагіни мають бути обов’язково окремими проектами, тоді як у Gradle є можливість їх реалізувати прямо в проекті з тестами, помістивши до магічної директорії buildSrc. Це, щоправда, має сенс, якщо плагіни тісно пов’язані з даним Gradle проектом і не будуть використовуватись в інших. Так ми уникаємо проблем із версіонністю і потребою в додаткових збірках на CI.</p>
      <h3>Контекст</h3>
      <p>Отже, уявімо, що ми маємо System Under Test у вигляді простого веб-застосунку за назвою Reminders. Там можна додавати, редагувати і видаляти нагадування. Кожне нагадування має три атрибути: текст, час і прапорець, чи виконано. Також ми маємо і UI тести, написані на Java з використанням TestNG і Selenide.</p>
      <p>Код тестів і самого застосунку у фінальному вигляді можна подивитися <a href="https://github.com/barvin/gradle-plugins">тут</a>.</p>
      <p>Тепер розглянемо два Gradle плагіни, які могли би бути корисні для тестів.</p>
      <h3>Test Format Check Plugin</h3>
      <p>Такий вигляд у нас має тест зі створення нагадування:</p>
      <pre> <br/>@Test(description = "Create reminder", <br/>        dataProvider = "createReminderData", <br/>        groups = {Groups.SMOKE, Teams.ALPHA, Sprints._1}) <br/>@TestCase("REM-132") <br/>public void createReminder(Reminder reminder) { <br/>    NavigationSteps.openRemindersApp(); <br/>    ReminderSteps.addReminder(reminder); <br/>    ReminderSteps.checkLastReminder(reminder); <br/>} <br/></pre>
      <p>Абстрагуймося від деталей реалізації і звернімо увагу на мета-дані тесту — список груп (зокрема, приналежність до команди і спринта), а також анотацію @TestCase, яка містить ідентифікатор задачі в якійсь трекінг-системі, наприклад JIRA. Схожий список атрибутів має переважна більшість фреймворків у тому чи іншому вигляді, і що більший проект (а точніше, що більше автоматизаторів одночасно працюють над ним), то гостріше стоїть потреба у перевірці наявності цих атрибутів і відповідності певному формату. Це нам дасть упевненість <s>у завтрашньому дні</s> вибірках за цими атрибутами як зараз, так і через кілька років, коли ми вже фізично не зможемо руками перевірити всі тести.</p>
      <p>Таку перевірку можна робити вручну на code review, можна написати окремий скрипт, а можна включити просто до процесу збірки проекту, наприклад, наступним етапом після компіляції. Тоді кожен автоматизатор отримає найшвидший зворотний зв’язок про стан мета-даних своїх тестів, просто зібравши проект локально після своїх змін. Для цього нам і знадобиться Gradle плагін.</p>
      <p>Спочатку робимо в корені проекту директорію buildSrc, в якій створюємо Gradle модуль, тобто свій build.gradle (build.gradle.kts) файл і директорію src, куди покладемо сам код плагіна. В нашому випадку це один клас, написаний на Kotlin. Власне, тут ви якраз можете потренуватись в будь-якій мові, яка компілюється в JVM bytecode, що я і зробив.</p>
      <p>Директорія buildSrc у проекті:</p>
      <figure>
        <img src="https://s.dou.ua/storage-files/image1_hC6DUUr.png"/>
      </figure>
      <p>Файл build.gradle.kts має такий вигляд:</p>
      <pre> <br/>plugins { <br/>    kotlin("jvm") version "1.3.50" <br/>    `java-gradle-plugin` <br/>} <br/><br/>gradlePlugin { <br/>    plugins { <br/>        create("testFormatCheck") { <br/>            id = "reminder-test-format-checker" <br/>            implementationClass = "com.example.plugins.TestFormatCheckPlugin" <br/>        } <br/>    } <br/>} <br/><br/>repositories { <br/>    jcenter() <br/>} <br/><br/>dependencies { <br/>    compile("com.github.javaparser:javaparser-core:3.14.7") <br/>} <br/></pre>
      <p>Єдиною бібліотекою, потрібною для нашого плагіна, є <a href="https://javaparser.org/">javaparser</a>. Вона вміє парсити Java код в абстрактне дерево, а також генерувати його, але ця функціональність у нашому випадку не потрібна. В блоці gradlePlugin ми даємо плагіну унікальний id і вказуємо клас імплементації, який має реалізувати інтерфейс org.gradle.api.Plugin.</p>
      <p>І ось так виглядатиме наш клас TestFormatCheckPlugin:</p>
      <pre> <br/>package com.example.plugins <br/><br/>import com.github.javaparser.ast.body.MethodDeclaration <br/>import com.github.javaparser.ast.expr.AnnotationExpr <br/>import com.github.javaparser.ast.expr.MemberValuePair <br/>import com.github.javaparser.ast.expr.NormalAnnotationExpr <br/>import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr <br/>import com.github.javaparser.utils.SourceRoot <br/>import org.gradle.api.Plugin <br/>import org.gradle.api.Project <br/>import java.io.File <br/><br/>class TestFormatCheckPlugin : Plugin&lt;Project&gt; { <br/>    override fun apply(project: Project) { <br/>        project.task("checkTestFormat") { task -&gt; <br/>            task.doLast { <br/>                val errors = arrayListOf&lt;String&gt;() <br/>                val packagePath = File("${project.projectDir}/src/test/java/com/example/tests").toPath() <br/>                SourceRoot(packagePath) <br/>                        .tryToParse("") <br/>                        .filter { it.isSuccessful } <br/>                        .map { it.result.get() } <br/>                        .forEach { compilationUnit -&gt; <br/>                            compilationUnit.findAll(MethodDeclaration::class.java).forEach { method -&gt; <br/>                                if (method.isTest()) { <br/>                                    errors.addAll(findErrorsWithTestCase(method)) <br/>                                    errors.addAll(findErrorsWithMandatoryTestProperties(method)) <br/>                                } <br/>                            } <br/>                        } <br/>                if (errors.isEmpty()) { <br/>                    println("Checking tests format passed") <br/>                } else { <br/>                    println("===================================================") <br/>                    println("Errors in tests format:") <br/>                    errors.forEach { println("&gt; $it") } <br/>                    println("===================================================") <br/>                    throw RuntimeException("Checking tests format failed. See errors in log.") <br/>                } <br/>            } <br/>        } <br/>    } <br/><br/>private fun MethodDeclaration.isTest(): Boolean = <br/>            this.findFirst(AnnotationExpr::class.java) { it.nameAsString == "Test" }.isPresent <br/><br/>    /** <br/>     * TestCase annotation should be present and match certain format <br/>     */ <br/>    private fun findErrorsWithTestCase(method: MethodDeclaration): List&lt;String&gt; { <br/>        val result = arrayListOf&lt;String&gt;() <br/>        val testCase = method.findFirst(SingleMemberAnnotationExpr::class.java) { it.nameAsString == "TestCase" } <br/>        if (testCase.isPresent) { <br/>            val testCaseValue = testCase.get().memberValue.asStringLiteralExpr().value <br/>            if (!testCaseValue.matches(Regex("REM-\\d+"))) { <br/>                result.add("@TestCase annotation does not match format 'REM-1234' for test " + <br/>                        "${method.nameAsString}. Actual value: '$testCaseValue'") <br/>            } <br/>        } else { <br/>            result.add("No @TestCase annotation found for test ${method.nameAsString}") <br/>        } <br/>        return result <br/>    } <br/><br/>    /** <br/>     * Mandatory attributes are description, team and sprint <br/>     */ <br/>    private fun findErrorsWithMandatoryTestProperties(method: MethodDeclaration): List&lt;String&gt; { <br/>        val result = arrayListOf&lt;String&gt;() <br/>        val test = method.findFirst(NormalAnnotationExpr::class.java) { it.nameAsString == "Test" }.get() <br/>        if (!test.findFirst(MemberValuePair::class.java) { it.nameAsString == "description" }.isPresent) { <br/>            result.add("Description not found in @Test for method ${method.nameAsString}") <br/>        } <br/>        val groups = test.findFirst(MemberValuePair::class.java) { it.nameAsString == "groups" } <br/>        if (groups.isPresent) { <br/>            if (!groups.get().value.toString().contains("Teams.")) { <br/>                result.add("No Team found for test method ${method.nameAsString}") <br/>            } <br/>            if (!groups.get().value.toString().contains("Sprints.")) { <br/>                result.add("No Sprint found for test method ${method.nameAsString}") <br/>            } <br/>        } else { <br/>            result.add("Groups not found in @Test for method ${method.nameAsString}") <br/>        } <br/>        return result <br/>    } <br/>} <br/></pre>
      <p>Розглянемо, що тут взагалі відбувається. Реалізовуючи інтерфейс Plugin, ми маємо реалізувати метод apply(Project), де можемо розширити логіку проекту, як нам заманеться. А саме, ми створюємо task під назвою «checkTestFormat» і пишемо його конфігурацію. Зокрема, нам потрібно просто виконати якийсь блок коду, для цього використовуємо властивість doLast {...} і описуємо в ній ту логіку, яка має відпрацювати, коли буде викликана задача checkTestFormat.</p>
      <p>Логіка ж задачі така: використовуючи javaparser,ми перебираємо всі Java файли з тестами, фільтруємо методи за анотацією @Test, потім збираємо список невідповідностей атрибутів (наприклад, наявність команди в групах тесту), і якщо список помилок не порожній, то виводимо його в консоль і валимо збірку викиданням RuntimeException.</p>
      <p>Залишилося кілька штрихів. Застосовуємо плагін у нашому проекті: для цього в нашому основному build.gradle.kts файлі в блоці plugins додаємо id нашого плагіна:</p>
      <pre> <br/>plugins { <br/>   java <br/>   `reminder-test-format-checker` <br/>} <br/></pre>
      <p>Тепер ми можемо його викликати напряму в командному рядку:</p>
      <p>
        <code>$ gradlew checkTestFormat</code>
      </p>
      <p>Але так нецікаво. Краще додати його в обов’язковому порядку після компіляції. Тоді при запуску тестів навіть локально ця перевірка не дасть пропустити жоден обов’язковий атрибут тесту. Для цього додаємо таке в основний build.gradle.kts файл:</p>
      <pre> <br/>tasks.compileTestJava { <br/>   finalizedBy("checkTestFormat") <br/>} <br/></pre>
      <p>Тепер в консолі будемо бачити таке повідомлення, якщо з атрибутами наших тестів все гаразд:</p>
      <pre>&gt; Task :checkTestFormat<br/>Checking tests format passed<br/><br/>BUILD SUCCESSFUL in 2s<br/></pre>
      <p>І наприклад таке, якщо щось пішло не так:</p>
      <pre>&gt; Task :checkTestFormat FAILED<br/>===================================================<br/>Errors in tests format:<br/>&gt; No Team found for test method createReminder<br/>&gt; No @TestCase annotation found for test updateReminder<br/>&gt; No Sprint found for test method updateReminder<br/>&gt; @TestCase annotation does not match format ’REM-1234′ for test deleteReminder. Actual value: ’REM-’<br/>===================================================<br/><br/>FAILURE: Build failed with an exception.<br/><br/>* What went wrong:<br/>Execution failed for task ’:checkTestFormat’.<br/>&gt; Checking tests format failed. See errors in log.<br/><br/>* Try:<br/>Run with —stacktrace option to get the stack trace. Run with —info or —debug option to get more log output. Run with —scan to get full insights.<br/><br/>* Get more help at https://help.gradle.org<br/><br/>BUILD FAILED in 2s<br/></pre>
      <p>Звичайно, подібний плагін також можна застосувати і до тестів у форматі BDD. Там навіть жодної бібліотеки не треба підключати: можна просто читати текстові файли з тестами і перевіряти відповідні атрибути за допомогою RegEx або іншим способом.</p>
      <h3>Swagger Codegen Plugin</h3>
      <p>У нас UI тести, але добре було б мати можливість викликати API напряму, щоб, наприклад, приготувати певні передумови для тесту, або і взагалі писати API тести. Отож, ми вирішуємо, що нам це потрібно, але як це правильно зробити? Напевно, перше, що спадає на думку, — підключити <a href="http://rest-assured.io/">Rest-Assured</a>, і вперед. На щастя, людство винайшло <a href="https://swagger.io/">Swagger</a>, тож якщо девелопери зробили вам таке щастя і підключили його, то ви будь-якої миті можете подивитись API специфікацію у читабельному вигляді і, відповідно, написати тести на потрібні вам точки доступу.</p>
      <p>Але виявляється, що існує ще більш просунутий варіант. Людство не зупинилось на досягнутому і винайшло також <a href="https://swagger.io/tools/swagger-codegen">Swagger Codegen</a> — інструмент, який дозволяє згенерувати код API клієнта (точки доступу і сутності) на основі API специфікації, яку генерує Swagger. Він підтримує різні мови і бібліотеки для API клієнтів, але нас, зокрема, цікавлять Java і Rest-Assured. Існує command-line інструмент, але оскільки він написаний на Java, то нам зручніше викликати його програмно, підключивши як бібліотеку. Аби зрозуміти, де найкраще викликати цю генерацію, поміркуймо, які саме переваги вона нам дає. Крім того, що цей код не треба писати самому, Swagger Codegen дає можливість постійно перегенеровувати API клієнт, тож якщо ми будемо це робити щоразу безпосередньо перед компіляцією проекту, і в нас змінились сутності або точки доступу, які ми смикаємо в тестах, то компіляція впаде, і ми одразу будемо змушені виправити невідповідність. Знову ж таки, отримуємо швидший фідбек, і нам не треба дізнаватись про зміни в API, розбираючи тести, що впали — вони навіть не запустяться.</p>
      <p>Отже, дописуємо ще один плагін. Для цього у файлі buildSrc/build.gradle.kts додаємо інформацію про нього і його залежності:</p>
      <pre> <br/>gradlePlugin { <br/>    plugins { <br/>        ... <br/>        create("codegen") { <br/>            id = "reminder-codegen" <br/>            implementationClass = "com.example.plugins.SwaggerCodeGenPlugin" <br/>        } <br/>    } <br/>} <br/><br/>dependencies { <br/>    ... <br/>    compile("io.swagger:swagger-codegen:2.4.7") <br/>} <br/></pre>
      <p>Тепер пишемо клас реалізації:</p>
      <pre> <br/>package com.example.plugins <br/><br/>import io.swagger.codegen.DefaultGenerator <br/>import io.swagger.codegen.config.CodegenConfigurator <br/>import org.gradle.api.Plugin <br/>import org.gradle.api.Project <br/>import java.io.File <br/><br/>const val SWAGGER_JSON_URL = "http://localhost:8080/v2/api-docs" <br/>const val INVOKER_PACKAGE = "com.example.services.api.client" <br/>const val API_PACKAGE = "com.example.services.api.controllers" <br/>const val MODEL_PACKAGE = "com.example.entities.generated" <br/><br/>class SwaggerCodeGenPlugin : Plugin&lt;Project&gt; { <br/>    override fun apply(project: Project) { <br/>        project.task("generateApi") { task -&gt; <br/>            task.doLast { <br/>                // Clean up temp dir and existing API client packages <br/>                File("${project.projectDir}/temp").deleteRecursively() <br/>                deletePackageDirectories("${project.projectDir}", <br/>                        listOf(INVOKER_PACKAGE, API_PACKAGE, MODEL_PACKAGE)) <br/><br/>                // Configure and run code generation <br/>                val config = CodegenConfigurator() <br/>                config.inputSpec = SWAGGER_JSON_URL <br/>                config.outputDir = "${project.projectDir}/temp" <br/>                config.lang = "java" <br/>                config.library = "rest-assured" <br/>                config.additionalProperties = mapOf( <br/>                        "invokerPackage" to INVOKER_PACKAGE, <br/>                        "apiPackage" to API_PACKAGE, <br/>                        "modelPackage" to MODEL_PACKAGE, <br/>                        "dateLibrary" to "java8", <br/>                        "hideGenerationTimestamp" to "true" <br/>                ) <br/>                DefaultGenerator().opts(config.toClientOptInput()).generate() <br/><br/>                // Copy generated files to the corresponding directory in sources <br/>                File("${project.projectDir}/temp/src/main/java") <br/>                        .copyRecursively(File("${project.projectDir}/src/test/java")) <br/><br/>                // Clean up temp directory <br/>                File("${project.projectDir}/temp").deleteRecursively() <br/>            } <br/>        } <br/>    } <br/>} <br/><br/>fun deletePackageDirectories(projectPath: String, packages: List&lt;String&gt;) { <br/>    packages.forEach { pack -&gt; <br/>        File("$projectPath/src/test/java/${pack.replace(".", "/")}").deleteRecursively() <br/>    } <br/>} <br/></pre>
      <p>Додамо плагін до блока plugins в нашому основному build.gradle.kts файлі:</p>
      <pre> <br/>plugins { <br/>    ... <br/>    `reminder-codegen` <br/>} <br/></pre>
      <p>У нас з’явився таск generateApi, і ми можемо його викликати:</p>
      <p>
        <code>$ gradlew generateApi</code>
      </p>
      <p>Він нам згенерує файли моделі (в нашому випадку це тільки Reminder), API клієнта і наших точок доступу (в нашому випадку ReminderControllerApi):</p>
      <figure>
        <img src="https://s.dou.ua/storage-files/image2_3qBgUxy.png"/>
      </figure>
      <p>Непоганий результат, але ми ще не можемо смикати API в тестах, треба трохи <s>допиляти напилком</s> дописати код. Створюємо клас «степів» у пакеті steps.api:</p>
      <pre> <br/>package com.example.steps.api; <br/><br/>import com.example.entities.generated.Reminder; <br/>import io.restassured.response.ResponseBody; <br/><br/>public class RemindersApiSteps extends BaseApiSteps { <br/>    public static void addReminder(Reminder reminder) { <br/>        apiClient <br/>                .reminderController() <br/>                .createUpdateUsingPUT() <br/>                .body(reminder) <br/>                .execute(ResponseBody::prettyPrint); <br/>    } <br/>} <br/></pre>
      <p>У свою чергу абстрактний клас BaseApiSteps міститиме конфігурацію apiClient:</p>
      <pre> <br/>package com.example.steps.api; <br/><br/>import com.example.services.api.client.ApiClient; <br/>import io.restassured.builder.RequestSpecBuilder; <br/>import io.restassured.filter.log.ErrorLoggingFilter; <br/><br/>import static com.example.services.api.client.ApiClient.Config.apiConfig; <br/>import static com.example.services.api.client.ApiClient.api; <br/>import static io.restassured.config.RestAssuredConfig.config; <br/><br/>public abstract class BaseApiSteps { <br/><br/>    protected static ApiClient apiClient = api(apiConfig().reqSpecSupplier( <br/>            () -&gt; new RequestSpecBuilder() <br/>                    .setConfig(config()) <br/>                    .addFilter(new ErrorLoggingFilter()) <br/>                    .setBaseUri("http://localhost:8080") <br/>    )); <br/>} <br/></pre>
      <p>Тепер ми можемо використати додавання reminder-а через API як передумову для тесту з видалення, який виглядатиме приблизно так:</p>
      <pre> <br/>@Test(description = "Delete reminder", <br/>        dataProvider = "deleteReminderData", <br/>        groups = {Teams.GAMMA, Sprints._1}) <br/>@TestCase("REM-171") <br/>public void deleteReminder(Reminder reminder) { <br/>    RemindersApiSteps.addReminder(reminder); <br/>    NavigationSteps.openRemindersApp(); <br/>    ReminderSteps.deleteLastReminder(); <br/>    CommonUiSteps.refreshPage(); <br/>    ReminderSteps.checkReminderIsAbsent(reminder); <br/>} <br/></pre>
      <p>Ще лишилося вирішити, де саме викликати генерацію класів API клієнта. В даному випадку я би все ж не включав її як обов’язкову перед стадією компіляції, адже якщо, наприклад, наш System Under Test зараз недоступний, то ламати в цей час збірку проекту у когось на комп’ютері не виглядає справедливим. В даному випадку доцільніше викликати генерацію явно:</p>
      <p>
        <code>$ gradlew generateApi test</code>
      </p>
      <p>Таку конфігурацію варто застосувати на CI після кожного коміта в Back-end: або генерація + компіляція тестів, або генерація + smoke API тести.</p>
      <h3>Висновок</h3>
      <p>Наведені приклади Gradle плагінів, як, напевно, і майже всі Gradle плагіни, можна було би замінити якимось скриптом, який лежить за межами проекту. Але коли в такій задачі з’являється потреба прив’язати її до якоїсь стадії збирання проекту, варто замислитись над перенесенням скрипта до плагіна.</p>
      <p>Поділіться, будь ласка, в коментарях досвідом написання своїх Gradle плагінів: як позитивним, так і негативним. Буду радий розширенню арсеналу.</p>
      <p>Темы: <a href="https://dou.ua/lenta/tags/tech/">tech</a>, <a href="https://dou.ua/lenta/tags/%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F/">автоматизация</a>, <a href="https://dou.ua/lenta/tags/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">тестирование</a></p>
    </article>
  </body>
</html>