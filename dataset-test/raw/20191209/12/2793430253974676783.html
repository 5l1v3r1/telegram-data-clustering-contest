<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://habr.com/en/post/479358/?utm_source=telegram.me&amp;utm_medium=social&amp;utm_campaign=forwarding-references-can-make-compiler"/>
    <meta property="og:site_name" content="Habr"/>
    <meta property="article:published_time" content="2019-12-09T12:54:51+00:00"/>
    <meta property="og:title" content="Quick reference of C++ value categories: Part 2"/>
    <meta property="og:description" content="← Go to Part 1 Passing parameters to a function When passing parameter to a function, category of a passed expression is implicitly converted to the category o..."/>
  </head>
  <body>
    <article>
      <h1>Quick reference of C++ value categories: Part 2</h1>
      <address><time datetime="2019-12-09T12:54:51+00:00">09 Dec 2019, 12:54</time> by <a rel="author" href="https://habr.com/en/users/Rualark/" target="_blank">Rualark</a></address>
      <figure>
        <img src="https://habrastorage.org/webt/nh/rz/-s/nhrz-smfzjdftvbzeuurpb7tpsu.png"/>
      </figure>
      <hr/>
      <p>← <a href="https://habr.com/en/post/479342/">Go to Part 1</a></p>
      <h3>Passing parameters to a function</h3>
      <p>When passing parameter to a function, category of a passed expression is implicitly converted to the category of function parameter: <code>void f(TO_TYPE p); FROM_TYPE x; f(x);</code> This implicit conversion takes place the same way as during an assignment (see "Assignment" section above) except that function definition cannot contain "auto" types.</p>
      <figure>
        <img src="https://habrastorage.org/webt/o5/e9/c1/o5e9c1gvz6zisyjjkjvvu7elmsu.png"/>
      </figure>
      <p>When function has multiple overloads with same number and types of parameters but different categories of parameters, overloading mechanism selects the most applicable function overload based on the category. In the table below function overloads are assigned an order in which each overload is selected when passing an expression of a particular category (e.g. 1 means that this overload will always be selected first if available):</p>
      <figure>
        <img src="https://habrastorage.org/webt/gk/e9/6t/gke96tfgahczmsch_fihgqmf0tw.png"/>
      </figure>
      <p>
        <b>Footnotes:</b>
      </p>
      <p>1 — a temporary created to hold a reference initializer persists until the end of function scope.</p>
      <p>
        <b>Note:</b>
      </p>
      <ul>
        <li>If a function takes parameter by value, this does not mean that it always creates copy of object and cannot change source object. For example, if value is moved this function, move constructor will be called and source object will be changed.</li>
        <li>You cannot have both <code>T f()</code> and <code>const T f()</code> function overloads</li>
        <li>Function can be overloaded based on whether a parameter is a reference or not. But if both functions can take argument, ambiguity will need to be resolved manual (by casting to the relevant function pointer type).</li>
        <li>Forwarding reference is most "greedy" — it wins as soon as there is no overload with exact match. That's why overloading a forwarding reference is usually not recommended (instead, avoid FR or avoid overloading or use tag dispatch or SFINAE). Constructor with one forwarding reference parameter should not be used, because it can conflict with copy and move constructors.</li>
        <li>Forwarding references can make compiler errors more difficult to understand and fix, especially if they are used multiple times sequentially.</li>
        <li>
          <p>Forwarding reference does not work in the following situations:</p>
          <ul>
            <li>You cannot forward <code>{1, 2, 3}</code> to a <code>vector&lt;int&gt;</code> with a forwarding reference.</li>
            <li>You cannot forward <code>0</code> or <code>NULL</code> to a pointer with a forwarding reference (use <code>nullptr</code> instead).</li>
            <li>You cannot forward integer static const and constexpr member variables with a forwarding reference, if they have no definitions.</li>
            <li>You cannot forward overloaded function or template with a forwarding reference, because this creates ambiguity (can be disambiguated by specifying type).</li>
          </ul>
        </li>
      </ul>
      <p>
        <b>Examples and tests of variants with printing of each called constructor and operator:</b>
      </p>
      <details>
        <summary>Examples and tests with printing of each called constructor and operator</summary>
        <pre>#include &lt;iostream&gt;<br/>#include &lt;iomanip&gt;<br/>#include &lt;map&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;string&gt;<br/><br/>using namespace std;<br/><br/>template&lt;class C, class T&gt;<br/>auto contains(const C&amp; v, const T&amp; x)<br/>-&gt; decltype(end(v), true)<br/>{<br/>    return end(v) != std::find(begin(v), end(v), x);<br/>}<br/><br/>template &lt;class... Types&gt;<br/>constexpr inline __attribute__((__always_inline__)) int UNUSED(Types&amp;&amp;...) {<br/>    return 0;<br/>};<br/><br/>map&lt;string, map&lt;string, string&gt;&gt; res;<br/>vector&lt;string&gt; froms;<br/>vector&lt;string&gt; tos;<br/>string from;<br/>string to;<br/><br/>int ready = 0;<br/><br/>void report(string st) {<br/>    if (!from.empty() &amp;&amp; !to.empty()) {<br/>        res[from][to] += st;<br/>    }<br/>    if (ready) cout &lt;&lt; st &lt;&lt; " ";<br/>}<br/><br/>struct T {<br/>    T() {<br/>        report("Dc");<br/>    }<br/>    T(int va) : a(va) {<br/>        report("Pc");<br/>    }<br/>    T(const T&amp; other) :<br/>        a(other.a)<br/>    {<br/>        report("Cc");<br/>    }<br/>    T(T&amp;&amp; other) :<br/>        a(std::exchange(other.a, 0))<br/>    {<br/>        report("Mc");<br/>    }<br/>    T&amp; operator=(int va) {<br/>        report("Va");<br/>        a = va;<br/>        return *this;<br/>    }<br/>    T&amp; operator=(const T&amp; rhs) {<br/>        report("Ca");<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = rhs.a;<br/>        return *this;<br/>    }<br/>    T&amp; operator=(T&amp;&amp; rhs) {<br/>        report("Ma");<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = std::exchange(rhs.a, 0);<br/>        return *this;<br/>    }<br/>    ~T() {<br/>        report("D");<br/>    }<br/>    int a = 1;<br/>};<br/><br/>void func_start() {<br/>    cout &lt;&lt; "|";<br/>}<br/><br/>T Fprv() { return T(4); }<br/>const T Fcprv() { return T(5); }<br/>T gs;<br/><br/>void t(T s)             { func_start(); cout &lt;&lt; s.a; }<br/>void ct(const T s)      { func_start(); cout &lt;&lt; s.a; }<br/>void tr(T&amp; s)           { func_start(); cout &lt;&lt; s.a; }<br/>void ctr(const T&amp; s)    { func_start(); cout &lt;&lt; s.a; }<br/>void trr(T&amp;&amp; s)         { func_start(); cout &lt;&lt; s.a; }<br/>void ctrr(const T&amp;&amp; s)  { func_start(); cout &lt;&lt; s.a; }<br/>template&lt;typename Z&gt;<br/>void pf(Z&amp;&amp; s)          { func_start(); gs = forward&lt;Z&gt;(s); cout &lt;&lt; gs.a; }<br/><br/>void print_col(const string &amp;st, int width) {<br/>    cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st;<br/>}<br/><br/>void test_pass(string lto, string lfrom) {<br/>    from = lfrom;<br/>    to = lto;<br/>    res[from][to] = "";<br/>    if (!from.empty() &amp;&amp; !to.empty()) {<br/>        if (!contains(froms, from)) froms.push_back(from);<br/>        if (!contains(tos, to)) tos.push_back(to);<br/>    }<br/>    print_col(lto + "(" + lfrom + "): ", 20);<br/>}<br/><br/>#define EVAL(x) #x<br/><br/>#define TEST_PASS(t, v) { \<br/>    test_pass(EVAL(t), #v); \<br/>    t(v); \<br/>    cout &lt;&lt; "-"; \<br/>}<br/><br/>void test_conversion() {<br/>    ready = 1;<br/>    T LV;<br/>    const T CLV;<br/>    T&amp; LR = LV;<br/>    const T&amp; CLR = LV;<br/>    //T&amp;&amp; XV = T(); -- actually LR<br/>    //const T&amp;&amp; CXV = T(); -- actually LR<br/>    auto &amp;&amp;fr = T();<br/><br/>#undef DT<br/>#define DT t<br/>    TEST_PASS(DT, 2);<br/>    TEST_PASS(DT, Fprv());<br/>    TEST_PASS(DT, Fcprv());<br/>    TEST_PASS(DT, LV);<br/>    TEST_PASS(DT, CLV);<br/>    TEST_PASS(DT, LR);<br/>    TEST_PASS(DT, CLR);<br/>    TEST_PASS(DT, move(LV));<br/>    TEST_PASS(DT, move(CLV));<br/>    TEST_PASS(DT, fr);<br/>#undef DT<br/>#define DT ct<br/>    TEST_PASS(DT, 2);<br/>    TEST_PASS(DT, Fprv());<br/>    TEST_PASS(DT, Fcprv());<br/>    TEST_PASS(DT, LV);<br/>    TEST_PASS(DT, CLV);<br/>    TEST_PASS(DT, LR);<br/>    TEST_PASS(DT, CLR);<br/>    TEST_PASS(DT, move(LV));<br/>    TEST_PASS(DT, move(CLV));<br/>    TEST_PASS(DT, fr);<br/>#undef DT<br/>#define DT tr<br/>    //TEST_PASS(DT, 2);<br/>    //TEST_PASS(DT, Fprv());<br/>    //TEST_PASS(DT, Fcprv());<br/>    TEST_PASS(DT, LV);<br/>    //TEST_PASS(DT, CLV);<br/>    TEST_PASS(DT, LR);<br/>    //TEST_PASS(DT, CLR);<br/>    //TEST_PASS(DT, move(LV));<br/>    //TEST_PASS(DT, move(CLV));<br/>    TEST_PASS(DT, fr);<br/>#undef DT<br/>#define DT ctr<br/>    TEST_PASS(DT, 2);<br/>    TEST_PASS(DT, Fprv());<br/>    TEST_PASS(DT, Fcprv());<br/>    TEST_PASS(DT, LV);<br/>    TEST_PASS(DT, CLV);<br/>    TEST_PASS(DT, LR);<br/>    TEST_PASS(DT, CLR);<br/>    TEST_PASS(DT, move(LV));<br/>    TEST_PASS(DT, move(CLV));<br/>    TEST_PASS(DT, fr);<br/>#undef DT<br/>#define DT trr<br/>    TEST_PASS(DT, 2);<br/>    TEST_PASS(DT, Fprv());<br/>    //TEST_PASS(DT, Fcprv());<br/>    //TEST_PASS(DT, LV);<br/>    //TEST_PASS(DT, CLV);<br/>    //TEST_PASS(DT, LR);<br/>    //TEST_PASS(DT, CLR);<br/>    TEST_PASS(DT, move(LV));<br/>    //TEST_PASS(DT, move(CLV));<br/>    //TEST_PASS(DT, fr);<br/>#undef DT<br/>#define DT ctrr<br/>    TEST_PASS(DT, 2);<br/>    TEST_PASS(DT, Fprv());<br/>    TEST_PASS(DT, Fcprv());<br/>    //TEST_PASS(DT, LV);<br/>    //TEST_PASS(DT, CLV);<br/>    //TEST_PASS(DT, LR);<br/>    //TEST_PASS(DT, CLR);<br/>    TEST_PASS(DT, move(LV));<br/>    TEST_PASS(DT, move(CLV));<br/>    //TEST_PASS(DT, fr);<br/>#undef DT<br/>#define DT pf<br/>    TEST_PASS(DT, 2);<br/>    TEST_PASS(DT, Fprv());<br/>    TEST_PASS(DT, Fcprv());<br/>    TEST_PASS(DT, LV);<br/>    TEST_PASS(DT, CLV);<br/>    TEST_PASS(DT, LR);<br/>    TEST_PASS(DT, CLR);<br/>    TEST_PASS(DT, move(LV));<br/>    TEST_PASS(DT, move(CLV));<br/>    TEST_PASS(DT, fr);<br/><br/>    cout &lt;&lt; endl;<br/>    const int twidth = 10;<br/>    cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "From:";<br/>    for (const auto&amp; lto : tos) {<br/>        cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lto;<br/>    }<br/>    cout &lt;&lt; endl;<br/>    for (const auto&amp; lfrom : froms) {<br/>        cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lfrom;<br/>        for (const auto&amp; lto : tos) {<br/>            if (!res.count(lfrom) || !res[lfrom].count(lto)) {<br/>                cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "-";<br/>            } else if (res[lfrom][lto].empty()) {<br/>                cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "+";<br/>            } else {<br/>                cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; res[lfrom][lto];<br/>            }<br/>        }<br/>        cout &lt;&lt; endl;<br/>    }<br/><br/>    cout &lt;&lt; endl;<br/>}<br/><br/>int main() {<br/>    test_conversion();<br/>    cout &lt;&lt; endl;<br/>    return 0;<br/>}<br/><br/>/* Output:<br/><br/>Dc Dc Dc<br/>t(2):               Pc |2D -<br/>t(Fprv()):          Pc |4D -<br/>t(Fcprv()):         Pc |5D -<br/>t(LV):              Cc |1D -<br/>t(CLV):             Cc |1D -<br/>t(LR):              Cc |1D -<br/>t(CLR):             Cc |1D -<br/>t(move(LV)):        Mc |1D -<br/>t(move(CLV)):       Cc |1D -<br/>t(fr):              Cc |1D -<br/>ct(2):              Pc |2D -<br/>ct(Fprv()):         Pc |4D -<br/>ct(Fcprv()):        Pc |5D -<br/>ct(LV):             Cc |0D -<br/>ct(CLV):            Cc |1D -<br/>ct(LR):             Cc |0D -<br/>ct(CLR):            Cc |0D -<br/>ct(move(LV)):       Mc |0D -<br/>ct(move(CLV)):      Cc |1D -<br/>ct(fr):             Cc |1D -<br/>tr(LV):             |0-<br/>tr(LR):             |0-<br/>tr(fr):             |1-<br/>ctr(2):             Pc |2D -<br/>ctr(Fprv()):        Pc |4D -<br/>ctr(Fcprv()):       Pc |5D -<br/>ctr(LV):            |0-<br/>ctr(CLV):           |1-<br/>ctr(LR):            |0-<br/>ctr(CLR):           |0-<br/>ctr(move(LV)):      |0-<br/>ctr(move(CLV)):     |1-<br/>ctr(fr):            |1-<br/>trr(2):             Pc |2D -<br/>trr(Fprv()):        Pc |4D -<br/>trr(move(LV)):      |0-<br/>ctrr(2):            Pc |2D -<br/>ctrr(Fprv()):       Pc |4D -<br/>ctrr(Fcprv()):      Pc |5D -<br/>ctrr(move(LV)):     |0-<br/>ctrr(move(CLV)):    |1-<br/>pf(2):              |Va 2-<br/>pf(Fprv()):         Pc |Ma 4D -<br/>pf(Fcprv()):        Pc |Ca 5D -<br/>pf(LV):             |Ca 0-<br/>pf(CLV):            |Ca 1-<br/>pf(LR):             |Ca 0-<br/>pf(CLR):            |Ca 0-<br/>pf(move(LV)):       |Ma 0-<br/>pf(move(CLV)):      |Ca 1-<br/>pf(fr):             |Ca 1-<br/>From:     t         ct        tr        ctr       trr       ctrr      pf<br/>2         PcD       PcD       -         PcD       PcD       PcD       Va<br/>Fprv()    PcD       PcD       -         PcD       PcD       PcD       PcMaD<br/>Fcprv()   PcD       PcD       -         PcD       -         PcD       PcCaD<br/>LV        CcD       CcD       +         +         -         -         Ca<br/>CLV       CcD       CcD       -         +         -         -         Ca<br/>LR        CcD       CcD       +         +         -         -         Ca<br/>CLR       CcD       CcD       -         +         -         -         Ca<br/>move(LV)  McD       McD       -         +         +         +         Ma<br/>move(CLV) CcD       CcD       -         +         -         +         Ca<br/>fr        CcD       CcD       +         +         -         -         Ca<br/><br/>D D D<br/><br/>*/<br/></pre>
      </details>
      <p>
        <b>Links:</b>
      </p>
      <p>
        <a href="https://en.cppreference.com/w/cpp/language/overload_resolution">Overload resolution</a>
        <br/>
        <a href="https://stackoverflow.com/questions/17642357/const-reference-vs-move-semantics">Const reference vs move semantics</a>
        <br/>
        <a href="https://stackoverflow.com/questions/51705967/advantages-of-pass-by-value-and-stdmove-over-pass-by-reference">Advantages of pass by value and std::move over pass by reference</a>
      </p>
      <h3>Returning from a function</h3>
      <p>When returning an expression from a function, category of returned expression FROM_TYPE can mismatch category of function return type RETURN_TYPE, which can mismatch category of assigned variable TO_TYPE: <code>RETURN_TYPE f() { FROM_TYPE x; return x; } TO_TYPE y = f();</code></p>
      <p>In this case implicit conversion can occur two times:</p>
      <ul>
        <li>When converting from FROM_TYPE to RETURN TYPE. This conversion is the same as during the assignment, except trying to convert PRV or CPRV to T&amp;&amp;, const T&amp;&amp; or const T&amp; (such conversions cannot occur, because lifetime of temporary object cannot be extended longer than function scope, <a href="https://stackoverflow.com/questions/1116641/is-returning-by-rvalue-reference-more-efficient">link</a>)</li>
        <li>When converting from RETURN_TYPE to TO_TYPE — a usual assignment conversion (see "Assigning value categories" above).</li>
      </ul>
      <figure>
        <img src="https://habrastorage.org/webt/70/gb/av/70gbav3z_faiwbacrdwoywvgnyw.png"/>
      </figure>
      <p>
        <b>Footnotes:</b>
      </p>
      <p>1 — a temporary created during assignment to hold a reference initializer persists until the end of its reference's scope (red font).</p>
      <p>
        <b>Examples and tests of variants with printing of used copy/move constructors and operators:</b>
      </p>
      <details>
        <summary>Examples and tests with printing of each called constructor and operator</summary>
        <pre>#include &lt;iostream&gt;<br/>#include &lt;iomanip&gt;<br/>#include &lt;map&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;string&gt;<br/><br/>using namespace std;<br/><br/>template&lt;class C, class T&gt;<br/>auto contains(const C&amp; v, const T&amp; x)<br/>-&gt; decltype(end(v), true)<br/>{<br/>    return end(v) != std::find(begin(v), end(v), x);<br/>}<br/><br/>template &lt;class... Types&gt;<br/>constexpr inline __attribute__((__always_inline__)) int UNUSED(Types&amp;&amp;...) {<br/>    return 0;<br/>};<br/><br/>map&lt;string, map&lt;string, string&gt;&gt; res;<br/>vector&lt;string&gt; froms;<br/>vector&lt;string&gt; tos;<br/>string from;<br/>string to;<br/><br/>int ready = 0;<br/><br/>void report(string st) {<br/>    if (!from.empty() &amp;&amp; !to.empty()) {<br/>        res[from][to] += st;<br/>    }<br/>    if (ready) cout &lt;&lt; st &lt;&lt; " ";<br/>}<br/><br/>struct T {<br/>    T() {<br/>        report("Dc");<br/>    }<br/>    T(int va) : a(va) {<br/>        report("Pc");<br/>    }<br/>    T(const T&amp; other) :<br/>        a(other.a)<br/>    {<br/>        report("Cc");<br/>    }<br/>    T(T&amp;&amp; other) :<br/>        a(std::exchange(other.a, 0))<br/>    {<br/>        report("Mc");<br/>    }<br/>    T&amp; operator=(int va) {<br/>        report("Va");<br/>        a = va;<br/>        return *this;<br/>    }<br/>    T&amp; operator=(const T&amp; rhs) {<br/>        report("Ca");<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = rhs.a;<br/>        return *this;<br/>    }<br/>    T&amp; operator=(T&amp;&amp; rhs) {<br/>        report("Ma");<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = std::exchange(rhs.a, 0);<br/>        return *this;<br/>    }<br/>    ~T() {<br/>        report("D");<br/>    }<br/>    int a = 1;<br/>};<br/><br/>T lv;<br/>const T clv;<br/>T&amp; lr = lv;<br/>T&amp;&amp; rr = std::move(lv);<br/>const T&amp; clr = clv;<br/>const T&amp;&amp; crr = std::move(clv);<br/>auto&amp;&amp; arr = std::move(lv);<br/><br/>T Fprv() { return T(); }<br/>const T Fcprv() { return T(); }<br/><br/>void func_start() {<br/>    cout &lt;&lt; "|";<br/>}<br/><br/>T prv_t() { func_start(); return T(2); }<br/>const T prv_ct() { func_start(); return T(2); }<br/>// Prohibited (returning reference to temporary object):<br/>// T&amp; prv_tr() { func_start(); return T(2); }<br/>// const T&amp; prv_ctr() { func_start(); return T(2); }<br/>// T&amp;&amp; prv_trr() { func_start(); return T(2); }<br/>// const T&amp;&amp; prv_ctrr() { func_start(); return T(2); }<br/>template&lt;typename Z&gt; Z&amp;&amp; prv_fr() { func_start(); return Z(2); }<br/><br/>/* Same as prv_ (I tested)<br/>T cprv_t() { func_start(); return Fcprv(); }<br/>const T cprv_ct() { func_start(); return Fcprv(); }<br/>// Prohibited (returning reference to temporary object):<br/>// T&amp; cprv_tr() { func_start(); return Fcprv(); }<br/>// const T&amp; cprv_ctr() { func_start(); return Fcprv(); }<br/>// T&amp;&amp; cprv_trr() { func_start(); return Fcprv(); }<br/>// const T&amp;&amp; cprv_ctrr() { func_start(); return Fcprv(); }<br/>template&lt;typename Z&gt; Z&amp;&amp; cprv_fr() { func_start(); return Fcprv(); }<br/>*/<br/><br/>/* Same as prv_ (I tested)<br/>T lit_t() { func_start(); return 3; }<br/>const T lit_ct() { func_start(); return 3; }<br/>//T&amp; lit_tr() { func_start(); return 3; }<br/>//const T&amp; lit_ctr() { func_start(); return 3; }<br/>//T&amp;&amp; lit_trr() { func_start(); return 3; }<br/>//const T&amp;&amp; lit_ctrr() { func_start(); return 3; }<br/>template&lt;typename Z&gt; Z&amp;&amp; lit_fr() { func_start(); return 3; }<br/> */<br/><br/>T lr_t()                { func_start(); return lr; }<br/>const T lr_ct()         { func_start(); return lr; }<br/>T&amp; lr_tr()              { func_start(); return lr; }<br/>const T&amp; lr_ctr()       { func_start(); return lr; }<br/>//T&amp;&amp; lr_trr()          { func_start(); return lr; }<br/>//const T&amp;&amp; lr_ctrr()   { func_start(); return lr; }<br/>template&lt;typename Z&gt; Z&amp;&amp; lr_fr() { func_start(); return lr; }<br/><br/>T clr_t()                { func_start(); return clr; }<br/>const T clr_ct()         { func_start(); return clr; }<br/>//T&amp; clr_tr()              { func_start(); return clr; }<br/>const T&amp; clr_ctr()       { func_start(); return clr; }<br/>//T&amp;&amp; clr_trr()          { func_start(); return clr; }<br/>//const T&amp;&amp; clr_ctrr()   { func_start(); return clr; }<br/>template&lt;typename Z&gt; Z&amp;&amp; clr_fr() { func_start(); return clr; }<br/><br/>/* This is the same as xv and cxv (I tested it)<br/>T rr_t()                { func_start(); return move(rr); }<br/>const T rr_ct()         { func_start(); return move(rr); }<br/>//T&amp; rr_tr()              { func_start(); return move(rr); }<br/>const T&amp; rr_ctr()       { func_start(); return move(rr); }<br/>T&amp;&amp; rr_trr()          { func_start(); return move(rr); }<br/>const T&amp;&amp; rr_ctrr()   { func_start(); return move(rr); }<br/>template&lt;typename Z&gt; Z&amp;&amp; rr_fr() { func_start(); return move(rr); }<br/><br/>T crr_t()                { func_start(); return move(crr); }<br/>const T crr_ct()         { func_start(); return move(crr); }<br/>//T&amp; crr_tr()              { func_start(); return move(crr); }<br/>const T&amp; crr_ctr()       { func_start(); return move(crr); }<br/>//T&amp;&amp; crr_trr()          { func_start(); return move(crr); }<br/>const T&amp;&amp; crr_ctrr()   { func_start(); return move(crr); }<br/>template&lt;typename Z&gt; Z&amp;&amp; crr_fr() { func_start(); return move(crr); }<br/> */<br/><br/>/* Same as lr_ (I tested)<br/>T arr_t()                { func_start(); return arr; }<br/>const T arr_ct()         { func_start(); return arr; }<br/>T&amp; arr_tr()              { func_start(); return arr; }<br/>const T&amp; arr_ctr()       { func_start(); return arr; }<br/>//T&amp;&amp; arr_trr()          { func_start(); return arr; }<br/>//const T&amp;&amp; arr_ctrr()   { func_start(); return arr; }<br/>template&lt;typename Z&gt; Z&amp;&amp; arr_fr() { func_start(); return arr; }<br/> */<br/><br/>T lv_t()                { func_start(); return lv; }<br/>const T lv_ct()         { func_start(); return lv; }<br/>T&amp; lv_tr()              { func_start(); return lv; }<br/>const T&amp; lv_ctr()       { func_start(); return lv; }<br/>//T&amp;&amp; lv_trr()          { func_start(); return lv; }<br/>//const T&amp;&amp; lv_ctrr()   { func_start(); return lv; }<br/>template&lt;typename Z&gt; Z&amp;&amp; lv_fr() { func_start(); return lv; }<br/><br/>T xv_t() { func_start(); return move(lv); }<br/>const T xv_ct() { func_start(); return move(lv); }<br/>//T&amp; xv_tr() { func_start(); return move(lv); }<br/>const T&amp; xv_ctr() { func_start(); return move(lv); }<br/>T&amp;&amp; xv_trr() { func_start(); return move(lv); }<br/>const T&amp;&amp; xv_ctrr() { func_start(); return move(lv); }<br/>template&lt;typename Z&gt; Z&amp;&amp; xv_fr() { func_start(); return move(lv); }<br/><br/>T clv_t() { func_start(); return clv; }<br/>const T clv_ct() { func_start(); return clv; }<br/>//T&amp; clv_tr() { func_start(); return clv; }<br/>const T&amp; clv_ctr() { func_start(); return clv; }<br/>//T&amp;&amp; clv_trr() { func_start(); return clv; }<br/>//const T&amp;&amp; clv_ctrr() { func_start(); return clv; }<br/>template&lt;typename Z&gt; Z&amp;&amp; clv_fr() { func_start(); return clv; }<br/><br/>T cxv_t() { func_start(); return move(clv); }<br/>const T cxv_ct() { func_start(); return move(clv); }<br/>//T&amp; cxv_tr() { func_start(); return move(clv); }<br/>const T&amp; cxv_ctr() { func_start(); return move(clv); }<br/>//T&amp;&amp; cxv_trr() { func_start(); return move(clv); }<br/>const T&amp;&amp; cxv_ctrr() { func_start(); return move(clv); }<br/>template&lt;typename Z&gt; Z&amp;&amp; cxv_fr() { func_start(); return move(clv); }<br/><br/>void print_col(const string &amp;st, int width) {<br/>    cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st;<br/>}<br/><br/>void test_call(string lto, string lfrom) {<br/>    from = lfrom;<br/>    to = lto;<br/>    res[from][to] = "";<br/>    if (!from.empty() &amp;&amp; !to.empty()) {<br/>        if (!contains(froms, from)) froms.push_back(from);<br/>        if (!contains(tos, to)) tos.push_back(to);<br/>    }<br/>    print_col(lto + " = " + lfrom + ": ", 20);<br/>}<br/><br/>#define EVAL(x) #x<br/><br/>#define TEST_CALL(t, v) { \<br/>    test_call(EVAL(t), #v); \<br/>    t s = v(); \<br/>    cout &lt;&lt; s.a; \<br/>    UNUSED(s); \<br/>    cout &lt;&lt; "-"; \<br/>}<br/><br/>void test_return() {<br/>    ready = 1;<br/>    cout &lt;&lt; endl;<br/>#define DT T<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT const T<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT T&amp;<br/>    //TEST_CALL(DT, prv_t);<br/>    //TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    //TEST_CALL(DT, lr_t);<br/>    //TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    //TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    //TEST_CALL(DT, clr_t);<br/>    //TEST_CALL(DT, clr_ct);<br/>    //TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    //TEST_CALL(DT, lv_t);<br/>    //TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    //TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    //TEST_CALL(DT, xv_t);<br/>    //TEST_CALL(DT, xv_ct);<br/>    //TEST_CALL(DT, xv_ctr);<br/>    //TEST_CALL(DT, xv_trr);<br/>    //TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    //TEST_CALL(DT, clv_t);<br/>    //TEST_CALL(DT, clv_ct);<br/>    //TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    //TEST_CALL(DT, cxv_t);<br/>    //TEST_CALL(DT, cxv_ct);<br/>    //TEST_CALL(DT, cxv_ctr);<br/>    //TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT T&amp;&amp;<br/>    TEST_CALL(DT, prv_t);<br/>    //TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    //TEST_CALL(DT, lr_ct);<br/>    //TEST_CALL(DT, lr_tr);<br/>    //TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    //TEST_CALL(DT, clr_ct);<br/>    //TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    //TEST_CALL(DT, lv_ct);<br/>    //TEST_CALL(DT, lv_tr);<br/>    //TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    //TEST_CALL(DT, xv_ct);<br/>    //TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    //TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    //TEST_CALL(DT, clv_ct);<br/>    //TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    //TEST_CALL(DT, cxv_ct);<br/>    //TEST_CALL(DT, cxv_ctr);<br/>    //TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT const T&amp;&amp;<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    //TEST_CALL(DT, lr_tr);<br/>    //TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    //TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    //TEST_CALL(DT, lv_tr);<br/>    //TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    //TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    //TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    //TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT const auto&amp;&amp;<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    //TEST_CALL(DT, lr_tr);<br/>    //TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    //TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    //TEST_CALL(DT, lv_tr);<br/>    //TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    //TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    //TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    //TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT auto&amp;<br/>    //TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    //TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    //TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    //TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    //TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    TEST_CALL(DT, xv_ctr);<br/>    //TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    //TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    //TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT const T&amp;<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT const auto&amp;<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/>#undef DT<br/>#define DT auto&amp;&amp;<br/>    TEST_CALL(DT, prv_t);<br/>    TEST_CALL(DT, prv_ct);<br/>    //TEST_CALL(DT, prv_fr);<br/>    TEST_CALL(DT, lr_t);<br/>    TEST_CALL(DT, lr_ct);<br/>    TEST_CALL(DT, lr_tr);<br/>    TEST_CALL(DT, lr_ctr);<br/>    //TEST_CALL(DT, lr_fr);<br/>    TEST_CALL(DT, clr_t);<br/>    TEST_CALL(DT, clr_ct);<br/>    TEST_CALL(DT, clr_ctr);<br/>    //TEST_CALL(DT, clr_fr);<br/>    TEST_CALL(DT, lv_t);<br/>    TEST_CALL(DT, lv_ct);<br/>    TEST_CALL(DT, lv_tr);<br/>    TEST_CALL(DT, lv_ctr);<br/>    //TEST_CALL(DT, lv_fr);<br/>    TEST_CALL(DT, xv_t);<br/>    TEST_CALL(DT, xv_ct);<br/>    TEST_CALL(DT, xv_ctr);<br/>    TEST_CALL(DT, xv_trr);<br/>    TEST_CALL(DT, xv_ctrr);<br/>    //TEST_CALL(DT, xv_fr);<br/>    TEST_CALL(DT, clv_t);<br/>    TEST_CALL(DT, clv_ct);<br/>    TEST_CALL(DT, clv_ctr);<br/>    //TEST_CALL(DT, clv_fr);<br/>    TEST_CALL(DT, cxv_t);<br/>    TEST_CALL(DT, cxv_ct);<br/>    TEST_CALL(DT, cxv_ctr);<br/>    TEST_CALL(DT, cxv_ctrr);<br/>    //TEST_CALL(DT, cxv_fr);<br/><br/>    cout &lt;&lt; endl;<br/>    const int twidth = 9;<br/>    cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "From:";<br/>    for (const auto&amp; lto : tos) {<br/>        cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lto;<br/>    }<br/>    cout &lt;&lt; endl;<br/>    for (const auto&amp; lfrom : froms) {<br/>        cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lfrom;<br/>        for (const auto&amp; lto : tos) {<br/>            if (!res.count(lfrom) || !res[lfrom].count(lto)) {<br/>                cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "-";<br/>            } else if (res[lfrom][lto].empty()) {<br/>                cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "+";<br/>            } else {<br/>                cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; res[lfrom][lto];<br/>            }<br/>        }<br/>        cout &lt;&lt; endl;<br/>    }<br/>}<br/><br/>int main() {<br/><br/>    test_return();<br/><br/>    return 0;<br/>}<br/><br/>/* Output:<br/><br/>T = prv_t:          |Pc 2-D<br/>T = prv_ct:         |Pc 2-D<br/>T = lr_t:           |Cc 1-D<br/>T = lr_ct:          |Cc 1-D<br/>T = lr_tr:          |Cc 1-D<br/>T = lr_ctr:         |Cc 1-D<br/>T = clr_t:          |Cc 1-D<br/>T = clr_ct:         |Cc 1-D<br/>T = clr_ctr:        |Cc 1-D<br/>T = lv_t:           |Cc 1-D<br/>T = lv_ct:          |Cc 1-D<br/>T = lv_tr:          |Cc 1-D<br/>T = lv_ctr:         |Cc 1-D<br/>T = xv_t:           |Mc 1-D<br/>T = xv_ct:          |Mc 0-D<br/>T = xv_ctr:         |Cc 0-D<br/>T = xv_trr:         |Mc 0-D<br/>T = xv_ctrr:        |Cc 0-D<br/>T = clv_t:          |Cc 1-D<br/>T = clv_ct:         |Cc 1-D<br/>T = clv_ctr:        |Cc 1-D<br/>T = cxv_t:          |Cc 1-D<br/>T = cxv_ct:         |Cc 1-D<br/>T = cxv_ctr:        |Cc 1-D<br/>T = cxv_ctrr:       |Cc 1-D<br/>const T = prv_t:    |Pc 2-D<br/>const T = prv_ct:   |Pc 2-D<br/>const T = lr_t:     |Cc 0-D<br/>const T = lr_ct:    |Cc 0-D<br/>const T = lr_tr:    |Cc 0-D<br/>const T = lr_ctr:   |Cc 0-D<br/>const T = clr_t:    |Cc 1-D<br/>const T = clr_ct:   |Cc 1-D<br/>const T = clr_ctr:  |Cc 1-D<br/>const T = lv_t:     |Cc 0-D<br/>const T = lv_ct:    |Cc 0-D<br/>const T = lv_tr:    |Cc 0-D<br/>const T = lv_ctr:   |Cc 0-D<br/>const T = xv_t:     |Mc 0-D<br/>const T = xv_ct:    |Mc 0-D<br/>const T = xv_ctr:   |Cc 0-D<br/>const T = xv_trr:   |Mc 0-D<br/>const T = xv_ctrr:  |Cc 0-D<br/>const T = clv_t:    |Cc 1-D<br/>const T = clv_ct:   |Cc 1-D<br/>const T = clv_ctr:  |Cc 1-D<br/>const T = cxv_t:    |Cc 1-D<br/>const T = cxv_ct:   |Cc 1-D<br/>const T = cxv_ctr:  |Cc 1-D<br/>const T = cxv_ctrr: |Cc 1-D<br/>T&amp; = lr_tr:         |0-<br/>T&amp; = lv_tr:         |0-<br/>T&amp;&amp; = prv_t:        |Pc 2-D<br/>T&amp;&amp; = lr_t:         |Cc 0-D<br/>T&amp;&amp; = clr_t:        |Cc 1-D<br/>T&amp;&amp; = lv_t:         |Cc 0-D<br/>T&amp;&amp; = xv_t:         |Mc 0-D<br/>T&amp;&amp; = xv_trr:       |0-<br/>T&amp;&amp; = clv_t:        |Cc 1-D<br/>T&amp;&amp; = cxv_t:        |Cc 1-D<br/>const T&amp;&amp; = prv_t:  |Pc 2-D<br/>const T&amp;&amp; = prv_ct: |Pc 2-D<br/>const T&amp;&amp; = lr_t:   |Cc 0-D<br/>const T&amp;&amp; = lr_ct:  |Cc 0-D<br/>const T&amp;&amp; = clr_t:  |Cc 1-D<br/>const T&amp;&amp; = clr_ct: |Cc 1-D<br/>const T&amp;&amp; = lv_t:   |Cc 0-D<br/>const T&amp;&amp; = lv_ct:  |Cc 0-D<br/>const T&amp;&amp; = xv_t:   |Mc 0-D<br/>const T&amp;&amp; = xv_ct:  |Mc 0-D<br/>const T&amp;&amp; = xv_trr: |0-<br/>const T&amp;&amp; = xv_ctrr: |0-<br/>const T&amp;&amp; = clv_t:  |Cc 1-D<br/>const T&amp;&amp; = clv_ct: |Cc 1-D<br/>const T&amp;&amp; = cxv_t:  |Cc 1-D<br/>const T&amp;&amp; = cxv_ct: |Cc 1-D<br/>const T&amp;&amp; = cxv_ctrr: |1-<br/>const auto&amp;&amp; = prv_t: |Pc 2-D<br/>const auto&amp;&amp; = prv_ct: |Pc 2-D<br/>const auto&amp;&amp; = lr_t: |Cc 0-D<br/>const auto&amp;&amp; = lr_ct: |Cc 0-D<br/>const auto&amp;&amp; = clr_t: |Cc 1-D<br/>const auto&amp;&amp; = clr_ct: |Cc 1-D<br/>const auto&amp;&amp; = lv_t: |Cc 0-D<br/>const auto&amp;&amp; = lv_ct: |Cc 0-D<br/>const auto&amp;&amp; = xv_t: |Mc 0-D<br/>const auto&amp;&amp; = xv_ct: |Mc 0-D<br/>const auto&amp;&amp; = xv_trr: |0-<br/>const auto&amp;&amp; = xv_ctrr: |0-<br/>const auto&amp;&amp; = clv_t: |Cc 1-D<br/>const auto&amp;&amp; = clv_ct: |Cc 1-D<br/>const auto&amp;&amp; = cxv_t: |Cc 1-D<br/>const auto&amp;&amp; = cxv_ct: |Cc 1-D<br/>const auto&amp;&amp; = cxv_ctrr: |1-<br/>auto&amp; = prv_ct:     |Pc 2-D<br/>auto&amp; = lr_ct:      |Cc 0-D<br/>auto&amp; = lr_tr:      |0-<br/>auto&amp; = lr_ctr:     |0-<br/>auto&amp; = clr_ct:     |Cc 1-D<br/>auto&amp; = clr_ctr:    |1-<br/>auto&amp; = lv_ct:      |Cc 0-D<br/>auto&amp; = lv_tr:      |0-<br/>auto&amp; = lv_ctr:     |0-<br/>auto&amp; = xv_ct:      |Mc 0-D<br/>auto&amp; = xv_ctr:     |0-<br/>auto&amp; = xv_ctrr:    |0-<br/>auto&amp; = clv_ct:     |Cc 1-D<br/>auto&amp; = clv_ctr:    |1-<br/>auto&amp; = cxv_ct:     |Cc 1-D<br/>auto&amp; = cxv_ctr:    |1-<br/>auto&amp; = cxv_ctrr:   |1-<br/>const T&amp; = prv_t:   |Pc 2-D<br/>const T&amp; = prv_ct:  |Pc 2-D<br/>const T&amp; = lr_t:    |Cc 0-D<br/>const T&amp; = lr_ct:   |Cc 0-D<br/>const T&amp; = lr_tr:   |0-<br/>const T&amp; = lr_ctr:  |0-<br/>const T&amp; = clr_t:   |Cc 1-D<br/>const T&amp; = clr_ct:  |Cc 1-D<br/>const T&amp; = clr_ctr: |1-<br/>const T&amp; = lv_t:    |Cc 0-D<br/>const T&amp; = lv_ct:   |Cc 0-D<br/>const T&amp; = lv_tr:   |0-<br/>const T&amp; = lv_ctr:  |0-<br/>const T&amp; = xv_t:    |Mc 0-D<br/>const T&amp; = xv_ct:   |Mc 0-D<br/>const T&amp; = xv_ctr:  |0-<br/>const T&amp; = xv_trr:  |0-<br/>const T&amp; = xv_ctrr: |0-<br/>const T&amp; = clv_t:   |Cc 1-D<br/>const T&amp; = clv_ct:  |Cc 1-D<br/>const T&amp; = clv_ctr: |1-<br/>const T&amp; = cxv_t:   |Cc 1-D<br/>const T&amp; = cxv_ct:  |Cc 1-D<br/>const T&amp; = cxv_ctr: |1-<br/>const T&amp; = cxv_ctrr: |1-<br/>const auto&amp; = prv_t: |Pc 2-D<br/>const auto&amp; = prv_ct: |Pc 2-D<br/>const auto&amp; = lr_t: |Cc 0-D<br/>const auto&amp; = lr_ct: |Cc 0-D<br/>const auto&amp; = lr_tr: |0-<br/>const auto&amp; = lr_ctr: |0-<br/>const auto&amp; = clr_t: |Cc 1-D<br/>const auto&amp; = clr_ct: |Cc 1-D<br/>const auto&amp; = clr_ctr: |1-<br/>const auto&amp; = lv_t: |Cc 0-D<br/>const auto&amp; = lv_ct: |Cc 0-D<br/>const auto&amp; = lv_tr: |0-<br/>const auto&amp; = lv_ctr: |0-<br/>const auto&amp; = xv_t: |Mc 0-D<br/>const auto&amp; = xv_ct: |Mc 0-D<br/>const auto&amp; = xv_ctr: |0-<br/>const auto&amp; = xv_trr: |0-<br/>const auto&amp; = xv_ctrr: |0-<br/>const auto&amp; = clv_t: |Cc 1-D<br/>const auto&amp; = clv_ct: |Cc 1-D<br/>const auto&amp; = clv_ctr: |1-<br/>const auto&amp; = cxv_t: |Cc 1-D<br/>const auto&amp; = cxv_ct: |Cc 1-D<br/>const auto&amp; = cxv_ctr: |1-<br/>const auto&amp; = cxv_ctrr: |1-<br/>auto&amp;&amp; = prv_t:     |Pc 2-D<br/>auto&amp;&amp; = prv_ct:    |Pc 2-D<br/>auto&amp;&amp; = lr_t:      |Cc 0-D<br/>auto&amp;&amp; = lr_ct:     |Cc 0-D<br/>auto&amp;&amp; = lr_tr:     |0-<br/>auto&amp;&amp; = lr_ctr:    |0-<br/>auto&amp;&amp; = clr_t:     |Cc 1-D<br/>auto&amp;&amp; = clr_ct:    |Cc 1-D<br/>auto&amp;&amp; = clr_ctr:   |1-<br/>auto&amp;&amp; = lv_t:      |Cc 0-D<br/>auto&amp;&amp; = lv_ct:     |Cc 0-D<br/>auto&amp;&amp; = lv_tr:     |0-<br/>auto&amp;&amp; = lv_ctr:    |0-<br/>auto&amp;&amp; = xv_t:      |Mc 0-D<br/>auto&amp;&amp; = xv_ct:     |Mc 0-D<br/>auto&amp;&amp; = xv_ctr:    |0-<br/>auto&amp;&amp; = xv_trr:    |0-<br/>auto&amp;&amp; = xv_ctrr:   |0-<br/>auto&amp;&amp; = clv_t:     |Cc 1-D<br/>auto&amp;&amp; = clv_ct:    |Cc 1-D<br/>auto&amp;&amp; = clv_ctr:   |1-<br/>auto&amp;&amp; = cxv_t:     |Cc 1-D<br/>auto&amp;&amp; = cxv_ct:    |Cc 1-D<br/>auto&amp;&amp; = cxv_ctr:   |1-<br/>auto&amp;&amp; = cxv_ctrr:  |1-<br/>From:    T        const T  T&amp;       T&amp;&amp;      const T&amp;&amp;const auto&amp;&amp;auto&amp;    const T&amp; const auto&amp;auto&amp;&amp;<br/>prv_t    PcD      PcD      -        PcD      PcD      PcD      -        PcD      PcD      PcD<br/>prv_ct   PcD      PcD      -        -        PcD      PcD      PcD      PcD      PcD      PcD<br/>lr_t     CcD      CcD      -        CcD      CcD      CcD      -        CcD      CcD      CcD<br/>lr_ct    CcD      CcD      -        -        CcD      CcD      CcD      CcD      CcD      CcD<br/>lr_tr    CcD      CcD      +        -        -        -        +        +        +        +<br/>lr_ctr   CcD      CcD      -        -        -        -        +        +        +        +<br/>clr_t    CcD      CcD      -        CcD      CcD      CcD      -        CcD      CcD      CcD<br/>clr_ct   CcD      CcD      -        -        CcD      CcD      CcD      CcD      CcD      CcD<br/>clr_ctr  CcD      CcD      -        -        -        -        +        +        +        +<br/>lv_t     CcD      CcD      -        CcD      CcD      CcD      -        CcD      CcD      CcD<br/>lv_ct    CcD      CcD      -        -        CcD      CcD      CcD      CcD      CcD      CcD<br/>lv_tr    CcD      CcD      +        -        -        -        +        +        +        +<br/>lv_ctr   CcD      CcD      -        -        -        -        +        +        +        +<br/>xv_t     McD      McD      -        McD      McD      McD      -        McD      McD      McD<br/>xv_ct    McD      McD      -        -        McD      McD      McD      McD      McD      McD<br/>xv_ctr   CcD      CcD      -        -        -        -        +        +        +        +<br/>xv_trr   McD      McD      -        +        +        +        -        +        +        +<br/>xv_ctrr  CcD      CcD      -        -        +        +        +        +        +        +<br/>clv_t    CcD      CcD      -        CcD      CcD      CcD      -        CcD      CcD      CcD<br/>clv_ct   CcD      CcD      -        -        CcD      CcD      CcD      CcD      CcD      CcD<br/>clv_ctr  CcD      CcD      -        -        -        -        +        +        +        +<br/>cxv_t    CcD      CcD      -        CcD      CcD      CcD      -        CcD      CcD      CcD<br/>cxv_ct   CcD      CcD      -        -        CcD      CcD      CcD      CcD      CcD      CcD<br/>cxv_ctr  CcD      CcD      -        -        -        -        +        +        +        +<br/>cxv_ctrr CcD      CcD      -        -        +        +        +        +        +        +<br/><br/>*/<br/></pre>
      </details>
      <p>std::move or std::forward should not be applied to local objects when returning from function, if return value optimization (RVO) can be used to return a local object by value — because converting LV to XV will prevent compiler from applying RVO and moving object instead. When applied, RVO is more effective, because it avoids calling any additional copy/move constructors or operators.</p>
      <p>On the other hand, different compilers can not apply RVO in different situations, but in most situations compiler will be able to apply move assignment operator at least. If there is a risk that copy constructor will be called instead of RVO, you can use std::move or std::forward intead of returning object by value, but as far as I know the only situation when this can happen is when using ternary operator in return statement like <code>return param ? a : b</code>, which can be usually easily replaced with if statement. You can find more information about which compilers apply RVO in which situations https:// here and https:// here.</p>
      <p>
        <b>Test of RVO with latest clang on Ubuntu (year 2019):</b>
      </p>
      <details>
        <summary>Examples and tests with printing of each called constructor and operator</summary>
        <pre>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;iomanip&gt;<br/><br/>using namespace std;<br/><br/>void report(string st) {<br/>    cout &lt;&lt; st &lt;&lt; " ";<br/>}<br/><br/>struct T {<br/>    T() {<br/>        report("Dc");<br/>    }<br/>    T(int va) : a(va) {<br/>        report("Pc");<br/>    }<br/>    T(const T&amp; other) :<br/>        a(other.a)<br/>    {<br/>        report("Cc");<br/>    }<br/>    T(T&amp;&amp; other) :<br/>        a(std::exchange(other.a, 0))<br/>    {<br/>        report("Mc");<br/>    }<br/>    T&amp; operator=(int va) {<br/>        report("Va");<br/>        a = va;<br/>        return *this;<br/>    }<br/>    T&amp; operator=(const T&amp; rhs) {<br/>        report("Ca");<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = rhs.a;<br/>        return *this;<br/>    }<br/>    T&amp; operator=(T&amp;&amp; rhs) {<br/>        report("Ma");<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = std::exchange(rhs.a, 0);<br/>        return *this;<br/>    }<br/>    ~T() {<br/>        report("D");<br/>    }<br/>    int a = 1;<br/>};<br/><br/>T urvo_single() {<br/>  //const bool param = true;<br/>  return T();<br/>}<br/><br/>T urvo_two() {<br/>  const bool param = true;<br/>  if(param)<br/>    return T();<br/>  else<br/>    return T();<br/>}<br/><br/>T urvo_two_with_param(bool param) {<br/>  if(param)<br/>    return T();<br/>  else<br/>    return T();<br/>}<br/><br/>T urvo_with_exception_1(bool param) {<br/>  if(!param)<br/>    throw std::exception();<br/><br/>  return T();<br/>}<br/><br/>T urvo_with_exception_2(bool param) {<br/>  if(param)<br/>    return T();<br/>  else<br/>    throw std::exception();<br/>}<br/><br/>T urvo_with_exception_3() {<br/>  const bool param = true;<br/>  if(param)<br/>    return T();<br/>  else<br/>    throw std::exception();<br/>}<br/><br/>static T make_X() { return T(); }<br/><br/>T rrvo_single() {<br/>  //const bool param = true;<br/>  return make_X();<br/>}<br/><br/>T rrvo_two() {<br/>  const bool param = true;<br/>  if(param)<br/>    return make_X();<br/>  else<br/>    return make_X();<br/>}<br/><br/>T rrvo_two_with_param(bool param) {<br/>  if(param)<br/>    return make_X();<br/>  else<br/>    return make_X();<br/>}<br/><br/>T rrvo_with_exception_1(bool param) {<br/>  if(!param)<br/>    throw std::exception();<br/><br/>  return make_X();<br/>}<br/><br/>T rrvo_with_exception_2(bool param) {<br/>  if(param)<br/>    return make_X();<br/>  else<br/>    throw std::exception();<br/>}<br/><br/>T rrvo_with_exception_3() {<br/>  const bool param = true;<br/>  if(param)<br/>    return make_X();<br/>  else<br/>    throw std::exception();<br/>}<br/><br/>T nrvo_single_1() {<br/>  T a;<br/>  return a;<br/>}<br/><br/>T nrvo_single_2() {<br/>  {<br/>    T a;<br/>    return a;<br/>  }<br/>}<br/><br/>T nrvo_single_with_exception_1(bool param) {<br/>  T a;<br/>  if(!param)<br/>    throw std::exception();<br/><br/>  return a;<br/>}<br/><br/>T nrvo_single_with_exception_1a(bool param) {<br/>  if(!param)<br/>    throw std::exception();<br/>  T a;<br/>  return a;<br/>}<br/><br/>T nrvo_single_with_exception_2(bool param) {<br/>  T a;<br/>  if(param)<br/>    return a;<br/>  else<br/>    throw std::exception();<br/><br/>   // Silence compilation error, does not count as an additional<br/>   // return statement as it is unreachable code<br/>  return a;<br/>}<br/><br/>T nrvo_single_with_exception_2a(bool param) {<br/>  if(param) {<br/>    T a;<br/>    return a;<br/>  } else<br/>    throw std::exception();<br/>}<br/><br/>T nrvo_single_with_exception_3() {<br/>  const bool param = true;<br/>  T a;<br/>  if(param)<br/>    return a;<br/>  else<br/>    throw std::exception();<br/>}<br/><br/>T nrvo_single_with_exception_3a() {<br/>  const bool param = true;<br/>  if(param) {<br/>    T a;<br/>    return a;<br/>  } else<br/>    throw std::exception();<br/>}<br/><br/>T nrvo_two_different_tern() {<br/>  const bool param = true;<br/>  T a, b;<br/>  return param ? a : b;<br/>}<br/><br/>T nrvo_two_different_if() {<br/>  const bool param = true;<br/>  T a, b;<br/>  if(param)<br/>    return a;<br/>  else<br/>    return b;<br/>}<br/><br/>T nrvo_two_different_if_2() {<br/>  const bool param = true;<br/>  if(param) {<br/>    T a;<br/>    return a;<br/>  } else {<br/>    T b;<br/>    return b;<br/>  }<br/>}<br/><br/>T nrvo_two_different_with_param_tern(bool param) {<br/>  T a, b;<br/>  return param ? a : b;<br/>}<br/><br/>T nrvo_two_different_with_param_if(bool param) {<br/>  T a, b;<br/>  if(param)<br/>    return a;<br/>  else<br/>    return b;<br/>}<br/><br/>T nrvo_two_different_with_param_if_2(bool param) {<br/>  if(param) {<br/>    T a;<br/>    return a;<br/>  } else {<br/>    T b;<br/>    return b;<br/>  }<br/>}<br/><br/>T nrvo_two_equal_tern() {<br/>  const bool param = true;<br/>  T a;<br/>  return param ? a : a;<br/>}<br/><br/>T nrvo_two_equal_if() {<br/>  const bool param = true;<br/>  T a;<br/>  if(param)<br/>    return a;<br/>  else<br/>    return a;<br/>}<br/><br/>T nrvo_two_equal_with_param_tern(bool param) {<br/>  T a;<br/>  return param ? a : a;<br/>}<br/><br/>T nrvo_two_equal_with_param_if(bool param) {<br/>  T a;<br/>  if(param)<br/>    return a;<br/>  else<br/>    return a;<br/>}<br/><br/>T nrvo_urvo_mixed_static() {<br/>    static const bool param = true;<br/>    if (param)<br/>        return T();<br/>    T a;<br/>    return a;<br/>}<br/><br/>T nrvo_urvo_mixed_dynamic(bool param) {<br/>    if (param)<br/>        return T();<br/>    T a;<br/>    return a;<br/>}<br/><br/>void print_col(const string &amp;st, int width) {<br/>    cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st;<br/>}<br/><br/>#define CHECK_COPIES(stmt) {                         \<br/>    print_col(#stmt ": ", 20);       \<br/>    try {                                            \<br/>        stmt;                                        \<br/>    }                                                \<br/>    catch(...) {                                     \<br/>    }                                                \<br/>}                                                    \<br/><br/>int main() {<br/>    CHECK_COPIES( T a = urvo_single());<br/>    CHECK_COPIES( T a = urvo_two());<br/>    CHECK_COPIES( T a = urvo_two_with_param(true));<br/>    CHECK_COPIES( T a = urvo_with_exception_1(true));<br/>    CHECK_COPIES( T a = urvo_with_exception_2(true));<br/>    CHECK_COPIES( T a = urvo_with_exception_3());<br/><br/>    cerr &lt;&lt; " ";<br/><br/>    CHECK_COPIES( T a = rrvo_single());<br/>    CHECK_COPIES( T a = rrvo_two());<br/>    CHECK_COPIES( T a = rrvo_two_with_param(true));<br/>    CHECK_COPIES( T a = rrvo_with_exception_1(true));<br/>    CHECK_COPIES( T a = rrvo_with_exception_2(true));<br/>    CHECK_COPIES( T a = rrvo_with_exception_3());<br/><br/>    cerr &lt;&lt; " ";<br/><br/>    CHECK_COPIES( T a = nrvo_single_1());<br/>    CHECK_COPIES( T a = nrvo_single_2());<br/>    CHECK_COPIES( T a = nrvo_single_with_exception_1(true));<br/>    CHECK_COPIES( T a = nrvo_single_with_exception_1a(true));<br/>    CHECK_COPIES( T a = nrvo_single_with_exception_2(true));<br/>    CHECK_COPIES( T a = nrvo_single_with_exception_2a(true));<br/>    CHECK_COPIES( T a = nrvo_single_with_exception_3());<br/>    CHECK_COPIES( T a = nrvo_single_with_exception_3a());<br/><br/>    cerr &lt;&lt; " ";<br/><br/>    CHECK_COPIES( T a = nrvo_two_different_tern());<br/>    CHECK_COPIES( T a = nrvo_two_different_if());<br/>    CHECK_COPIES( T a = nrvo_two_different_if_2());<br/>    CHECK_COPIES( T a = nrvo_two_different_with_param_tern(true));<br/>    CHECK_COPIES( T a = nrvo_two_different_with_param_if(true));<br/>    CHECK_COPIES( T a = nrvo_two_different_with_param_if_2(true));<br/>    CHECK_COPIES( T a = nrvo_two_equal_tern());<br/>    CHECK_COPIES( T a = nrvo_two_equal_if());<br/>    CHECK_COPIES( T a = nrvo_two_equal_with_param_tern(true));<br/>    CHECK_COPIES( T a = nrvo_two_equal_with_param_if(true));<br/><br/>    cerr &lt;&lt; " ";<br/><br/>    CHECK_COPIES( T a = nrvo_urvo_mixed_static());<br/>    CHECK_COPIES( T a = nrvo_urvo_mixed_dynamic(true));<br/>}<br/><br/>/* Output:<br/><br/> T a = urvo_single(): Dc D<br/> T a = urvo_two():   Dc D<br/> T a = urvo_two_with_param(true): Dc D<br/> T a = urvo_with_exception_1(true): Dc D<br/> T a = urvo_with_exception_2(true): Dc D<br/> T a = urvo_with_exception_3(): Dc D<br/> T a = rrvo_single(): Dc D<br/> T a = rrvo_two():   Dc D<br/> T a = rrvo_two_with_param(true): Dc D<br/> T a = rrvo_with_exception_1(true): Dc D<br/> T a = rrvo_with_exception_2(true): Dc D<br/> T a = rrvo_with_exception_3(): Dc D<br/> T a = nrvo_single_1(): Dc D<br/> T a = nrvo_single_2(): Dc D<br/> T a = nrvo_single_with_exception_1(true): Dc D<br/> T a = nrvo_single_with_exception_1a(true): Dc D<br/> T a = nrvo_single_with_exception_2(true): Dc D<br/> T a = nrvo_single_with_exception_2a(true): Dc D<br/> T a = nrvo_single_with_exception_3(): Dc D<br/> T a = nrvo_single_with_exception_3a(): Dc D<br/> T a = nrvo_two_different_tern(): Dc Dc Cc D D D<br/> T a = nrvo_two_different_if(): Dc Dc Mc D D D<br/> T a = nrvo_two_different_if_2(): Dc D<br/> T a = nrvo_two_different_with_param_tern(true): Dc Dc Cc D D D<br/> T a = nrvo_two_different_with_param_if(true): Dc Dc Mc D D D<br/> T a = nrvo_two_different_with_param_if_2(true): Dc D<br/> T a = nrvo_two_equal_tern(): Dc Cc D D<br/> T a = nrvo_two_equal_if(): Dc D<br/> T a = nrvo_two_equal_with_param_tern(true): Dc Cc D D<br/> T a = nrvo_two_equal_with_param_if(true): Dc D<br/> T a = nrvo_urvo_mixed_static(): Dc D<br/> T a = nrvo_urvo_mixed_dynamic(true): Dc D<br/><br/>*/<br/></pre>
      </details>
      <p>
        <b>Links:</b>
      </p>
      <p>
        <a href="https://en.cppreference.com/w/cpp/language/copy_elision">Copy elision</a>
        <br/>
        <a href="https://www.docdroid.net/lEI1j0g/copy-elision-revisited.pdf">Copy elision revisited</a>
        <br/>
        <a href="https://godbolt.org/z/BPQEH6">Compare clang and gcc copy elision (tests with similar results are commented out)</a>
      </p>
      <h3>Passing and returning trivially copyable objects of small size</h3>
      <p>Trivially copyable struct or class:</p>
      <ul>
        <li>has no virtual members or virtual base classes</li>
        <li>has default copy and move constructors and operators</li>
      </ul>
      <p>Trivially copyable objects of small size (up to 16 bytes) can be passed in CPU registers when passed to function by value — like scalar types.</p>
      <p>Also, when passing it by value, compiler has additional guarantee that object will not change during the course of the function even if other functions are called — this is why compiler can generate more effective code in this situations. If passed by const T&amp;, there is no such guarantee, because object passed by constant reference can still be changed from other function, or multiple passed objects can use shared memory.</p>
      <p>For the same reason, std::string_view should be passed by value.</p>
      <p>
        <b>Links:</b>
      </p>
      <p>
        <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">Trivially copyable</a>
      </p>
      <h3>Returning from a function with a reference parameter</h3>
      <p>A reference to an object can be passed to a function so that function can change source object:</p>
      <pre>T&amp; change(T&amp; X) { <br/>  X.change();<br/>  return X; <br/>}</pre>
      <p>This method should not be used if temporary object can be created inside function and returned by value, because returning by value can take advantage of return value optimization (see above).</p>
      <h3>Passing multiple parameters and returning one of them from function</h3>
      <p>If all passed parameters are lvalues, you can pass and return by const T&amp;. This gives high performance, because no copy/move constructors or operators are called:</p>
      <pre>const T&amp; get(const T&amp; a, const T&amp; b) {<br/>  if ( /* something */ ) return a;<br/>  else return b;<br/>}</pre>
      <p>prvalue cannot be passed to get function, because this would result in returning a reference to a temporary object. If prvalue has to be passed,</p>
      <p>If both parameters are temporary objects (prvalues), T&amp;&amp; can be returned, which also gives high performance (no copy/move constructors or operators are called):</p>
      <pre>T&amp;&amp; get(T&amp;&amp; a, T&amp;&amp; b) {<br/>  if ( /* something */ ) return std::move(a);<br/>  else return std::move(b);<br/>}</pre>
      <p>If some of parameters are temporary objects (prvalues) and other are lvalues, it is difficult to high performance without complicating the function interface. In the following example if lvalue and prvalue are passed as A and B arguments into the function, copy constructor will be called if A is chosen and move constructor if B is chosen:</p>
      <pre>T get(const T&amp; a, T&amp;&amp; b) {<br/>  if ( /* something */ ) return a;<br/>  else return std::move(b);<br/>}</pre>
      <h3>Passing to constructor or setter</h3>
      <p>In this section I describe passing an object of type T to an object of type C during construction of type C or by calling a setter:</p>
      <pre>class C { <br/>  C(T X) : x(X) {} <br/>  void set(T X) { <br/>    x = X; <br/>  }<br/>  T x;<br/>};<br/><br/>T y;<br/>C c(y);<br/>c.set(y);</pre>
      <ul>
        <li>
          <p>For copying an lvalue to x member variable in an object of class C:</p>
          <ul>
            <li>with class C constructor: any of the following variants is good ("T move" variant is a bit less efficient due to calling an additional move constructor)</li>
            <li>with class C set(T):</li>
            <li>if T is copy-on-write (like CString in MFC/ATL) and x will not change later, any of the following variants is good ("T move" variant is a bit less efficient due to calling an additional move constructor)</li>
            <li>if T is not copy-on write or x can change later, "T move" variant becomes inefficient, because it does not allow to avoid deallocation, even if already allocated memory in existing object x is enough for new object and class can reuse allocated memory (like std::string)</li>
          </ul>
        </li>
        <li>For moving an xvalue or prvalue to x member variable in an object of class C with C's constructor or C's <code>set</code> member function any of the following variants is good except "const T&amp;" (because it requires copying). Perfect forwarding has a slight performance advantage due to avoiding calling move constructor when converting from different type, instead forwarding parameter of a different type to a parametrized constructor</li>
      </ul>
      <p>
        <b>Variants:</b>
      </p>
      <ul>
        <li>
          <p>const T&amp; — optimal if we do not need to move objects or store them in dynamically growing containers</p>
          <pre>class C { <br/>C(const T&amp; X) : x(X) {} <br/>void set(const T&amp; X) { <br/>x = X; <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>const T&amp; + T&amp;&amp; move — optimized variant if we need to support both lvalue copy and rvalue move. Can lead to code duplication, especially if constructors with different combinations of &amp; and &amp;&amp; are needed. Provides simple implementation of noexcept for effective use with containers.</p>
          <pre>class C { <br/>C(const T&amp; X) : x(X) {} <br/>C(T&amp;&amp; X) : x(std::move(X)) {} <br/>void set(const T&amp; X) { <br/>x = X; <br/>}<br/>void set(T&amp;&amp; X) { <br/>x = std::move(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>T move — looks simple, but not only intuitive (can avoid copying and change object, passed with std::move as xvalue). Less efficient than perfect forwarding and &amp;+&amp;&amp; in some situations (does not allow to avoid deallocation, even if already allocated memory in existing object x is enough for new object and class can reuse allocated memory, calls excessive moves and destructors)</p>
          <pre>class C { <br/>C(T X) : x(std::move(X)) {} <br/>void set(T X) { <br/>x = std::move(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>Perfect forwarding (PF) — most effective variant (especially when forwarding literals or other types, which can be converted to class with parametrized constructors), but it is more difficult to write, which increases risk of mistakes. Does not support virtual functions and has to be implemented in header file.</p>
          <pre>class C { <br/>template&lt;typename Z&gt;<br/>C(Z&amp;&amp; X) : x(std::forward&lt;Z&gt;(X)) {} <br/>template&lt;typename Z&gt;<br/>void set(Z&amp;&amp; X) { <br/>x = std::forward&lt;Z&gt;(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>Strict perfect forwarding (PF Strict). Has same qualities as perfect forwarding, but is more safe, because it does not allow to convert types and thus cannot receive literals (actually, it is the only variant among discussed in this section, which does not allow to convert types).</p>
          <pre>class C { <br/>template&lt;class Z, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;Z&gt;, T&gt;::value&gt;&gt;<br/>C(Z&amp;&amp; X) : x(std::forward&lt;Z&gt;(X)) {} <br/>template&lt;class Z, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;Z&gt;, T&gt;::value&gt;&gt;<br/>void set(Z&amp;&amp; X) { <br/>x = std::forward&lt;Z&gt;(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
      </ul>
      <figure>
        <img src="https://habrastorage.org/webt/4w/0q/ee/4w0qee7m2_tsrnmaaximni3awf4.png"/>
      </figure>
      <p>In the comparison tables below constructor properties are highlighted with green, setter member function properties are highlighted with yellow.</p>
      <figure>
        <img src="https://habrastorage.org/webt/8w/0n/rt/8w0nrtcbpggu66xhxnc1dm9ecrk.png"/>
      </figure>
      <p><b>Annotations:</b><br/>1 — Becomes combinatorial if constructor has multiple parameters<br/>2 — Function is technically noexcept, but copy before function call can result in exception<br/>3 — Requires noexcept(std::is_nothrow_assignable&lt;Type&amp;, T&gt;::value)<br/>4 — Does not accept conversion<br/>5 — Unconditional deallocation leads to inability to reuse allocated storage (std::string). Not a problem for copy-on-write implementations (Tstring)<br/>6 — If you do not have overloaded assignment operator for value type in object class, this will be: VcMaD</p>
      <p>
        <b>Examples and tests of variants with printing of used copy/move constructors and operators:</b>
      </p>
      <details>
        <summary>Examples and tests with printing of each called constructor and operator</summary>
        <pre>#include &lt;iostream&gt;<br/><br/>using namespace std;<br/><br/>struct TStruct {<br/>    TStruct() {<br/>        cout &lt;&lt; "Dc";<br/>    }<br/>    TStruct(int va) : a(va) {<br/>        cout &lt;&lt; "Vc";<br/>    }<br/>    TStruct(const TStruct&amp; other) :<br/>        a(other.a)<br/>    {<br/>        cout &lt;&lt; "Cc";<br/>    }<br/>    TStruct(TStruct&amp;&amp; other) :<br/>        a(std::exchange(other.a, 0))<br/>    {<br/>        cout &lt;&lt; "Mc";<br/>    }<br/>    TStruct&amp; operator=(int va) {<br/>        cout &lt;&lt; "Va";<br/>        a = va;<br/>        return *this;<br/>    }<br/>    TStruct&amp; operator=(const TStruct&amp; rhs) {<br/>        cout &lt;&lt; "Ca";<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = rhs.a;<br/>        return *this;<br/>    }<br/>    TStruct&amp; operator=(TStruct&amp;&amp; rhs) {<br/>        cout &lt;&lt; "Ma";<br/>        // check for self-assignment<br/>        if(&amp;rhs == this) return *this;<br/>        a = std::exchange(rhs.a, 0);<br/>        return *this;<br/>    }<br/>    ~TStruct() {<br/>        cout &lt;&lt; "D";<br/>    }<br/>    int a = 1;<br/>};<br/><br/>struct TRef {<br/>    TRef(TStruct&amp; tsv) : ts(tsv) {}<br/>    void set(TStruct&amp; tsv) { ts = tsv; }<br/>    TStruct ts;<br/>};<br/><br/>struct TConstRef {<br/>    TConstRef(const TStruct&amp; tsv) : ts(tsv) {}<br/>    void set(const TStruct&amp; tsv) { ts = tsv; }<br/>    TStruct ts;<br/>};<br/><br/>struct TConstRefAndRvalueRef {<br/>    TConstRefAndRvalueRef(const TStruct&amp; tsv) : ts(tsv) {<br/>        cout &lt;&lt; "Lr";<br/>    }<br/>    TConstRefAndRvalueRef(TStruct&amp;&amp; tsv) : ts(std::move(tsv)) {<br/>        cout &lt;&lt; "Rr";<br/>    }<br/>    void set(const TStruct&amp; tsv) {<br/>        cout &lt;&lt; "Sl";<br/>        ts = tsv;<br/>    }<br/>    void set(TStruct&amp;&amp; tsv) {<br/>        cout &lt;&lt; "Sr";<br/>        ts = std::move(tsv);<br/>    }<br/>    TStruct ts;<br/>};<br/><br/>struct TConstRvalueRef {<br/>    TConstRvalueRef(const TStruct&amp;&amp; tsv) : ts(std::move(tsv)) {<br/>    }<br/>    void set(const TStruct&amp;&amp; tsv) {<br/>        ts = std::move(tsv);<br/>    }<br/>    TStruct ts;<br/>};<br/><br/>struct TValueMove {<br/>    TValueMove(TStruct tsv) : ts(std::move(tsv)) {}<br/>    void set(TStruct tsv) { ts = std::move(tsv); }<br/>    TStruct ts;<br/>};<br/><br/>struct TConstValueMove {<br/>    TConstValueMove(const TStruct tsv) : ts(std::move(tsv)) {}<br/>    void set(const TStruct tsv) { ts = std::move(tsv); }<br/>    TStruct ts;<br/>};<br/><br/>struct TPerfectForward {<br/>    template&lt;class T&gt;<br/>    TPerfectForward(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {}<br/>    template&lt;class T&gt;<br/>    void set(T&amp;&amp; tsv) { ts = std::forward&lt;T&gt;(tsv); }<br/>    TStruct ts;<br/>};<br/><br/>struct TConstPerfectForward {<br/>    template&lt;class T&gt;<br/>    TConstPerfectForward(const T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {}<br/>    template&lt;class T&gt;<br/>    void set(const T&amp;&amp; tsv) { ts = std::forward&lt;T&gt;(tsv); }<br/>    TStruct ts;<br/>};<br/><br/>struct TPerfectForwardStrict {<br/>    template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt;<br/>    TPerfectForwardStrict(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {}<br/>    template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt;<br/>    void set(T&amp;&amp; tsv) { ts = std::forward&lt;T&gt;(tsv); }<br/>    TStruct ts;<br/>};<br/><br/>struct TMultiVariant {<br/>    TMultiVariant(const TStruct&amp; tsv) : ts(tsv) {<br/>        cout &lt;&lt; "Lr";<br/>    }<br/>    TMultiVariant(TStruct&amp;&amp; tsv) : ts(std::move(tsv)) {<br/>        cout &lt;&lt; "Rr";<br/>    }<br/>    void set(const TStruct&amp; tsv) {<br/>        cout &lt;&lt; "Sl";<br/>        ts = tsv;<br/>    }<br/>    void set(TStruct&amp;&amp; tsv) {<br/>        cout &lt;&lt; "Sr";<br/>        ts = std::move(tsv);<br/>    }<br/><br/>    template&lt;class T&gt;<br/>    TMultiVariant(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {<br/>        cout &lt;&lt; "Pf";<br/>    }<br/>    template&lt;class T&gt;<br/>    void set(T&amp;&amp; tsv) {<br/>        cout &lt;&lt; "Sp";<br/>        ts = std::forward&lt;T&gt;(tsv);<br/>    }<br/>    TStruct ts;<br/>};<br/><br/>struct TMultiVariantStrict {<br/>    TMultiVariantStrict(const TStruct&amp; tsv) : ts(tsv) {<br/>        cout &lt;&lt; "Lr";<br/>    }<br/>    TMultiVariantStrict(TStruct&amp;&amp; tsv) : ts(std::move(tsv)) {<br/>        cout &lt;&lt; "Rr";<br/>    }<br/>    void set(const TStruct&amp; tsv) {<br/>        cout &lt;&lt; "Sl";<br/>        ts = tsv;<br/>    }<br/>    void set(TStruct&amp;&amp; tsv) {<br/>        cout &lt;&lt; "Sr";<br/>        ts = std::move(tsv);<br/>    }<br/><br/>    template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt;<br/>    TMultiVariantStrict(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {<br/>        cout &lt;&lt; "Pf";<br/>    }<br/>    template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt;<br/>    void set(T&amp;&amp; tsv) {<br/>        cout &lt;&lt; "Sp";<br/>        ts = std::forward&lt;T&gt;(tsv);<br/>    }<br/>    TStruct ts;<br/>};<br/><br/>TStruct get_st() {<br/>    return TStruct(7);<br/>}<br/><br/>void detect_change(int&amp; param, int val) {<br/>    if (param != val) {<br/>        cout &lt;&lt; "!";<br/>        param = val;<br/>    } else {<br/>        cout &lt;&lt; "-";<br/>    }<br/>}<br/><br/>void test_passing() {<br/>    cout &lt;&lt; "TStruct st(100): ";<br/>    TStruct st(100);<br/><br/>    // Test constructing with object<br/>    cout &lt;&lt; endl &lt;&lt; "TRef (st): ";<br/>    TRef rf(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef (st):                ";<br/>    TConstRef crf(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (st):    ";<br/>    TConstRefAndRvalueRef crf_rvf(st);<br/>    detect_change(st.a, 100);<br/>    // Will not compile<br/>    // cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (st): ";<br/>    // TConstRvalueRef crvf(st);<br/>    // detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove (st):               ";<br/>    TValueMove vm(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove (st):          ";<br/>    TConstValueMove cvm(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward (st):          ";<br/>    TPerfectForward pf(st);<br/>    detect_change(st.a, 100);<br/>    // Will not compile<br/>    // cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (st): ";<br/>    // TConstPerfectForward cpf(st);<br/>    // detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (st):    ";<br/>    TPerfectForwardStrict pft(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant (st):            ";<br/>    TMultiVariant mv(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (st):      ";<br/>    TMultiVariantStrict mvt(st);<br/>    detect_change(st.a, 100);<br/><br/>    // Test constructing with moved object<br/>    // Will not compile because of std::move<br/>    // cout &lt;&lt; endl &lt;&lt; "TRef (std::move(st)): ";<br/>    // TRef rf4(std::move(st));<br/>    // detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef (std::move(st)):             ";<br/>    TConstRef crf4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (std::move(st)): ";<br/>    TConstRefAndRvalueRef crf_rvf4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (std::move(st)):       ";<br/>    TConstRvalueRef crvf4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove (std::move(st)):            ";<br/>    TValueMove vm4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove (std::move(st)):       ";<br/>    TConstValueMove cvm4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward (std::move(st)):       ";<br/>    TPerfectForward pf4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    // Will not compile<br/>    // cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (std::move(st)): ";<br/>    // TConstPerfectForward cpf4(std::move(st));<br/>    // detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (std::move(st)): ";<br/>    TPerfectForwardStrict pft4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant (std::move(st)):         ";<br/>    TMultiVariant mv4(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (std::move(st)):   ";<br/>    TMultiVariantStrict mvt4(std::move(st));<br/>    detect_change(st.a, 100);<br/><br/>    // Test constructing with temporary object<br/>    // Will not compile<br/>    // cout &lt;&lt; endl &lt;&lt; "TRef (TStruct(6)): ";<br/>    // TRef rf3(TStruct(6));<br/>     cout &lt;&lt; endl &lt;&lt; "TConstRef (TStruct(6)):               ";<br/>    TConstRef crf3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (TStruct(6)):    ";<br/>    TConstRefAndRvalueRef crf_rvf3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (TStruct(6)):          ";<br/>    TConstRvalueRef crvf3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove (TStruct(6)):               ";<br/>    TValueMove vm3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove (TStruct(6)):          ";<br/>    TConstValueMove cvm3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward (TStruct(6)):          ";<br/>    TPerfectForward pf3(TStruct(6));<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (TStruct(6)): ";<br/>    //TConstPerfectForward cpf3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (TStruct(6)):    ";<br/>    TPerfectForwardStrict pft3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant (TStruct(6)):            ";<br/>    TMultiVariant mv3(TStruct(6));<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (TStruct(6)):      ";<br/>    TMultiVariantStrict mvt3(TStruct(6));<br/><br/>    // Test constructing with RVO object<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TRef (get_st()): ";<br/>    //TRef rf5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef (get_st()):               ";<br/>    TConstRef crf5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (get_st()):   ";<br/>    TConstRefAndRvalueRef crf_rvf5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (get_st()):         ";<br/>    TConstRvalueRef crvf5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove (get_st()):              ";<br/>    TValueMove vm5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove (get_st()):         ";<br/>    TConstValueMove cvm5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward (get_st()):         ";<br/>    TPerfectForward pf5(get_st());<br/>    //cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (get_st()): ";<br/>    //TConstPerfectForward cpf5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (get_st()):   ";<br/>    TPerfectForwardStrict pft5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant (get_st()):           ";<br/>    TMultiVariant mv5(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (get_st()):     ";<br/>    TMultiVariantStrict mvt5(get_st());<br/><br/>    // Test constructing with literal<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TRef (5): ";<br/>    //TRef rf2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef (5):                     ";<br/>    TConstRef crf2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (5):         ";<br/>    TConstRefAndRvalueRef crf_rvf2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (5):               ";<br/>    TConstRvalueRef crvf2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove (5):                    ";<br/>    TValueMove vm2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove (5):               ";<br/>    TConstValueMove cvm2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward (5):               ";<br/>    TPerfectForward pf2(5);<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (5): ";<br/>    //TConstPerfectForward cpf2(5);<br/>    // Will not compile due to SFINAE test<br/>    //cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (5): ";<br/>    //TPerfectForwardStrict pft2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant (5):                 ";<br/>    TMultiVariant mv2(5);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (5):           ";<br/>    TMultiVariantStrict mvt2(5);<br/><br/>    // Test setting with object<br/>    st.a = 100;<br/>    cout &lt;&lt; endl &lt;&lt; "TRef set(st):                      ";<br/>    rf.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef set(st):                 ";<br/>    crf.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(st):     ";<br/>    crf_rvf.set(st);<br/>    detect_change(st.a, 100);<br/>    // Will not compile<br/>    // cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(st): ";<br/>    // crvf2.set(st);<br/>    // detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove set(st):                ";<br/>    vm.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(st):           ";<br/>    cvm.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(st):           ";<br/>    pf.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(st):     ";<br/>    pft.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(st):             ";<br/>    mv.set(st);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(st):       ";<br/>    mvt.set(st);<br/>    detect_change(st.a, 100);<br/><br/>    // Test setting with moved object<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TRef set(std::move(st)): ";<br/>    //rf.set(std::move(st));<br/>    //detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef set(std::move(st)):              ";<br/>    crf.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(std::move(st)):  ";<br/>    crf_rvf.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(std::move(st)):        ";<br/>    crvf2.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove set(std::move(st)):             ";<br/>    vm.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(std::move(st)):        ";<br/>    cvm.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(std::move(st)):        ";<br/>    pf.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(std::move(st)):  ";<br/>    pft.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(std::move(st)):          ";<br/>    mv.set(std::move(st));<br/>    detect_change(st.a, 100);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(std::move(st)):    ";<br/>    mvt.set(std::move(st));<br/>    detect_change(st.a, 100);<br/><br/>    // Test setting with constructed temporary object<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TRef set(TStruct(8)): ";<br/>    //rf.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef set(TStruct(8)):             ";<br/>    crf.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(TStruct(8)): ";<br/>    crf_rvf.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(TStruct(8)):       ";<br/>    crvf2.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove set(TStruct(8)):            ";<br/>    vm.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(TStruct(8)):       ";<br/>    cvm.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(TStruct(8)):       ";<br/>    pf.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(TStruct(8)): ";<br/>    pft.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(TStruct(8)):         ";<br/>    mv.set(TStruct(8));<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(TStruct(8)):   ";<br/>    mvt.set(TStruct(8));<br/><br/>    // Test setting with RVO object<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TRef set(get_st()): ";<br/>    //rf.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef set(get_st()):              ";<br/>    crf.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(get_st()):  ";<br/>    crf_rvf.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(get_st()):        ";<br/>    crvf2.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove set(get_st()):             ";<br/>    vm.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(get_st()):        ";<br/>    cvm.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(get_st()):        ";<br/>    pf.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(get_st()):  ";<br/>    pft.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(get_st()):          ";<br/>    mv.set(get_st());<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(get_st()):    ";<br/>    mvt.set(get_st());<br/><br/>    cout &lt;&lt; endl &lt;&lt; "st = 3: ";<br/>    st = 3;<br/><br/>    // Test setting with literal<br/>    // Will not compile<br/>    //cout &lt;&lt; endl &lt;&lt; "TRef set(4): ";<br/>    //rf.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRef set(4):             ";<br/>    crf.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(4): ";<br/>    crf_rvf.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(4):       ";<br/>    crvf2.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TValueMove set(4):            ";<br/>    vm.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(4):       ";<br/>    cvm.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(4):       ";<br/>    pf.set(4);<br/>    // Will not compile due to SFINAE test<br/>    //cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(st): ";<br/>    //pft.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(4):         ";<br/>    mv.set(4);<br/>    cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(4):   ";<br/>    mvt.set(4);<br/>    cout &lt;&lt; endl;<br/>}<br/><br/>int main() {<br/>    test_passing();<br/><br/>    return 0;<br/>}<br/><br/>/* Output:<br/><br/>TStruct st(100): Vc<br/>TRef (st): Cc-<br/>TConstRef (st):                Cc-<br/>TConstRefAndRvalueRef (st):    CcLr-<br/>TValueMove (st):               CcMcD-<br/>TConstValueMove (st):          CcCcD-<br/>TPerfectForward (st):          Cc-<br/>TPerfectForwardStrict (st):    Cc-<br/>TMultiVariant (st):            CcPf-<br/>TMultiVariantStrict (st):      CcPf-<br/>TConstRef (std::move(st)):             Cc-<br/>TConstRefAndRvalueRef (std::move(st)): McRr!<br/>TConstRvalueRef (std::move(st)):       Cc-<br/>TValueMove (std::move(st)):            McMcD!<br/>TConstValueMove (std::move(st)):       McCcD!<br/>TPerfectForward (std::move(st)):       Mc!<br/>TPerfectForwardStrict (std::move(st)): Mc!<br/>TMultiVariant (std::move(st)):         McRr!<br/>TMultiVariantStrict (std::move(st)):   McRr!<br/>TConstRef (TStruct(6)):               VcCcD<br/>TConstRefAndRvalueRef (TStruct(6)):    VcMcRrD<br/>TConstRvalueRef (TStruct(6)):          VcCcD<br/>TValueMove (TStruct(6)):               VcMcD<br/>TConstValueMove (TStruct(6)):          VcCcD<br/>TPerfectForward (TStruct(6)):          VcMcD<br/>TPerfectForwardStrict (TStruct(6)):    VcMcD<br/>TMultiVariant (TStruct(6)):            VcMcRrD<br/>TMultiVariantStrict (TStruct(6)):      VcMcRrD<br/>TConstRef (get_st()):               VcCcD<br/>TConstRefAndRvalueRef (get_st()):   VcMcRrD<br/>TConstRvalueRef (get_st()):         VcCcD<br/>TValueMove (get_st()):              VcMcD<br/>TConstValueMove (get_st()):         VcCcD<br/>TPerfectForward (get_st()):         VcMcD<br/>TPerfectForwardStrict (get_st()):   VcMcD<br/>TMultiVariant (get_st()):           VcMcRrD<br/>TMultiVariantStrict (get_st()):     VcMcRrD<br/>TConstRef (5):                     VcCcD<br/>TConstRefAndRvalueRef (5):         VcMcRrD<br/>TConstRvalueRef (5):               VcCcD<br/>TValueMove (5):                    VcMcD<br/>TConstValueMove (5):               VcCcD<br/>TPerfectForward (5):               Vc<br/>TMultiVariant (5):                 VcPf<br/>TMultiVariantStrict (5):           VcMcRrD<br/>TRef set(st):                      Ca-<br/>TConstRef set(st):                 Ca-<br/>TConstRefAndRvalueRef set(st):     SlCa-<br/>TValueMove set(st):                CcMaD-<br/>TConstValueMove set(st):           CcCaD-<br/>TPerfectForward set(st):           Ca-<br/>TPerfectForwardStrict set(st):     Ca-<br/>TMultiVariant set(st):             SpCa-<br/>TMultiVariantStrict set(st):       SpCa-<br/>TConstRef set(std::move(st)):              Ca-<br/>TConstRefAndRvalueRef set(std::move(st)):  SrMa!<br/>TConstRvalueRef set(std::move(st)):        Ca-<br/>TValueMove set(std::move(st)):             McMaD!<br/>TConstValueMove set(std::move(st)):        McCaD!<br/>TPerfectForward set(std::move(st)):        Ma!-<br/>TPerfectForwardStrict set(std::move(st)):  Ma!<br/>TMultiVariant set(std::move(st)):          SrMa!<br/>TMultiVariantStrict set(std::move(st)):    SrMa!<br/>TConstRef set(TStruct(8)):             VcCaD<br/>TConstRefAndRvalueRef set(TStruct(8)): VcSrMaD<br/>TConstRvalueRef set(TStruct(8)):       VcCaD<br/>TValueMove set(TStruct(8)):            VcMaD<br/>TConstValueMove set(TStruct(8)):       VcCaD<br/>TPerfectForward set(TStruct(8)):       VcMaD<br/>TPerfectForwardStrict set(TStruct(8)): VcMaD<br/>TMultiVariant set(TStruct(8)):         VcSrMaD<br/>TMultiVariantStrict set(TStruct(8)):   VcSrMaD<br/>TConstRef set(get_st()):              VcCaD<br/>TConstRefAndRvalueRef set(get_st()):  VcSrMaD<br/>TConstRvalueRef set(get_st()):        VcCaD<br/>TValueMove set(get_st()):             VcMaD<br/>TConstValueMove set(get_st()):        VcCaD<br/>TPerfectForward set(get_st()):        VcMaD<br/>TPerfectForwardStrict set(get_st()):  VcMaD<br/>TMultiVariant set(get_st()):          VcSrMaD<br/>TMultiVariantStrict set(get_st()):    VcSrMaD<br/>st = 3: Va<br/>TConstRef set(4):             VcCaD<br/>TConstRefAndRvalueRef set(4): VcSrMaD<br/>TConstRvalueRef set(4):       VcCaD<br/>TValueMove set(4):            VcMaD<br/>TConstValueMove set(4):       VcCaD<br/>TPerfectForward set(4):       Va<br/>TMultiVariant set(4):         SpVa<br/>TMultiVariantStrict set(4):   VcSrMaD<br/>DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD<br/><br/>*/<br/></pre>
      </details>
      <p>
        <b>Links:</b>
        <br/>
        <a href="https://www.youtube.com/watch?v=xnqTKD8uD64&amp;feature=youtu.be&amp;t=3209">CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"</a>
        <br/>
        <a href="https://github.com/CppCon/CppCon2014/blob/master/Presentations/Back%20to%20the%20Basics!%20Essentials%20of%20Modern%20C%2B%2B%20Style/Back%20to%20the%20Basics!%20Essentials%20of%20Modern%20C%2B%2B%20Style%20-%20Herb%20Sutter%20-%20CppCon%202014.pdf">PDF presentation</a>
        <br/>
        <a href="https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring">Meaning of acronym SSO in the context of std::string</a>
        <br/>
        <a href="https://stackoverflow.com/questions/26261007/why-is-value-taking-setter-member-functions-not-recommended-in-herb-sutters-cpp">Why is value taking setter member functions not recommended in Herb Sutter's CppCon 2014 talk (Back to Basics: Modern C++ Style)?</a>
        <br/>
        <a href="https://stackoverflow.com/questions/26147491/whats-the-correct-enable-if-constraint-on-perfect-forwarding-setter"><code>What's the correct enable_if</code> constraint on perfect forwarding setter?</a>
        <br/>
        <a href="https://mpark.github.io/programming/2014/06/07/beware-of-perfect-forwarding-constructors/">Beware of Perfect Forwarding Constructors</a>
      </p>
      <h3>Why other variants of passing to constructor or setter are less used</h3>
      <ul>
        <li>
          <p>T&amp; — cannot accept rvalue. Is the same as "const T&amp;" variant, but less safe.</p>
          <pre>class T { <br/>C(T&amp; X) : x(X) {} <br/>void set(T&amp; X) { <br/>x = X; <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>const T&amp;&amp; move — does not allow move due to prohibiting change of passed object. Not used.</p>
          <pre>class C { <br/>C(const T&amp;&amp; X) : x(std::move(X)) {} <br/>void set(const T&amp;&amp; X) { <br/>x = std::move(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>const T move — does not allow move due to prohibiting change of passed object.</p>
          <pre>class C { <br/>C(const T X) : x(std::move(X)) {} <br/>void set(const T X) { <br/>x = std::move(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
        <li>
          <p>const Perfect forwarding (PF) — will not compile</p>
          <pre>class C { <br/>template&lt;typename Z&gt;<br/>C(const Z&amp;&amp; X) : x(std::forward&lt;Z&gt;(X)) {} <br/>template&lt;typename Z&gt;<br/>void set(const Z&amp;&amp; X) { <br/>x = std::forward&lt;Z&gt;(X); <br/>}<br/>T x;<br/>};</pre>
        </li>
      </ul>
      <figure>
        <img src="https://habrastorage.org/webt/yh/yw/lu/yhywlupwrd8x9mkmessxd8tohoc.png"/>
      </figure>
      <h3>Working with smart pointers</h3>
      <ul>
        <li>Do not pass shared_ptr (or other countref alternatives) by value, if you do not need to count references (reduces performance due to atomic operations with counter) — prefer passing objects by * or &amp; as usual.</li>
        <li>Do not pass shared_ptr (or other countref alternatives) by reference or const reference, if you do not need to count references — prefer passing objects by * or &amp; as usual.</li>
        <li>If fabric has to return a polymorphic type (and thus cannot return by value), return unique_ptr, which can be converted to shared_ptr if needed (or return shared_ptr if you are sure that it will always be needed intead of unique_ptr)</li>
        <li>If a function will need to decide if it wants to copy a shared_ptr or not — you can pass a const shared_ptr&amp; to it</li>
        <li>Never dereference or call a method of non-local shared_ptr, because this puts object outside of shared_ptr control (instead, first make a local copy of shared_ptr). Example:</li>
      </ul>
      <figure>
        <img src="https://habrastorage.org/webt/oz/kw/dd/ozkwddosyw2igdar_pdmycwws0m.png"/>
      </figure>
      <hr/>
      <p>
        <b>Links:</b>
      </p>
      <p>
        <a href="https://www.youtube.com/watch?v=xnqTKD8uD64&amp;feature=youtu.be&amp;t=3209">CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"</a>
        <br/>
        <a href="https://github.com/CppCon/CppCon2014/blob/master/Presentations/Back%20to%20the%20Basics!%20Essentials%20of%20Modern%20C%2B%2B%20Style/Back%20to%20the%20Basics!%20Essentials%20of%20Modern%20C%2B%2B%20Style%20-%20Herb%20Sutter%20-%20CppCon%202014.pdf">PDF presentation</a>
        <br/>
        <a href="https://stackoverflow.com/questions/57714186/what-is-an-aliased-local-shared-ptr-in-this-example">What is an 'aliased local shared_ptr' in this example?</a>
      </p>
      <p>
        <i>Some of the used images were taken from the linked articles</i>
      </p>
      <hr/>
      <p>
        <a href="https://habr.com/en/post/479342/">Go to Part 1</a>
      </p>
      <related>
        <h4>Similar posts</h4>
        <a href="https://habr.com/en/post/458248/"/>
        <a href="https://habr.com/en/post/458202/"/>
        <a href="https://habr.com/en/post/457330/"/>
      </related>
    </article>
  </body>
</html>