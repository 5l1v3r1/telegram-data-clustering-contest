<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://www.xda-developers.com/asynctask-deprecate-android-11/"/>
    <meta property="og:site_name" content="XDA Developers"/>
    <meta property="article:published_time" content="2019-11-07T14:09:00+00:00"/>
    <meta property="og:title" content="Google is deprecating Android’s AsyncTask API in Android 11"/>
    <meta property="og:description" content="The Android API for asynchronous logic, AsyncTask, is on its way out. According to an AOSP commit, the API will be deprecated in Android 11."/>
  </head>
  <body>
    <article>
      <h1>Google is deprecating Android’s AsyncTask API in Android 11</h1>
      <address><time datetime="2019-11-07T14:09:00+00:00">07 Nov 2019, 14:09</time> by <a rel="author" href="https://www.xda-developers.com/author/zacharywander/" target="_blank">Zachary Wander</a></address>
      <p>For years now, Android’s AsyncTask has been a staple tool for beginner and expert developers alike. If you’ve ever Googled a <a href="https://www.xda-developers.com/category/tutorials/">tutorial</a> for any sort of asynchronous logic in Android, chances are that the first few results suggest using AsyncTask. It’s not like this is a random choice, either. AsyncTask was originally created to simplify the interaction between background operations and an application’s UI. For a while, it did that well. AsyncTask really does help simplify asynchronous tasks. That doesn’t mean it’s perfect, though.</p>
      <p>One thing a lot of applications need to do is grab information from a remote server. Since network requests can take a while, it’s usually important to do them asynchronously so that they don’t cause the application to freeze. Once the operation is complete, the UI can be updated. However, it’s possible that by the time the network request completes, the relevant part of the UI no longer exists, which can cause crashes or other bugs. While AsyncTask does make the overall process simpler, it doesn’t respect Android’s application lifecycle. That means there’s no built-in protection against an AsyncTask finishing after a UI change. Of course, it’s possible to manually add checks and other protections, but that adds a lot of repeat code (AKA boilerplate). Because of problems like this, AsyncTask has sort of fallen by the wayside. Google also hasn’t made many changes to how it works.</p>
      <p>Well, it seems like Google’s opinion is that AsyncTask is beyond saving. In a recent AOSP commit, AsyncTask was deprecated, citing similar reasons to the ones I just talked about. While this isn’t really a huge change for end-users, it can mean a lot for developers. If you’re maintaining an older codebase or you’re just starting out with asynchronous tasks in Android, you’re likely going to have to change a bunch of code. Luckily, though, Google hasn’t left developers in the dust.</p>
      <p>Because of AsyncTask’s limitations, alternatives have sprung up over time, such as RxJava and Kotlin’s new(ish) Coroutines library. These alternatives tend to have much more flexibility and features than AsyncTask, so they’ve gained quite a bit of popularity. In its deprecation notice for AsyncTask, Google recommends using Java’s Concurrency framework or Kotlin Coroutines.</p>
      <p>Personally, I’ve already started using Kotlin’s Coroutines, and haven’t looked back. Of course, I know many people have integrated their code tightly around AsyncTask, so this is probably at least a slight inconvenience for them. It’s a good thing there are plenty of alternatives to choose from. It may be annoying to change your code, but at least it’s possible this time.</p>
      <p>If you want more details, you can check out the commit <a href="https://android-review.googlesource.com/c/platform/frameworks/base/+/1156409">here.</a> The commit was merged earlier today, and unless there’s an Android maintenance release in the pipeline, we’ll see this change reflected in Android 11 next year.</p>
    </article>
  </body>
</html>