,src,lang,text
0,"











Windows 10 SDK Preview Build 19013 available now!
07 Nov 2019, 14:03 by Kevin Larkin
Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with Windows 10 Insider Preview (Build 19013 or greater). The Preview SDK Build 19013 contains bug fixes and under development changes to the API surface area.
The Preview SDK can be downloaded from developer section on Windows Insider.
For feedback and updates to the known issues, please see the developer forum. For new developer feature requests, head over to our Windows Platform UserVoice.
Things to note:

This build works in conjunction with previously released SDKs and Visual Studio 2017 and 2019. You can install this SDK and still also continue to submit your apps that target Windows 10 build 1903 or earlier to the Microsoft Store.
The Windows SDK will now formally only be supported by Visual Studio 2017 and greater. You can download the Visual Studio 2019 here.
This build of the Windows SDK will install on only on Windows 10 Insider Preview builds.
In order to assist with script access to the SDK, the ISO will also be able to be accessed through the following static URL: https://software-download.microsoft.com/download/sg/Windows_InsiderPreview_SDK_en-us_19013_1.iso.

Tools Updates
Message Compiler (mc.exe)

Now detects the Unicode byte order mark (BOM) in .mc files. If the If the .mc file starts with a UTF-8 BOM, it will be read as a UTF-8 file. Otherwise, if it starts with a UTF-16LE BOM, it will be read as a UTF-16LE file. If the -u parameter was specified, it will be read as a UTF-16LE file. Otherwise, it will be read using the current code page (CP_ACP).
Now avoids one-definition-rule (ODR) problems in MC-generated C/C++ ETW helpers caused by conflicting configuration macros (e.g. when two .cpp files with conflicting definitions of MCGEN_EVENTWRITETRANSFER are linked into the same binary, the MC-generated ETW helpers will now respect the definition of MCGEN_EVENTWRITETRANSFER in each .cpp file instead of arbitrarily picking one or the other).

Windows Trace Preprocessor (tracewpp.exe)

Now supports Unicode input (.ini, .tpl, and source code) files. Input files starting with a UTF-8 or UTF-16 byte order mark (BOM) will be read as Unicode. Input files that do not start with a BOM will be read using the current code page (CP_ACP). For backwards-compatibility, if the -UnicodeIgnore command-line parameter is specified, files starting with a UTF-16 BOM will be treated as empty.
Now supports Unicode output (.tmh) files. By default, output files will be encoded using the current code page (CP_ACP). Use command-line parameters -cp:UTF-8 or -cp:UTF-16 to generate Unicode output files.
Behavior change: tracewpp now converts all input text to Unicode, performs processing in Unicode, and converts output text to the specified output encoding. Earlier versions of tracewpp avoided Unicode conversions and performed text processing assuming a single-byte character set. This may lead to behavior changes in cases where the input files do not conform to the current code page. In cases where this is a problem, consider converting the input files to UTF-8 (with BOM) and/or using the -cp:UTF-8 command-line parameter to avoid encoding ambiguity.

TraceLoggingProvider.h

Now avoids one-definition-rule (ODR) problems caused by conflicting configuration macros (e.g. when two .cpp files with conflicting definitions of TLG_EVENT_WRITE_TRANSFER are linked into the same binary, the TraceLoggingProvider.h helpers will now respect the definition of TLG_EVENT_WRITE_TRANSFER in each .cpp file instead of arbitrarily picking one or the other).
In C++ code, the TraceLoggingWrite macro has been updated to enable better code sharing between similar events using variadic templates.

Signing your apps with Device Guard Signing

We are making it easier for you to sign your app. Device Guard signing is a Device Guard feature that is available in Microsoft Store for Business and Education. Signing allows enterprises to guarantee every app comes from a trusted source. Our goal is to make signing your MSIX package easier. Documentation on Device Guard Signing can be found here: https://docs.microsoft.com/en-us/windows/msix/package/signing-package-device-guard-signing

Windows SDK Flight NuGet Feed
We have stood up a NuGet feed for the flighted builds of the SDK. You can now test preliminary builds of the Windows 10 WinRT API Pack, as well as a microsoft.windows.sdk.headless.contracts NuGet package.
We use the following feed to flight our NuGet packages.
Microsoft.Windows.SDK.Contracts which can be used with to add the latest Windows Runtime APIs support to your .NET Framework 4.5+ and .NET Core 3.0+ libraries and apps.
The Windows 10 WinRT API Pack enables you to add the latest Windows Runtime APIs support to your .NET Framework 4.5+ and .NET Core 3.0+ libraries and apps.
Microsoft.Windows.SDK.Headless.Contracts provides a subset of the Windows Runtime APIs for console apps excludes the APIs associated with a graphical user interface. This NuGet is used in conjunction with
Windows ML container development. Check out the Getting Started guide for more information.
Breaking Changes
Removal of api-ms-win-net-isolation-l1-1-0.lib
In this release api-ms-win-net-isolation-l1-1-0.lib has been removed from the Windows SDK. Apps that were linking against api-ms-win-net-isolation-l1-1-0.lib can switch to OneCoreUAP.lib as a replacement.
Removal of IRPROPS.LIB
In this release irprops.lib has been removed from the Windows SDK. Apps that were linking against irprops.lib can switch to bthprops.lib as a drop-in replacement.
Removal of WUAPICommon.H and WUAPICommon.IDL
In this release we have moved ENUM tagServerSelection from WUAPICommon.H to wupai.h and removed the header. If you would like to use the ENUM tagServerSelection, you will need to include wuapi.h or wuapi.idl.
API Updates, Additions and Removals
The following APIs have been added to the platform since the release of Windows 10 SDK, version 1903, build 18362.
Additions:
  namespace Windows.AI.MachineLearning {   public sealed class LearningModelSessionOptions {     bool CloseModelOnSessionCreation { get; set; }   } } namespace Windows.ApplicationModel {   public sealed class AppInfo {     public static AppInfo Current { get; }     Package Package { get; }     public static AppInfo GetFromAppUserModelId(string appUserModelId);     public static AppInfo GetFromAppUserModelIdForUser(User user, string appUserModelId);   }   public interface IAppInfoStatics   public sealed class Package {     StorageFolder EffectiveExternalLocation { get; }     string EffectiveExternalPath { get; }     string EffectivePath { get; }     string InstalledPath { get; }     bool IsStub { get; }     StorageFolder MachineExternalLocation { get; }     string MachineExternalPath { get; }     string MutablePath { get; }     StorageFolder UserExternalLocation { get; }     string UserExternalPath { get; }     IVectorView<AppListEntry> GetAppListEntries();     RandomAccessStreamReference GetLogoAsRandomAccessStreamReference(Size size);   } } namespace Windows.ApplicationModel.AppService {   public enum AppServiceConnectionStatus {     AuthenticationError = 8,     DisabledByPolicy = 10,     NetworkNotAvailable = 9,     WebServiceUnavailable = 11,   }   public enum AppServiceResponseStatus {     AppUnavailable = 6,     AuthenticationError = 7,     DisabledByPolicy = 9,     NetworkNotAvailable = 8,     WebServiceUnavailable = 10,   }   public enum StatelessAppServiceResponseStatus {     AuthenticationError = 11,     DisabledByPolicy = 13,     NetworkNotAvailable = 12,     WebServiceUnavailable = 14,   } } namespace Windows.ApplicationModel.Background {   public sealed class BackgroundTaskBuilder {     void SetTaskEntryPointClsid(Guid TaskEntryPoint);   }   public sealed class BluetoothLEAdvertisementPublisherTrigger : IBackgroundTrigger {     bool IncludeTransmitPowerLevel { get; set; }     bool IsAnonymous { get; set; }     IReference<short> PreferredTransmitPowerLevelInDBm { get; set; }     bool UseExtendedFormat { get; set; }   }   public sealed class BluetoothLEAdvertisementWatcherTrigger : IBackgroundTrigger {     bool AllowExtendedAdvertisements { get; set; }   } } namespace Windows.ApplicationModel.ConversationalAgent {   public sealed class ActivationSignalDetectionConfiguration   public enum ActivationSignalDetectionTrainingDataFormat   public sealed class ActivationSignalDetector   public enum ActivationSignalDetectorKind   public enum ActivationSignalDetectorPowerState   public sealed class ConversationalAgentDetectorManager   public sealed class DetectionConfigurationAvailabilityChangedEventArgs   public enum DetectionConfigurationAvailabilityChangeKind   public sealed class DetectionConfigurationAvailabilityInfo   public enum DetectionConfigurationTrainingStatus } namespace Windows.ApplicationModel.DataTransfer {   public sealed class DataPackage {     event TypedEventHandler<DataPackage, object> ShareCanceled;   } } namespace Windows.Devices.Bluetooth {   public sealed class BluetoothAdapter {     bool IsExtendedAdvertisingSupported { get; }     uint MaxAdvertisementDataLength { get; }   } } namespace Windows.Devices.Bluetooth.Advertisement {   public sealed class BluetoothLEAdvertisementPublisher {     bool IncludeTransmitPowerLevel { get; set; }     bool IsAnonymous { get; set; }     IReference<short> PreferredTransmitPowerLevelInDBm { get; set; }     bool UseExtendedAdvertisement { get; set; }   }   public sealed class BluetoothLEAdvertisementPublisherStatusChangedEventArgs {     IReference<short> SelectedTransmitPowerLevelInDBm { get; }   }   public sealed class BluetoothLEAdvertisementReceivedEventArgs {     BluetoothAddressType BluetoothAddressType { get; }     bool IsAnonymous { get; }     bool IsConnectable { get; }     bool IsDirected { get; }     bool IsScannable { get; }     bool IsScanResponse { get; }     IReference<short> TransmitPowerLevelInDBm { get; }   }   public enum BluetoothLEAdvertisementType {     Extended = 5,   }   public sealed class BluetoothLEAdvertisementWatcher {     bool AllowExtendedAdvertisements { get; set; }   }   public enum BluetoothLEScanningMode {     None = 2,   } } namespace Windows.Devices.Bluetooth.Background {   public sealed class BluetoothLEAdvertisementPublisherTriggerDetails {     IReference<short> SelectedTransmitPowerLevelInDBm { get; }   } } namespace Windows.Devices.Display {   public sealed class DisplayMonitor {     bool IsDolbyVisionSupportedInHdrMode { get; }   } } namespace Windows.Devices.Input {   public sealed class PenButtonListener   public sealed class PenDockedEventArgs   public sealed class PenDockListener   public sealed class PenTailButtonClickedEventArgs   public sealed class PenTailButtonDoubleClickedEventArgs   public sealed class PenTailButtonLongPressedEventArgs   public sealed class PenUndockedEventArgs } namespace Windows.Devices.Sensors {   public sealed class Accelerometer {     AccelerometerDataThreshold ReportThreshold { get; }   }   public sealed class AccelerometerDataThreshold   public sealed class Barometer {     BarometerDataThreshold ReportThreshold { get; }   }   public sealed class BarometerDataThreshold   public sealed class Compass {     CompassDataThreshold ReportThreshold { get; }   }   public sealed class CompassDataThreshold   public sealed class Gyrometer {     GyrometerDataThreshold ReportThreshold { get; }   }   public sealed class GyrometerDataThreshold   public sealed class Inclinometer {     InclinometerDataThreshold ReportThreshold { get; }   }   public sealed class InclinometerDataThreshold   public sealed class LightSensor {     LightSensorDataThreshold ReportThreshold { get; }   }   public sealed class LightSensorDataThreshold   public sealed class Magnetometer {     MagnetometerDataThreshold ReportThreshold { get; }   }   public sealed class MagnetometerDataThreshold } namespace Windows.Foundation.Metadata {   public sealed class AttributeNameAttribute : Attribute   public sealed class FastAbiAttribute : Attribute   public sealed class NoExceptionAttribute : Attribute } namespace Windows.Globalization {   public sealed class Language {     string AbbreviatedName { get; }     public static IVector<string> GetMuiCompatibleLanguageListFromLanguageTags(IIterable<string> languageTags);   } } namespace Windows.Graphics.Capture {   public sealed class GraphicsCaptureSession : IClosable {     bool IsCursorCaptureEnabled { get; set; }   } } namespace Windows.Graphics.DirectX {   public enum DirectXPixelFormat {     SamplerFeedbackMinMipOpaque = 189,     SamplerFeedbackMipRegionUsedOpaque = 190,   } } namespace Windows.Graphics.Holographic {   public sealed class HolographicFrame {     HolographicFrameId Id { get; }   }   public struct HolographicFrameId   public sealed class HolographicFrameRenderingReport   public sealed class HolographicFrameScanoutMonitor : IClosable   public sealed class HolographicFrameScanoutReport   public sealed class HolographicSpace {     HolographicFrameScanoutMonitor CreateFrameScanoutMonitor(uint maxQueuedReports);   } } namespace Windows.Management.Deployment {   public sealed class AddPackageOptions   public enum DeploymentOptions : uint {     StageInPlace = (uint)4194304,   }   public sealed class PackageManager {     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> AddPackageByUriAsync(Uri packageUri, AddPackageOptions options);     IVector<Package> FindProvisionedPackages();     PackageStubPreference GetPackageStubPreference(string packageFamilyName);     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> RegisterPackageByUriAsync(Uri manifestUri, RegisterPackageOptions options);     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> RegisterPackagesByFullNameAsync(IIterable<string> packageFullNames, RegisterPackageOptions options);     void SetPackageStubPreference(string packageFamilyName, PackageStubPreference useStub);     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> StagePackageByUriAsync(Uri packageUri, StagePackageOptions options);   }   public enum PackageStubPreference   public enum PackageTypes : uint {     All = (uint)4294967295,   }   public sealed class RegisterPackageOptions   public enum RemovalOptions : uint {     PreserveRoamableApplicationData = (uint)128,   }   public sealed class StagePackageOptions   public enum StubPackageOption } namespace Windows.Media.Audio {   public sealed class AudioPlaybackConnection : IClosable   public sealed class AudioPlaybackConnectionOpenResult   public enum AudioPlaybackConnectionOpenResultStatus   public enum AudioPlaybackConnectionState } namespace Windows.Media.Capture {   public sealed class MediaCapture : IClosable {     MediaCaptureRelativePanelWatcher CreateRelativePanelWatcher(StreamingCaptureMode captureMode, DisplayRegion displayRegion);   }   public sealed class MediaCaptureInitializationSettings {     Uri DeviceUri { get; set; }     PasswordCredential DeviceUriPasswordCredential { get; set; }   }  public sealed class MediaCaptureRelativePanelWatcher : IClosable } namespace Windows.Media.Capture.Frames {   public sealed class MediaFrameSourceInfo {     Panel GetRelativePanel(DisplayRegion displayRegion);   } } namespace Windows.Media.Devices {   public sealed class PanelBasedOptimizationControl   public sealed class VideoDeviceController : IMediaDeviceController {     PanelBasedOptimizationControl PanelBasedOptimizationControl { get; }   } } namespace Windows.Media.MediaProperties {   public static class MediaEncodingSubtypes {     public static string Pgs { get; }     public static string Srt { get; }     public static string Ssa { get; }     public static string VobSub { get; }   }   public sealed class TimedMetadataEncodingProperties : IMediaEncodingProperties {     public static TimedMetadataEncodingProperties CreatePgs();     public static TimedMetadataEncodingProperties CreateSrt();     public static TimedMetadataEncodingProperties CreateSsa(byte[] formatUserData);     public static TimedMetadataEncodingProperties CreateVobSub(byte[] formatUserData);   } } namespace Windows.Networking.BackgroundTransfer {   public sealed class DownloadOperation : IBackgroundTransferOperation, IBackgroundTransferOperationPriority {     void RemoveRequestHeader(string headerName);     void SetRequestHeader(string headerName, string headerValue);   }   public sealed class UploadOperation : IBackgroundTransferOperation, IBackgroundTransferOperationPriority {     void RemoveRequestHeader(string headerName);     void SetRequestHeader(string headerName, string headerValue);   } } namespace Windows.Networking.Connectivity {   public enum NetworkAuthenticationType {     Owe = 12,   } } namespace Windows.Networking.NetworkOperators {   public sealed class NetworkOperatorTetheringAccessPointConfiguration {     TetheringWiFiBand Band { get; set; }     bool IsBandSupported(TetheringWiFiBand band);     IAsyncOperation<bool> IsBandSupportedAsync(TetheringWiFiBand band);   }   public sealed class NetworkOperatorTetheringManager {     public static void DisableNoConnectionsTimeout();     public static IAsyncAction DisableNoConnectionsTimeoutAsync();     public static void EnableNoConnectionsTimeout();     public static IAsyncAction EnableNoConnectionsTimeoutAsync();     public static bool IsNoConnectionsTimeoutEnabled();   }   public enum TetheringWiFiBand } namespace Windows.Networking.PushNotifications {   public static class PushNotificationChannelManager {     public static event EventHandler<PushNotificationChannelsRevokedEventArgs> ChannelsRevoked;   }   public sealed class PushNotificationChannelsRevokedEventArgs   public sealed class RawNotification {     IBuffer ContentBytes { get; }   } } namespace Windows.Security.Authentication.Web.Core {   public sealed class WebAccountMonitor {     event TypedEventHandler<WebAccountMonitor, WebAccountEventArgs> AccountPictureUpdated;   } } namespace Windows.Security.Isolation {   public sealed class IsolatedWindowsEnvironment   public enum IsolatedWindowsEnvironmentActivator   public enum IsolatedWindowsEnvironmentAllowedClipboardFormats : uint   public enum IsolatedWindowsEnvironmentAvailablePrinters : uint   public enum IsolatedWindowsEnvironmentClipboardCopyPasteDirections : uint   public struct IsolatedWindowsEnvironmentContract   public struct IsolatedWindowsEnvironmentCreateProgress   public sealed class IsolatedWindowsEnvironmentCreateResult   public enum IsolatedWindowsEnvironmentCreateStatus   public sealed class IsolatedWindowsEnvironmentFile   public static class IsolatedWindowsEnvironmentHost   public enum IsolatedWindowsEnvironmentHostError   public sealed class IsolatedWindowsEnvironmentLaunchFileResult   public enum IsolatedWindowsEnvironmentLaunchFileStatus   public sealed class IsolatedWindowsEnvironmentOptions   public static class IsolatedWindowsEnvironmentOwnerRegistration   public sealed class IsolatedWindowsEnvironmentOwnerRegistrationData   public sealed class IsolatedWindowsEnvironmentOwnerRegistrationResult   public enum IsolatedWindowsEnvironmentOwnerRegistrationStatus   public sealed class IsolatedWindowsEnvironmentProcess   public enum IsolatedWindowsEnvironmentProcessState   public enum IsolatedWindowsEnvironmentProgressState   public sealed class IsolatedWindowsEnvironmentShareFolderRequestOptions   public sealed class IsolatedWindowsEnvironmentShareFolderResult   public enum IsolatedWindowsEnvironmentShareFolderStatus   public sealed class IsolatedWindowsEnvironmentStartProcessResult   public enum IsolatedWindowsEnvironmentStartProcessStatus   public sealed class IsolatedWindowsEnvironmentTelemetryParameters   public static class IsolatedWindowsHostMessenger   public delegate void MessageReceivedCallback(Guid receiverId, IVectorView<object> message); } namespace Windows.Storage {   public static class KnownFolders {     public static IAsyncOperation<StorageFolder> GetFolderAsync(KnownFolderId folderId);     public static IAsyncOperation<KnownFoldersAccessStatus> RequestAccessAsync(KnownFolderId folderId);     public static IAsyncOperation<KnownFoldersAccessStatus> RequestAccessForUserAsync(User user, KnownFolderId folderId);   }   public enum KnownFoldersAccessStatus   public sealed class StorageFile : IInputStreamReference, IRandomAccessStreamReference, IStorageFile, IStorageFile2, IStorageFilePropertiesWithAvailability, IStorageItem, IStorageItem2, IStorageItemProperties, IStorageItemProperties2, IStorageItemPropertiesWithProvider {     public static IAsyncOperation<StorageFile> GetFileFromPathForUserAsync(User user, string path);   }   public sealed class StorageFolder : IStorageFolder, IStorageFolder2, IStorageFolderQueryOperations, IStorageItem, IStorageItem2, IStorageItemProperties, IStorageItemProperties2, IStorageItemPropertiesWithProvider {     public static IAsyncOperation<StorageFolder> GetFolderFromPathForUserAsync(User user, string path);   } } namespace Windows.Storage.Provider {   public sealed class StorageProviderFileTypeInfo   public sealed class StorageProviderSyncRootInfo {     IVector<StorageProviderFileTypeInfo> FallbackFileTypeInfo { get; }   }   public static class StorageProviderSyncRootManager {     public static bool IsSupported();   } } namespace Windows.System {   public sealed class UserChangedEventArgs {     IVectorView<UserWatcherUpdateKind> ChangedPropertyKinds { get; }   }   public enum UserWatcherUpdateKind } namespace Windows.UI.Composition.Interactions {   public sealed class InteractionTracker : CompositionObject {     int TryUpdatePosition(Vector3 value, InteractionTrackerClampingOption option, InteractionTrackerPositionUpdateOption posUpdateOption);   }   public enum InteractionTrackerPositionUpdateOption } namespace Windows.UI.Input {   public sealed class CrossSlidingEventArgs {     uint ContactCount { get; }   }   public sealed class DraggingEventArgs {     uint ContactCount { get; }   }   public sealed class GestureRecognizer {     uint HoldMaxContactCount { get; set; }     uint HoldMinContactCount { get; set; }     float HoldRadius { get; set; }     TimeSpan HoldStartDelay { get; set; }     uint TapMaxContactCount { get; set; }     uint TapMinContactCount { get; set; }     uint TranslationMaxContactCount { get; set; }     uint TranslationMinContactCount { get; set; }   }   public sealed class HoldingEventArgs {     uint ContactCount { get; }     uint CurrentContactCount { get; }   }   public sealed class ManipulationCompletedEventArgs {     uint ContactCount { get; }     uint CurrentContactCount { get; }   }   public sealed class ManipulationInertiaStartingEventArgs {     uint ContactCount { get; }   }   public sealed class ManipulationStartedEventArgs {     uint ContactCount { get; }   }   public sealed class ManipulationUpdatedEventArgs {     uint ContactCount { get; }     uint CurrentContactCount { get; }   }   public sealed class RightTappedEventArgs {     uint ContactCount { get; }   }   public sealed class SystemButtonEventController : AttachableInputObject   public sealed class SystemFunctionButtonEventArgs   public sealed class SystemFunctionLockChangedEventArgs   public sealed class SystemFunctionLockIndicatorChangedEventArgs   public sealed class TappedEventArgs {     uint ContactCount { get; }   } } namespace Windows.UI.Input.Inking {   public sealed class InkModelerAttributes {     bool UseVelocityBasedPressure { get; set; }   } } namespace Windows.UI.Text {   public enum RichEditMathMode   public sealed class RichEditTextDocument : ITextDocument {     void GetMath(out string value);     void SetMath(string value);     void SetMathMode(RichEditMathMode mode);   } } namespace Windows.UI.ViewManagement {   public sealed class UISettings {     event TypedEventHandler<UISettings, UISettingsAnimationsEnabledChangedEventArgs> AnimationsEnabledChanged;     event TypedEventHandler<UISettings, UISettingsMessageDurationChangedEventArgs> MessageDurationChanged;   }   public sealed class UISettingsAnimationsEnabledChangedEventArgs   public sealed class UISettingsMessageDurationChangedEventArgs } namespace Windows.UI.ViewManagement.Core {   public sealed class CoreInputView {     event TypedEventHandler<CoreInputView, CoreInputViewHidingEventArgs> PrimaryViewHiding;     event TypedEventHandler<CoreInputView, CoreInputViewShowingEventArgs> PrimaryViewShowing;   }   public sealed class CoreInputViewHidingEventArgs   public enum CoreInputViewKind {     Symbols = 4,   }   public sealed class CoreInputViewShowingEventArgs   public sealed class UISettingsController } 


",en,"











Windows 10 SDK Preview Build 19013 available now!
07 Nov 2019, 14:03 by Kevin Larkin
Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with Windows 10 Insider Preview (Build 19013 or greater). The Preview SDK Build 19013 contains bug fixes and under development changes to the API surface area.
The Preview SDK can be downloaded from developer section on Windows Insider.
For feedback and updates to the known issues, please see the developer forum. For new developer feature requests, head over to our Windows Platform UserVoice.
Things to note:

This build works in conjunction with previously released SDKs and Visual Studio 2017 and 2019. You can install this SDK and still also continue to submit your apps that target Windows 10 build 1903 or earlier to the Microsoft Store.
The Windows SDK will now formally only be supported by Visual Studio 2017 and greater. You can download the Visual Studio 2019 here.
This build of the Windows SDK will install on only on Windows 10 Insider Preview builds.
In order to assist with script access to the SDK, the ISO will also be able to be accessed through the following static URL: https://software-download.microsoft.com/download/sg/Windows_InsiderPreview_SDK_en-us_19013_1.iso.

Tools Updates
Message Compiler (mc.exe)

Now detects the Unicode byte order mark (BOM) in .mc files. If the If the .mc file starts with a UTF-8 BOM, it will be read as a UTF-8 file. Otherwise, if it starts with a UTF-16LE BOM, it will be read as a UTF-16LE file. If the -u parameter was specified, it will be read as a UTF-16LE file. Otherwise, it will be read using the current code page (CP_ACP).
Now avoids one-definition-rule (ODR) problems in MC-generated C/C++ ETW helpers caused by conflicting configuration macros (e.g. when two .cpp files with conflicting definitions of MCGEN_EVENTWRITETRANSFER are linked into the same binary, the MC-generated ETW helpers will now respect the definition of MCGEN_EVENTWRITETRANSFER in each .cpp file instead of arbitrarily picking one or the other).

Windows Trace Preprocessor (tracewpp.exe)

Now supports Unicode input (.ini, .tpl, and source code) files. Input files starting with a UTF-8 or UTF-16 byte order mark (BOM) will be read as Unicode. Input files that do not start with a BOM will be read using the current code page (CP_ACP). For backwards-compatibility, if the -UnicodeIgnore command-line parameter is specified, files starting with a UTF-16 BOM will be treated as empty.
Now supports Unicode output (.tmh) files. By default, output files will be encoded using the current code page (CP_ACP). Use command-line parameters -cp:UTF-8 or -cp:UTF-16 to generate Unicode output files.
Behavior change: tracewpp now converts all input text to Unicode, performs processing in Unicode, and converts output text to the specified output encoding. Earlier versions of tracewpp avoided Unicode conversions and performed text processing assuming a single-byte character set. This may lead to behavior changes in cases where the input files do not conform to the current code page. In cases where this is a problem, consider converting the input files to UTF-8 (with BOM) and/or using the -cp:UTF-8 command-line parameter to avoid encoding ambiguity.

TraceLoggingProvider.h

Now avoids one-definition-rule (ODR) problems caused by conflicting configuration macros (e.g. when two .cpp files with conflicting definitions of TLG_EVENT_WRITE_TRANSFER are linked into the same binary, the TraceLoggingProvider.h helpers will now respect the definition of TLG_EVENT_WRITE_TRANSFER in each .cpp file instead of arbitrarily picking one or the other).
In C++ code, the TraceLoggingWrite macro has been updated to enable better code sharing between similar events using variadic templates.

Signing your apps with Device Guard Signing

We are making it easier for you to sign your app. Device Guard signing is a Device Guard feature that is available in Microsoft Store for Business and Education. Signing allows enterprises to guarantee every app comes from a trusted source. Our goal is to make signing your MSIX package easier. Documentation on Device Guard Signing can be found here: https://docs.microsoft.com/en-us/windows/msix/package/signing-package-device-guard-signing

Windows SDK Flight NuGet Feed
We have stood up a NuGet feed for the flighted builds of the SDK. You can now test preliminary builds of the Windows 10 WinRT API Pack, as well as a microsoft.windows.sdk.headless.contracts NuGet package.
We use the following feed to flight our NuGet packages.
Microsoft.Windows.SDK.Contracts which can be used with to add the latest Windows Runtime APIs support to your .NET Framework 4.5+ and .NET Core 3.0+ libraries and apps.
The Windows 10 WinRT API Pack enables you to add the latest Windows Runtime APIs support to your .NET Framework 4.5+ and .NET Core 3.0+ libraries and apps.
Microsoft.Windows.SDK.Headless.Contracts provides a subset of the Windows Runtime APIs for console apps excludes the APIs associated with a graphical user interface. This NuGet is used in conjunction with
Windows ML container development. Check out the Getting Started guide for more information.
Breaking Changes
Removal of api-ms-win-net-isolation-l1-1-0.lib
In this release api-ms-win-net-isolation-l1-1-0.lib has been removed from the Windows SDK. Apps that were linking against api-ms-win-net-isolation-l1-1-0.lib can switch to OneCoreUAP.lib as a replacement.
Removal of IRPROPS.LIB
In this release irprops.lib has been removed from the Windows SDK. Apps that were linking against irprops.lib can switch to bthprops.lib as a drop-in replacement.
Removal of WUAPICommon.H and WUAPICommon.IDL
In this release we have moved ENUM tagServerSelection from WUAPICommon.H to wupai.h and removed the header. If you would like to use the ENUM tagServerSelection, you will need to include wuapi.h or wuapi.idl.
API Updates, Additions and Removals
The following APIs have been added to the platform since the release of Windows 10 SDK, version 1903, build 18362.
Additions:
  namespace Windows.AI.MachineLearning {   public sealed class LearningModelSessionOptions {     bool CloseModelOnSessionCreation { get; set; }   } } namespace Windows.ApplicationModel {   public sealed class AppInfo {     public static AppInfo Current { get; }     Package Package { get; }     public static AppInfo GetFromAppUserModelId(string appUserModelId);     public static AppInfo GetFromAppUserModelIdForUser(User user, string appUserModelId);   }   public interface IAppInfoStatics   public sealed class Package {     StorageFolder EffectiveExternalLocation { get; }     string EffectiveExternalPath { get; }     string EffectivePath { get; }     string InstalledPath { get; }     bool IsStub { get; }     StorageFolder MachineExternalLocation { get; }     string MachineExternalPath { get; }     string MutablePath { get; }     StorageFolder UserExternalLocation { get; }     string UserExternalPath { get; }     IVectorView<AppListEntry> GetAppListEntries();     RandomAccessStreamReference GetLogoAsRandomAccessStreamReference(Size size);   } } namespace Windows.ApplicationModel.AppService {   public enum AppServiceConnectionStatus {     AuthenticationError = 8,     DisabledByPolicy = 10,     NetworkNotAvailable = 9,     WebServiceUnavailable = 11,   }   public enum AppServiceResponseStatus {     AppUnavailable = 6,     AuthenticationError = 7,     DisabledByPolicy = 9,     NetworkNotAvailable = 8,     WebServiceUnavailable = 10,   }   public enum StatelessAppServiceResponseStatus {     AuthenticationError = 11,     DisabledByPolicy = 13,     NetworkNotAvailable = 12,     WebServiceUnavailable = 14,   } } namespace Windows.ApplicationModel.Background {   public sealed class BackgroundTaskBuilder {     void SetTaskEntryPointClsid(Guid TaskEntryPoint);   }   public sealed class BluetoothLEAdvertisementPublisherTrigger : IBackgroundTrigger {     bool IncludeTransmitPowerLevel { get; set; }     bool IsAnonymous { get; set; }     IReference<short> PreferredTransmitPowerLevelInDBm { get; set; }     bool UseExtendedFormat { get; set; }   }   public sealed class BluetoothLEAdvertisementWatcherTrigger : IBackgroundTrigger {     bool AllowExtendedAdvertisements { get; set; }   } } namespace Windows.ApplicationModel.ConversationalAgent {   public sealed class ActivationSignalDetectionConfiguration   public enum ActivationSignalDetectionTrainingDataFormat   public sealed class ActivationSignalDetector   public enum ActivationSignalDetectorKind   public enum ActivationSignalDetectorPowerState   public sealed class ConversationalAgentDetectorManager   public sealed class DetectionConfigurationAvailabilityChangedEventArgs   public enum DetectionConfigurationAvailabilityChangeKind   public sealed class DetectionConfigurationAvailabilityInfo   public enum DetectionConfigurationTrainingStatus } namespace Windows.ApplicationModel.DataTransfer {   public sealed class DataPackage {     event TypedEventHandler<DataPackage, object> ShareCanceled;   } } namespace Windows.Devices.Bluetooth {   public sealed class BluetoothAdapter {     bool IsExtendedAdvertisingSupported { get; }     uint MaxAdvertisementDataLength { get; }   } } namespace Windows.Devices.Bluetooth.Advertisement {   public sealed class BluetoothLEAdvertisementPublisher {     bool IncludeTransmitPowerLevel { get; set; }     bool IsAnonymous { get; set; }     IReference<short> PreferredTransmitPowerLevelInDBm { get; set; }     bool UseExtendedAdvertisement { get; set; }   }   public sealed class BluetoothLEAdvertisementPublisherStatusChangedEventArgs {     IReference<short> SelectedTransmitPowerLevelInDBm { get; }   }   public sealed class BluetoothLEAdvertisementReceivedEventArgs {     BluetoothAddressType BluetoothAddressType { get; }     bool IsAnonymous { get; }     bool IsConnectable { get; }     bool IsDirected { get; }     bool IsScannable { get; }     bool IsScanResponse { get; }     IReference<short> TransmitPowerLevelInDBm { get; }   }   public enum BluetoothLEAdvertisementType {     Extended = 5,   }   public sealed class BluetoothLEAdvertisementWatcher {     bool AllowExtendedAdvertisements { get; set; }   }   public enum BluetoothLEScanningMode {     None = 2,   } } namespace Windows.Devices.Bluetooth.Background {   public sealed class BluetoothLEAdvertisementPublisherTriggerDetails {     IReference<short> SelectedTransmitPowerLevelInDBm { get; }   } } namespace Windows.Devices.Display {   public sealed class DisplayMonitor {     bool IsDolbyVisionSupportedInHdrMode { get; }   } } namespace Windows.Devices.Input {   public sealed class PenButtonListener   public sealed class PenDockedEventArgs   public sealed class PenDockListener   public sealed class PenTailButtonClickedEventArgs   public sealed class PenTailButtonDoubleClickedEventArgs   public sealed class PenTailButtonLongPressedEventArgs   public sealed class PenUndockedEventArgs } namespace Windows.Devices.Sensors {   public sealed class Accelerometer {     AccelerometerDataThreshold ReportThreshold { get; }   }   public sealed class AccelerometerDataThreshold   public sealed class Barometer {     BarometerDataThreshold ReportThreshold { get; }   }   public sealed class BarometerDataThreshold   public sealed class Compass {     CompassDataThreshold ReportThreshold { get; }   }   public sealed class CompassDataThreshold   public sealed class Gyrometer {     GyrometerDataThreshold ReportThreshold { get; }   }   public sealed class GyrometerDataThreshold   public sealed class Inclinometer {     InclinometerDataThreshold ReportThreshold { get; }   }   public sealed class InclinometerDataThreshold   public sealed class LightSensor {     LightSensorDataThreshold ReportThreshold { get; }   }   public sealed class LightSensorDataThreshold   public sealed class Magnetometer {     MagnetometerDataThreshold ReportThreshold { get; }   }   public sealed class MagnetometerDataThreshold } namespace Windows.Foundation.Metadata {   public sealed class AttributeNameAttribute : Attribute   public sealed class FastAbiAttribute : Attribute   public sealed class NoExceptionAttribute : Attribute } namespace Windows.Globalization {   public sealed class Language {     string AbbreviatedName { get; }     public static IVector<string> GetMuiCompatibleLanguageListFromLanguageTags(IIterable<string> languageTags);   } } namespace Windows.Graphics.Capture {   public sealed class GraphicsCaptureSession : IClosable {     bool IsCursorCaptureEnabled { get; set; }   } } namespace Windows.Graphics.DirectX {   public enum DirectXPixelFormat {     SamplerFeedbackMinMipOpaque = 189,     SamplerFeedbackMipRegionUsedOpaque = 190,   } } namespace Windows.Graphics.Holographic {   public sealed class HolographicFrame {     HolographicFrameId Id { get; }   }   public struct HolographicFrameId   public sealed class HolographicFrameRenderingReport   public sealed class HolographicFrameScanoutMonitor : IClosable   public sealed class HolographicFrameScanoutReport   public sealed class HolographicSpace {     HolographicFrameScanoutMonitor CreateFrameScanoutMonitor(uint maxQueuedReports);   } } namespace Windows.Management.Deployment {   public sealed class AddPackageOptions   public enum DeploymentOptions : uint {     StageInPlace = (uint)4194304,   }   public sealed class PackageManager {     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> AddPackageByUriAsync(Uri packageUri, AddPackageOptions options);     IVector<Package> FindProvisionedPackages();     PackageStubPreference GetPackageStubPreference(string packageFamilyName);     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> RegisterPackageByUriAsync(Uri manifestUri, RegisterPackageOptions options);     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> RegisterPackagesByFullNameAsync(IIterable<string> packageFullNames, RegisterPackageOptions options);     void SetPackageStubPreference(string packageFamilyName, PackageStubPreference useStub);     IAsyncOperationWithProgress<DeploymentResult, DeploymentProgress> StagePackageByUriAsync(Uri packageUri, StagePackageOptions options);   }   public enum PackageStubPreference   public enum PackageTypes : uint {     All = (uint)4294967295,   }   public sealed class RegisterPackageOptions   public enum RemovalOptions : uint {     PreserveRoamableApplicationData = (uint)128,   }   public sealed class StagePackageOptions   public enum StubPackageOption } namespace Windows.Media.Audio {   public sealed class AudioPlaybackConnection : IClosable   public sealed class AudioPlaybackConnectionOpenResult   public enum AudioPlaybackConnectionOpenResultStatus   public enum AudioPlaybackConnectionState } namespace Windows.Media.Capture {   public sealed class MediaCapture : IClosable {     MediaCaptureRelativePanelWatcher CreateRelativePanelWatcher(StreamingCaptureMode captureMode, DisplayRegion displayRegion);   }   public sealed class MediaCaptureInitializationSettings {     Uri DeviceUri { get; set; }     PasswordCredential DeviceUriPasswordCredential { get; set; }   }  public sealed class MediaCaptureRelativePanelWatcher : IClosable } namespace Windows.Media.Capture.Frames {   public sealed class MediaFrameSourceInfo {     Panel GetRelativePanel(DisplayRegion displayRegion);   } } namespace Windows.Media.Devices {   public sealed class PanelBasedOptimizationControl   public sealed class VideoDeviceController : IMediaDeviceController {     PanelBasedOptimizationControl PanelBasedOptimizationControl { get; }   } } namespace Windows.Media.MediaProperties {   public static class MediaEncodingSubtypes {     public static string Pgs { get; }     public static string Srt { get; }     public static string Ssa { get; }     public static string VobSub { get; }   }   public sealed class TimedMetadataEncodingProperties : IMediaEncodingProperties {     public static TimedMetadataEncodingProperties CreatePgs();     public static TimedMetadataEncodingProperties CreateSrt();     public static TimedMetadataEncodingProperties CreateSsa(byte[] formatUserData);     public static TimedMetadataEncodingProperties CreateVobSub(byte[] formatUserData);   } } namespace Windows.Networking.BackgroundTransfer {   public sealed class DownloadOperation : IBackgroundTransferOperation, IBackgroundTransferOperationPriority {     void RemoveRequestHeader(string headerName);     void SetRequestHeader(string headerName, string headerValue);   }   public sealed class UploadOperation : IBackgroundTransferOperation, IBackgroundTransferOperationPriority {     void RemoveRequestHeader(string headerName);     void SetRequestHeader(string headerName, string headerValue);   } } namespace Windows.Networking.Connectivity {   public enum NetworkAuthenticationType {     Owe = 12,   } } namespace Windows.Networking.NetworkOperators {   public sealed class NetworkOperatorTetheringAccessPointConfiguration {     TetheringWiFiBand Band { get; set; }     bool IsBandSupported(TetheringWiFiBand band);     IAsyncOperation<bool> IsBandSupportedAsync(TetheringWiFiBand band);   }   public sealed class NetworkOperatorTetheringManager {     public static void DisableNoConnectionsTimeout();     public static IAsyncAction DisableNoConnectionsTimeoutAsync();     public static void EnableNoConnectionsTimeout();     public static IAsyncAction EnableNoConnectionsTimeoutAsync();     public static bool IsNoConnectionsTimeoutEnabled();   }   public enum TetheringWiFiBand } namespace Windows.Networking.PushNotifications {   public static class PushNotificationChannelManager {     public static event EventHandler<PushNotificationChannelsRevokedEventArgs> ChannelsRevoked;   }   public sealed class PushNotificationChannelsRevokedEventArgs   public sealed class RawNotification {     IBuffer ContentBytes { get; }   } } namespace Windows.Security.Authentication.Web.Core {   public sealed class WebAccountMonitor {     event TypedEventHandler<WebAccountMonitor, WebAccountEventArgs> AccountPictureUpdated;   } } namespace Windows.Security.Isolation {   public sealed class IsolatedWindowsEnvironment   public enum IsolatedWindowsEnvironmentActivator   public enum IsolatedWindowsEnvironmentAllowedClipboardFormats : uint   public enum IsolatedWindowsEnvironmentAvailablePrinters : uint   public enum IsolatedWindowsEnvironmentClipboardCopyPasteDirections : uint   public struct IsolatedWindowsEnvironmentContract   public struct IsolatedWindowsEnvironmentCreateProgress   public sealed class IsolatedWindowsEnvironmentCreateResult   public enum IsolatedWindowsEnvironmentCreateStatus   public sealed class IsolatedWindowsEnvironmentFile   public static class IsolatedWindowsEnvironmentHost   public enum IsolatedWindowsEnvironmentHostError   public sealed class IsolatedWindowsEnvironmentLaunchFileResult   public enum IsolatedWindowsEnvironmentLaunchFileStatus   public sealed class IsolatedWindowsEnvironmentOptions   public static class IsolatedWindowsEnvironmentOwnerRegistration   public sealed class IsolatedWindowsEnvironmentOwnerRegistrationData   public sealed class IsolatedWindowsEnvironmentOwnerRegistrationResult   public enum IsolatedWindowsEnvironmentOwnerRegistrationStatus   public sealed class IsolatedWindowsEnvironmentProcess   public enum IsolatedWindowsEnvironmentProcessState   public enum IsolatedWindowsEnvironmentProgressState   public sealed class IsolatedWindowsEnvironmentShareFolderRequestOptions   public sealed class IsolatedWindowsEnvironmentShareFolderResult   public enum IsolatedWindowsEnvironmentShareFolderStatus   public sealed class IsolatedWindowsEnvironmentStartProcessResult   public enum IsolatedWindowsEnvironmentStartProcessStatus   public sealed class IsolatedWindowsEnvironmentTelemetryParameters   public static class IsolatedWindowsHostMessenger   public delegate void MessageReceivedCallback(Guid receiverId, IVectorView<object> message); } namespace Windows.Storage {   public static class KnownFolders {     public static IAsyncOperation<StorageFolder> GetFolderAsync(KnownFolderId folderId);     public static IAsyncOperation<KnownFoldersAccessStatus> RequestAccessAsync(KnownFolderId folderId);     public static IAsyncOperation<KnownFoldersAccessStatus> RequestAccessForUserAsync(User user, KnownFolderId folderId);   }   public enum KnownFoldersAccessStatus   public sealed class StorageFile : IInputStreamReference, IRandomAccessStreamReference, IStorageFile, IStorageFile2, IStorageFilePropertiesWithAvailability, IStorageItem, IStorageItem2, IStorageItemProperties, IStorageItemProperties2, IStorageItemPropertiesWithProvider {     public static IAsyncOperation<StorageFile> GetFileFromPathForUserAsync(User user, string path);   }   public sealed class StorageFolder : IStorageFolder, IStorageFolder2, IStorageFolderQueryOperations, IStorageItem, IStorageItem2, IStorageItemProperties, IStorageItemProperties2, IStorageItemPropertiesWithProvider {     public static IAsyncOperation<StorageFolder> GetFolderFromPathForUserAsync(User user, string path);   } } namespace Windows.Storage.Provider {   public sealed class StorageProviderFileTypeInfo   public sealed class StorageProviderSyncRootInfo {     IVector<StorageProviderFileTypeInfo> FallbackFileTypeInfo { get; }   }   public static class StorageProviderSyncRootManager {     public static bool IsSupported();   } } namespace Windows.System {   public sealed class UserChangedEventArgs {     IVectorView<UserWatcherUpdateKind> ChangedPropertyKinds { get; }   }   public enum UserWatcherUpdateKind } namespace Windows.UI.Composition.Interactions {   public sealed class InteractionTracker : CompositionObject {     int TryUpdatePosition(Vector3 value, InteractionTrackerClampingOption option, InteractionTrackerPositionUpdateOption posUpdateOption);   }   public enum InteractionTrackerPositionUpdateOption } namespace Windows.UI.Input {   public sealed class CrossSlidingEventArgs {     uint ContactCount { get; }   }   public sealed class DraggingEventArgs {     uint ContactCount { get; }   }   public sealed class GestureRecognizer {     uint HoldMaxContactCount { get; set; }     uint HoldMinContactCount { get; set; }     float HoldRadius { get; set; }     TimeSpan HoldStartDelay { get; set; }     uint TapMaxContactCount { get; set; }     uint TapMinContactCount { get; set; }     uint TranslationMaxContactCount { get; set; }     uint TranslationMinContactCount { get; set; }   }   public sealed class HoldingEventArgs {     uint ContactCount { get; }     uint CurrentContactCount { get; }   }   public sealed class ManipulationCompletedEventArgs {     uint ContactCount { get; }     uint CurrentContactCount { get; }   }   public sealed class ManipulationInertiaStartingEventArgs {     uint ContactCount { get; }   }   public sealed class ManipulationStartedEventArgs {     uint ContactCount { get; }   }   public sealed class ManipulationUpdatedEventArgs {     uint ContactCount { get; }     uint CurrentContactCount { get; }   }   public sealed class RightTappedEventArgs {     uint ContactCount { get; }   }   public sealed class SystemButtonEventController : AttachableInputObject   public sealed class SystemFunctionButtonEventArgs   public sealed class SystemFunctionLockChangedEventArgs   public sealed class SystemFunctionLockIndicatorChangedEventArgs   public sealed class TappedEventArgs {     uint ContactCount { get; }   } } namespace Windows.UI.Input.Inking {   public sealed class InkModelerAttributes {     bool UseVelocityBasedPressure { get; set; }   } } namespace Windows.UI.Text {   public enum RichEditMathMode   public sealed class RichEditTextDocument : ITextDocument {     void GetMath(out string value);     void SetMath(string value);     void SetMathMode(RichEditMathMode mode);   } } namespace Windows.UI.ViewManagement {   public sealed class UISettings {     event TypedEventHandler<UISettings, UISettingsAnimationsEnabledChangedEventArgs> AnimationsEnabledChanged;     event TypedEventHandler<UISettings, UISettingsMessageDurationChangedEventArgs> MessageDurationChanged;   }   public sealed class UISettingsAnimationsEnabledChangedEventArgs   public sealed class UISettingsMessageDurationChangedEventArgs } namespace Windows.UI.ViewManagement.Core {   public sealed class CoreInputView {     event TypedEventHandler<CoreInputView, CoreInputViewHidingEventArgs> PrimaryViewHiding;     event TypedEventHandler<CoreInputView, CoreInputViewShowingEventArgs> PrimaryViewShowing;   }   public sealed class CoreInputViewHidingEventArgs   public enum CoreInputViewKind {     Symbols = 4,   }   public sealed class CoreInputViewShowingEventArgs   public sealed class UISettingsController } 


"
