<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://habr.com/ru/post/466551/"/>
    <meta property="og:site_name" content="Хабр"/>
    <meta property="article:published_time" content="2019-11-22T10:08:51+00:00"/>
    <meta property="og:title" content="Puppeteer c ES6 в ноде и браузере, или почему Zora это лучший тест-фреймворк в своей нише"/>
    <meta property="og:description" content="Все хорошо, пока вам нужно прогнать JS исходники через бабели-шмабели для создания бандла, но начинается сущий ад, когда вы захотите написать тесты для вашего са..."/>
  </head>
  <body>
    <article>
      <h1>Puppeteer c ES6 в ноде и браузере, или почему Zora это лучший тест-фреймворк в своей нише</h1>
      <address><time datetime="2019-11-22T10:08:51+00:00">22 Nov 2019, 10:08</time> by <a rel="author" href="https://habr.com/ru/users/munrocket/" target="_blank">munrocket</a></address>
      <p>Все хорошо, пока вам нужно прогнать JS исходники через бабели-шмабели для создания бандла, но начинается сущий ад, когда вы захотите написать тесты для вашего сайта или бибилиотеки. Проблема в том, что все тест-фреймворки используют специфичные функции из ноды или/и написаны в ES5. Таким образом запуск E2E тестов становятся не тривиальной задачей и предлагает танцы с бубном транспиляций и sourcemap-ов для покрытия кода. Вы же не хотите что бы ошибки указывали не туда?</p>
      <figure>
        <img src="https://habrastorage.org/webt/-b/ap/4s/-bap4sw3txogxdeww4tsomrzffw.png"/>
      </figure>
      <p>В этой статье я опишу свой опыт использования Puppeteer для небольшой задачи,<br/>и как я запустил ES6 модули в ноде и браузере, имея всего один исходник для тестов без сборщиков.</p>
      <p>Зачем вообще Puppeteer, спросите вы, почему не WebDriver? Просто я заметил, как мучаются создатели популярных опенсорс WebGL библиотек, например, у них есть в наличии 300 страниц с примерами, каждый из которых может сломаться при любом коммите. Они проверяют их после каждого изменения, и если что-то забыли открыть — извините <code>¯\_(ツ)_/¯</code>, сломалось. Коли никто до сих пор не решил данную задачу, то я решил попробовать это, пока в своей небольшой либе. Первая мысль которая была, это запустить headless-gl, но он морально устарел. Node-gles уже поддерживает WebGL2, но не редкое расширение, которое я использовал. WebDriver? Даже не пробовал. Не уверен что это возможно, python/C#/Java были мне не нужны, а требовался JS/TS с последней нодой и с новейшим браузерным API, так залетающие фичи могут быть по последней спеке.</p>
      <p>Почему ES6 модули? Поддержка WebGL и ES6 в браузерах примерно на одном уровне. А с модулями бандл или нет, пусть решает пользователь, просто можно собрать обе версии. Но оказывается для юнит тестирования, очень удобно использовать версию именно с модулями, так как sourcemap-ы добываются очень просто, а тесты после этого без каких либо лишних телодвижений можно запускать как в ноде, так и в браузере. Запуская их в puppeteer, E2E с покрытием кода дается почти бесплатно. Typescript c таргетом в ES6 наверно был нужен, но на маленьком проекте покрытым тестами, пойдет и обычный js.</p>
      <p>Итак, хватит введений, я поставил в проект <code>puppeteer</code> и <code>puppeteer-to-istanbul</code> и написал такую обертку</p>
      <pre>// puppeteer.js<br/><br/>import puppeteer from 'puppeteer';<br/>import pup2ist from 'puppeteer-to-istanbul';<br/><br/>(async () =&gt; {<br/>  const browser = await puppeteer.launch({<br/>    headless: process.env.HEADLESS, // headless customization<br/>    slowMo: 250                     // good fature for new configs<br/>  });<br/>  const page = (await browser.pages())[0];<br/><br/>  // enable coverage<br/>  await page.coverage.startJSCoverage();<br/>  await page.coverage.startCSSCoverage();<br/><br/>  // some additional code with console events here...<br/><br/>  // navigate to unit test page<br/>  await page.goto('http://127.0.0.1:1234/');<br/><br/>  // disable coverage<br/>  const jsCoverage = await page.coverage.stopJSCoverage();<br/>  const cssCoverage = await page.coverage.stopCSSCoverage();<br/>  pup2ist.write([...jsCoverage, ...cssCoverage])<br/><br/>  await new Promise(resolve =&gt; setTimeout(resolve, 6000));<br/>  await browser.close();<br/>})();</pre>
      <p>Которую можно запускать командой <code>node --experimental-modules --no-warnings ./test/puppeteer.js</code> с 11+ нодой, или даже без флагов на node 13.2+. Конечно можно использовать <code>require</code>, то се… Но зачем? Это же вообще бэкенд, тут поддержка у клиентов даже не нужна! Следующий код из <code>package.json</code> позволяет нам кастомизировать HEADLESS загрузку в консоли и в CI облаке, если требуются различные настройки для них. В travs/circle-ci наверно будет стоять linux и можно устанавливать там переменные среды в таком формате. <code>concurrently</code> открывает параллельно два процесса в одной консоли.</p>
      <pre>// package.json<br/>{<br/>  //bla-bla...<br/><br/>  "type": "module",      // this line indicates that we are using es6 modules<br/>  "scripts": {<br/>    "test": "node --experimental-modules --no-warnings ./test/puppeteer.js",<br/>    "server": "http-server -c-1 -p 1234",<br/>    "not-bad-cmd--dude": "concurrently -k -s first \"npm:test\" \"npm:server\"",<br/>    "ci": "HEADLESS=true concurrently -k -s first \"npm:test\" \"npm:server\"",<br/>  }<br/>}</pre>
      <p>На локальной машине после ввода команды <code>npm run server</code> будет запускаться http сервер, а на <code>npm run test</code> puppeteer в отдельном окне окне хрома. Вот в принципе и все что нужно знать про puppeteer. Дальнейшие примеры по скриншотам, эмуляциям девайсов, админкам и т.д., расположены <a href="https://github.com/checkly/puppeteer-examples">тут</a>. Кстати, вместе с пакетом <code>puppeteer</code> вам установился отдельный хром в <code>node_modules</code>, если он вам не нужен, замените его на <code>puppeteer-core</code> или <code>puppeteer-firefox</code>. Следует заметить что в примере выше мы бесплатно получили JS/CSS покрытие кода которое пишется в папку .nyc_output, пока не будем заострять на этом внимание, на данном этапе нам от этого не холодно не жарко, но если что — оно там есть, и статистика покрытия тестов почти готова к просмотру.</p>
      <figure>
        <img src="https://habrastorage.org/webt/7p/1a/ub/7p1aubzvuejnelkrcqktlhwvwci.png"/>
      </figure>
      <p>Теперь перейдем к самим тестам, пытаясь выбрать в чем я буду запускать E2E в моей небольшой либе, я наткнулся на следующие графики, где сравнивали производительности фреймворков для тестирования. Наверно, время выполнения не так важно, но когда какой нибудь Jest запускает их в 10 раз медленнее, возникает вопрос "что это, и зачем это нужно". Основной критерий выбора это был запуск es6 со строчкой <code>&lt;script type="module" src="./test.js"&gt;&lt;/script&gt;</code> в html странице. Так как на момент написания моего кода, нода еще не поддерживала в полной мере ES6 (вчера вышла 12.3 в которой сняли флаги). Я решил, что если взять фреймворк с исходниками на TS или же ES6+, то оно точно должно запускаться. Вообще, наверное можно было взять какой нибудь mocha, объявить его выше на странице и обращаться к объявленному классу, но что будет если выпадет ошибка? В общем, можете назвать свой любимый тест раннер тут. Я лишь скажу что Zora поддерживает TAP формат, и это значит для нее подходит целый зоопарк TAP пожирателей. В ней есть большинство ассертов, она поддерживает async, она одна из самых быстрых, написана на чистом ES6 без зависимостей от самой ноды. Мне показалась она настоящим бриллиантом для небольших проектов.</p>
      <p>В итоге у меня получились какие-то такие тесты, которые работают как в браузере так и в ноде. В <a href="https://github.com/lorenzofox3/zora">документации</a> по Zora есть исчерпывающая инструкция по ассертам и группировкам команд.</p>
      <pre>// test.js<br/>import MyLibrary from '../dist/my-library.module.js';<br/>import { test } from 'https://cdn.jsdelivr.net/npm/zora@3.0.3/dist/bundle/module.js';<br/><br/>test('CPU', async (t) =&gt; {<br/>  // some stuff here<br/>  t.ok(tfps != null, 'fps = ' + (tfps != null ? tfps.toFixed(1) : 'null'));<br/>  t.ok(tcpu != null, 'cpu = ' + (tcpu != null ? tcpu.toFixed(1) : 'null'));<br/>});<br/><br/>test('Memory', async (t) =&gt; {<br/>  // some stuff here<br/>  t.ok(tmem != null, 'mem = ' + (tmem != null ? tmem.toFixed(1) : 'null'));<br/>});<br/><br/>// etc...</pre>
      <p>Для того что бы показать консоль без сборок, мне пришлось сделать подобный снифер. Голая консоль не очень презентабельна, можно было бы подключить TAP вывод куда-нибудь для наведения марафета. Но самое забавное — это то, что результаты тестов на вашем клиенте можно посмотреть в <a href="https://munrocket.github.io/gl-bench/test/unit-test.html">онлайне</a>. Так же, совершенно этот же код запускается в CI по любому коммиту.</p>
      <pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;!-- some declarations in head --&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;!-- some declarations in body --&gt;<br/><br/>  &lt;script&gt;<br/>    const addSniffer = (spyTarget) =&gt; function() {<br/>      spyTarget.apply(window.console, arguments);<br/>      sniffer([...arguments]);<br/>    }<br/>    window.console.log = addSniffer(window.console.log);<br/>    window.console.error = addSniffer(window.console.error);<br/><br/>    let screen = document.getElementById('screen');<br/>    function sniffer(string) {<br/>      let screen = document.getElementById("screen");<br/>      string.forEach(line =&gt; {<br/>        let div = document.createElement("div");<br/>        let text = document.createTextNode(line);<br/>        div.appendChild(text)<br/>        screen.appendChild(div);<br/>      });<br/>    }<br/>  &lt;/script&gt;<br/><br/>  &lt;script type="module" src="./test.js"&gt;&lt;/script&gt;<br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
      <p>Но это еще не все, имея готовые тесты, можно подключить таких ботов как renovate/greenkeeper/dependabot, которые бы обновляли зависимости в вашей библиотеке, и делали автокоммиты, предварительно проверяя корректность обновлений. А travis/github-ci/circle-ci бы выкладывали бы новую версию npm пакетов.</p>
      <p>Например такой конфиг от renovate, делает автокоммиты по воскресеньям, и поднимает версию</p>
      <pre>{<br/>  "automerge": true,<br/>  "automergeType": "branch",<br/>  "bumpVersion": "patch",<br/>  "schedule": ["on sunday"],<br/>  "ignorePaths": [".circleci"]<br/>}</pre>
      <p>А travis, когда вы сами подняли версию или же какой то бот, может автоматом выкладывать пакет в npm. Для этого нужно создать аккаунт на <code>travis-ci.org</code>, включить f2a как описано в <a href="https://tailordev.fr/blog/2018/03/15/automated-npm-releases-with-travis-ci/">данной статье</a>, ввести два секретных ключа <code>$NPM_EMAIL</code> и <code>$NPM_TOKEN</code>, и создать подобный конфиг.</p>
      <pre>language: node_js<br/>node_js: '12'<br/><br/>script:<br/>  - npm run ci<br/><br/>deploy:<br/>  provider: npm<br/>  email: $NPM_EMAIL<br/>  api_key: $NPM_TOKEN<br/>  on:<br/>    branch: master</pre>
      <p>Итого, как-то так можно, но сложно избавится от оповещений от гитхаба о том, что в какой-то зависимости появилась уязвимость :D</p>
      <related>
        <h4>Похожие публикации</h4>
        <a href="https://habr.com/ru/post/348612/"/>
        <a href="https://habr.com/ru/post/341348/"/>
        <a href="https://habr.com/ru/post/268795/"/>
      </related>
    </article>
  </body>
</html>