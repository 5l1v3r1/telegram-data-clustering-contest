<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://dou.ua/lenta/articles/scala-shapeless/"/>
    <meta property="og:site_name" content="ДОУ"/>
    <meta property="article:published_time" content="2019-11-23T10:00:00+00:00"/>
    <meta property="og:title" content="Вывод реализаций интерфейсов в Scala c библиотекой Shapeless"/>
    <meta property="og:description" content="В статье рассмотрим пример превращения данных алгебраического типа в представлении через sealed trait family в обобщенное представление. Покажем техники работы с этим обобщенным представлением на примере структурного сравнения, операции diff."/>
  </head>
  <body>
    <article>
      <h1>Вывод реализаций интерфейсов в Scala c библиотекой Shapeless</h1>
      <address><time datetime="2019-11-23T10:00:00+00:00">23 Nov 2019, 10:00</time> by <a rel="author" href="https://dou.ua/users/iva-kam/" target="_blank">Иван Камышан</a></address>
      <p>В статье рассмотрим пример превращения данных алгебраического типа в представлении через sealed trait family в обобщенное представление. Покажем техники работы с этим обобщенным представлением на примере структурного сравнения, операции <code>diff</code>. В конце статьи — работающий пример в репозитории на GitHub.</p>
      <h3>Мотивация</h3>
      <p>Наверняка многим программистам, которые пишут на статически типизированных языках, часто приходится иметь дело с введением операции сравнения (метод <code>equals</code>, операция <code>==</code> и т. д.). В большинстве языков эта операция вводится непосредственным написанием кода операции. Чаще всего это может выглядеть как-то так:</p>
      <pre>class Foo { <br/> private var bar: Int <br/> private var baz: Double <br/> private var qux: String <br/><br/> override def equals(that: Foo): Boolean  = { <br/>   this.bar == that.bar &amp;&amp; this.baz == that.baz &amp;&amp; this.qux == that.qux <br/> } <br/>}</pre>
      <p>Однако написание такого кода бывает достаточно громоздким и трудоемким, в особенности для большого количества классов.</p>
      <p>Еще одна проблема, с которой, возможно, многие читатели могли столкнуться при тестировании — это поиск причины, по которой два объекта не равны, и конкретных полей, которые отличаются. Написание кода, который бы по заданному объекту напрямую отыскивал и перечислял все отличающиеся поля, снова привело бы к написанию большого количества бойлерплейта и сложной инфраструктуры.</p>
      <p>Хотелось бы иметь магический метод <code>Compare(a,b)</code>, который бы работал для большого количества типов и в то же время был легко настраиваемым.</p>
      <p>Решить задачу по написанию этого метода так, чтобы бойлерплейта пришлось писать по минимуму, можно несколькими способами. Во-первых, можно применить рефлексию для выведения механизма сравнения типов данных, но рефлексия славится монструозностью кода. И, что самое главное, рефлексия работает во время исполнения кода, что чревато ошибками времени исполнения, которые, в принципе, можно отловить на этапе компиляции. Во-вторых, можно применить кодогенерацию (шаблоны/макросы), которая бы генерировала весь бойлерплейт, однако, так или иначе, нужно будет усложнять процесс сборки и компиляции и выносить генерирование всего бойлерплейта в отдельный этап. Обычно это осложнено слаборазвитым тулингом для рефлексии времени компиляции и усложняющейся сборкой.</p>
      <p>Однако в языке Scala есть решение, которое упрощает подобную кодогенерацию, убирая любую необходимость писать код «сбоку» приложения и как-либо модифицировать сборку и компиляцию проекта. Это решение, библиотека Shapeless, является набором макросов и достаточно хорошего API к ним, которая предоставляет разные абстракции для обобщенного программирования, такие как гетерогенный список, копроизведение, функции с зависимым от типа параметра типом возвращаемого значения и т. д. В частности, эта библиотека предоставляет механизм превращения ограниченных иерархий кейс-классов в гетерогенные списки, который и будет использоваться для решения задачи.</p>
      <p>Будем решать эту задачу для семейств запечатанных трейтов, пользуясь их хорошими свойствами.</p>
      <h3>Семейства запечатанных трейтов в Scala (sealed trait family)</h3>
      <p>В Scala конструкции, состоящие из некоторого количества «интерфейсов», доступных к расширению в рамках одного файла (sealed trait), и классов, содержащих только неизменяемые данные (<code>case class</code> и <code>case object</code>), их наследующих, называются ограниченной иерархией кейс-классов. Эта конструкция довольно неплохо справляется с моделированием замкнутых ADT (Algebraic Data Type).</p>
      <p>Пара примеров:</p>
      <pre>sealed trait Color <br/><br/>sealed trait PredefColor extends Color <br/>case object Red extends PredefColor <br/>case object Green extends PredefColor <br/>case object Blue extends PredefColor <br/><br/>case class RGB(r: Byte, g: Byte, b: Byte) extends Color <br/>case class RGBA(r: Byte, g: Byte, b: Byte, a: Byte) extends Color <br/>case class HSV(h: Byte, s: Byte, v: Byte) extends Color <br/></pre>
      <p>Или</p>
      <pre>case class Id(text: Id) <br/>sealed trait WithId{ def id: Id } <br/>sealed trait UserData{ <br/> def login: String <br/> def email: String <br/>} <br/>sealed trait AdminPriviledges {def privileges: Set[String]} <br/>sealed trait User <br/>case object Unregistered extends User <br/>case class New(id: Id) extends WithId <br/>case class LoggedUsser(id: Id, login: String, email: String) extends WithId with UserData <br/>case class Admin(id: Id, login: String, email: String, priviledges: Set[String]) extends WithId  <br/>  with UserData with AdminPriviledges <br/></pre>
      <p>В свою очередь, программы на Scala очень часто пишутся с использованием принципа отделения данных от операций над ними, и ADT достаточно хорошо подходит для описания данных в таких программах.</p>
      <p>ADT располагает рядом хороших свойств, например, данные иммутабельные и не содержат никаких сложных процедур построения внутреннего состояния. Или же ADT замкнуто (то есть то, что унаследовано от одного sealed trait, находится внутри одного файла), что позволяет делать полный перебор по структуре ADT, будучи уверенным, что все варианты будут перебраны. Кроме этого, все поля внутри конечных кейс-классов — открытые, что вместе с предыдущим фактом делает ADT весьма удобным типом данных с простой и понятной структурой.</p>
      <h3>Имплиситы и тайпклассы в Scala</h3>
      <p><a href="https://en.wikipedia.org/wiki/Type_class">Тайпкласс</a>, как гласит Википедия, это конструкт для ad-hoc полиморфизма. Иными словами, способ для выбора конкретной реализации полиморфной функции по типу аргумента.</p>
      <p>Реализация тайпкласса в Scala использует неявные значения и неявные аргументы функций, которые в этом языке являются очень мощным средством. Вообще-то на Хабрахабре по этому поводу есть довольно неплохая <a href="https://habr.com/ru/post/329600/">статья</a>, но краткое их описание, необходимое для решения задачи, будет приведено ниже.</p>
      <p>Во-первых, существуют неявные значения, они помечаются ключевым словом <code>implicit</code>, например:</p>
      <pre>implicit val foo: Int =5 <br/>implicit val  <br/></pre>
      <p>Существуют неявные аргументы функции, которые помечаются отдельным блоком параметров:</p>
      <pre>def functionWithImplicitParameters( regularParam: String <br/>                                 )(implicit <br/>                                   implicitParam1: String, <br/>                                   implicitParam2: Int <br/>): (String, String, Int)= (regularParam, implicitParam1, implicitParam2)</pre>
      <p>На места неявных параметров в месте вызова функции компилятор во время компиляции подставляет первые наиболее подходящие параметры. Если же параметров одного типа на место одного неявного параметра претендует больше одного, это вызывает ошибку компиляции <i>diverging implicit expansion</i>.</p>
      <p>Несколько замечаний об этом виде неявных сущностей: неявные параметры могут быть функциями, которые имеют неявные параметры, и поиск неявных параметров рекурсивен. То есть следующий код будет валиден:</p>
      <pre>type T1 <br/>type T2 <br/>type T3 <br/><br/>implicit def foo(implicit t1: T1): T2 <br/>implicit def bar(implicit t2: T2): T3 <br/><br/>implicit val t1: T1 = ??? <br/><br/>val res = bar <br/></pre>
      <p>В данном случае вызов</p>
      <pre>bar </pre>
      <p>развернется до</p>
      <pre>bar(foo(t1))</pre>
      <p>Для типов неявных параметров нет строгих ограничений: типы неявных параметров и значений могут вполне быть как функциями, так и высшими кайндами.</p>
      <p>Для неявных параметров с местом для еще одного параметра существует специальный синтаксический сахар, который позволяет превращать</p>
      <pre>type Bar[T] <br/>def foo[F](implicit b: Bar[F]): Unit</pre>
      <p>в</p>
      <pre>def foo[F : Bar]:Unit</pre>
      <p>При условии, что тип <i>Bar</i> имеет место для одного параметра.</p>
      <p>Есть еще один тип имплиситов — неявные классы. Они могут иметь только один параметр, и в основном используются для добавления функциональности существующим объектам, таким образом чтобы не изменять код самих существующих объектов.</p>
      <p>Например:</p>
      <pre>sealed trait Color <br/><br/>sealed trait PredefColor extends Color <br/>case object Red extends PredefColor <br/>case object Green extends PredefColor <br/>case object Blue extends PredefColor <br/><br/>case class RGB(r: Int, g: Int, b: Int) extends Color <br/><br/>implicit class ToRgbOps(val color: PredefColor) extends AnyVal { <br/> def toRgb: RGB = { <br/>   case Red =&gt; RGB(255 byteValue, 0, 0) <br/>   case Green =&gt; RGB(0, 255 byteValue, 0) <br/>   case Blue =&gt; RGB(0, 0, 255 byteValue ) <br/> } <br/>} <br/></pre>
      <p>И тогда мы сможем писать <code>Red.toRgb или Green.toRgb</code>.</p>
      <p>Это очень удобный инструмент для предотвращения превращения класса в километровую простыню, в особенности вместе с тайпклассами.</p>
      <p>Итак, переходим непосредственно к самим тайпклассам. Каждый тайпкласс состоит условно из 4-х компонентов. Первый — это интерфейс, заявляющий саму функциональность тайпкласса.</p>
      <p>Например:</p>
      <pre>trait Show[A] { <br/> def show(a: A): String <br/>}</pre>
      <p>Второй компонент — это companion object этого трейта, который даст возможность использовать определенный синтаксис.</p>
      <pre>object Show { <br/> def apply[A](a: A)(implicit show: Show[A]): String = show.show(a) <br/>}</pre>
      <p>А сам синтаксис использования будет выглядеть так:</p>
      <pre>Show[A](a)</pre>
      <p>Третий компонент — это набор реализаций: <code>implicit val showString: Show[String] = {s =&gt; s} /*</code> синтаксический сахар для анонимных классов c одним методом был создан, потому что писать <code>new Foo {override def baz}</code> каждый раз слишком громоздко*/</p>
      <pre>implicit val showString: Show[String] = {s: String =&gt; s} /* синтаксический сахар для анонимных классов c одним методом, был создан, потому что писать new Foo {override def baz} каждый раз слишком громоздко*/ <br/><br/>implicit val showInt: Show[Int] = {i: Int =&gt; i.toString} <br/>implicit def showList[T : Show]: Show[List[T]] = {list: List[T] =&gt; <br/> list.map{Show[T].apply _}.mkString("List(", ",", ")") <br/>}</pre>
      <p>Четвертый, не обязательный, но крайне желательный компонент — это «синтаксис» тайпкласса, который позволит вызывать этот метод через точку:</p>
      <pre>implicit class ShowSyntax[T](val t: T) extends AnyVal { <br/> def show(implicit instance: Show[T]): String = instance.show(t) <br/>}</pre>
      <p>А вызов будет выглядеть вот так:</p>
      <pre>println(List(1,2,3,4,5,6).show)</pre>
      <h3>Деконструкция sealed trait family</h3>
      <p>Теперь мы попробуем построить sealed trait family из набора «примитивных» типов. Для этого нам потребуются следующие компоненты: набор идентификаторов <code>Id</code>, набор примитивных типов <code>PT</code> и несколько операций. Строить будем некоторое множество типов <code>T</code>. Во-первых, любой примитивный тип является и типом <code>Т</code>. Нам понадобится операция связывания идентификатора с типом, будем обозначать ее символом <code>@</code>. То есть, если <code>id</code> — идентификатор и <code>t</code> — тип, то <code>lt := t @ id</code> — тип с идентификатором. Далее, введем операцию конструирования на типах с идентификаторами: если <code>t1, …, tn</code> — типы из <code>Т</code> и <code>id1, …, idn</code> — идентификаторы, то <code>t := (t1 @ id1, t2 @ id2, …, tn @ idn)</code> — тип из <code>Т</code>. Далее, вводим операцию «или» на типах: если <code>t1, …, tn</code> — типы из <code>Т</code>, то <code>t := t1 | t2 | … | tn</code> — тип из <code>Т</code>. Такая модель упрощенно показывает структуру ADT.</p>
      <p>В нашем случае примитивными типами выступают, собственно, встроенные типы данных из разряда Int, Byte, Long, String, Double, Boolean и, кроме этого, различные типы, которые не являются частью ADT, такие как, например, <code>java.time.Instant</code>.</p>
      <p>Операция конструирования моделирует введение нового типа при помощи кейс-классов или кейс-обджектов, например, из типов Int, String, String, идентификаторов foo, bar, baz мы можем построить новый тип Qux <code>case class Qux(foo: Int, bar: String, baz: String)</code>, который в нашей модели будет представлен как <code>Qux := (Int @ foo, String @ bar, String @ baz)</code>.</p>
      <p>При этом различные вопросы по поводу того, какие поля включать в этот перечень и какие не включать и нужны ли дополнительные пометки о свойствах этих полей, мы можем смело отметать по той простой причине, что все поля равноправны и неизменяемы.</p>
      <p>Операция «или» моделирует sealed trait. Ограниченность sealed trait рамками одного файла позволяет гарантировать, что перечень типов, которые наследуются от данного sealed trait, полон и известен на этапе компиляции.</p>
      <pre>sealed trait PredefColor <br/>case object Red extends PredefColor <br/>case object Green extends PredefColor <br/>case object Blue extends PredefColor <br/></pre>
      <p>То есть в этом случае мы можем смоделировать <code>PredefColor := Red|Green|Blue</code>.</p>
      <p>При этом разные обязательства по наличию полей в кейс-классах, которые наследуют трейты, в этой модели не учитываются.</p>
      <p>Остается вопрос о параметрических типах вроде <code>List[T]</code> и т. д., но пока на этом останавливаться и вводить дополнительный формализм не будем: большинство вопросов, связанных с высшими каиндами, уже решено в механизме поиска имплиситов в компиляторе Scala.</p>
      <p>На нашей модели вполне можно строить алгоритм структурного сравнения. Итак, нам нужно сравнить две структуры одинакового типа, но потенциально разного значения, и вывести список различных полей. Различные сложности сравнения неупорядоченных и упорядоченных коллекций, с которыми мы можем столкнуться, пока оставим за кадром и будем выводить наиболее простое решение.</p>
      <p>Допустим, у нас есть некоторый набор операций сравнения для примитивных типов, тогда нам остается определить операцию сравнения для операции конструирования и для операции «или».</p>
      <p>Для операции конструирования мы будем определять сравнение как объединение различия для всех элементов.</p>
      <p>Для операции «или», с учетом объектов <code>ob1, ob2,...,obn</code> типов <code>t1|...|tn</code>, понятно, что настоящие типы этих объектов будут <code>t_i</code> и <code>t_j</code> для некоторых <code>i,j</code> из <code>1,...,n</code>. Тогда если <code>i == j</code>, мы возвращаем результат сравнения внутренностей объектов, а если <code>i != j</code>, возвращаем несовпадение действительных типов.</p>
      <h3>Инструментарий</h3>
      <p>Нам понадобятся абстракции для представления операций <code>@, (_,...,_)</code> и <code>“|”</code>. К счастью, библиотека Shapeless предоставляет таковые.</p>
      <p>Для операции <code>@</code> существует отдельный тип <code>FieldType[Identifier, T]</code>, который представляет абстракцию для поля класса, названного некоторым именем. О его использовании — ниже.</p>
      <p>Для моделирования операции конструирования Shapeless представляет гетерогенный список <code>HList</code>. Отличие гетерогенного списка от обычного состоит в том, что этот список хранит информацию о типе каждого элемента в типе самого списка.</p>
      <p>Дело в том, что сам тип <code>HList</code> — это надтип для очень широкого семейства типов, но конструктора у конкретных типов всего два: <code>HNil</code> — пустой список и <code>::[+Head, +Tail &lt;: HList]</code>. Благодаря синтаксическому сахару для типов с двумя параметрами конструкции вроде <code>::[String, ::[Int, HNil]] выглядят как String :: Int :: HNil</code>.</p>
      <p>HList умеет очень многое, связанное с информацией о типах. Более подробную информацию можно получить в описании библиотеки <a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists">на GitHub</a>.</p>
      <p>Нам же пригодится только возможность рекурсивно проходить по элементам этого списка.</p>
      <p>Далее, операцию «или» представляет тип <code>Coproduct</code>. Он подобен <code>HList</code> в том, что имеет структуру, похожую на цепь, но на этот раз у него есть несколько конструкторов. Общий тип <code>Coproduct</code> населен типами <code>T1 :+: T2 :+: … :+: TN :+: CNil, для N= 1,2,3,...</code>. Каждый тип для фиксированного <code>N= N0</code> состоит из элементов <code>Inl(t1: T1), Inr(Inl(t2: T2), … , Inr(Inr(,, Inl(tn0: TN0)))</code>. Где в <code>H :+: T при T &lt;: Coproduct Inr</code> обозначает, что конкретный объект типа <code>H</code>, а <code>Inl</code> обозначает, что тип конкретного объекта находится в <code>T</code>. Тип <code>CNil</code> существует для терминирования последовательности <code>CNil</code>, и ни для чего более.</p>
      <p>Рекурсивное прохождение по всем возможным вариантам принадлежности конкретного объекта к типу будет очень похоже на такое у гетерогенного списка.</p>
      <p>Теперь нам необходимо связующее звено, которое выведет тип представления конкретного объекта через описанные выше три типа данных и предоставит механизм для превращения из конкретного объекта в обобщенное представление. В Shapeless существует тайпкласс <code>LabelledGeneric</code>, экземпляры которого генерируются неявным макросом (как и большинство экземпляров тайпклассов в этой библиотеке, так что открытие портала в измерение неявных макросов и призыв реализаций — это вполне обыкновенный способ взаимодействия с ней) на этапе компиляции. Чтобы «призвать» <code>LabelledGeneric</code> для типа T в скоупе, в котором объявлен, достаточно написать:</p>
      <pre>import shapeless._ <br/>val v = LabelledGeneric[T]</pre>
      <p>Для того чтобы призвать экземпляр тайпкласса для параметра типа <code>T</code>, необходимо потребовать implicit параметр <code>lgen: LabelledGeneric.Aux[T, Repr]</code>, и ввести дополнительный параметр, который будет нести тип представления <code>Repr</code>.</p>
      <p>Из чего будет состоять тип <code>Repr</code>? Этот тип будет действовать именно по описанной выше модели. Для кейс-классов он будет выдавать <code>HList</code> из <code>FieldType[FieldName, TypeName]</code>, тегированный специальным образом, для sealed trait — coproduct.</p>
      <p>Следует отметить, что у IDE возникают определенные сложности с определением типов репрезентации <code>labelled generic</code>. Например, для класса</p>
      <pre>case class Foo(s: String, i: Int, b: Boolean)</pre>
      <p>...мы получим тип <code>LabelledGeneric[Foo]</code>, который, естественно, соответствовать настоящему не будет, но даст нам некоторое представление о том, как это выглядит в реальности.</p>
      <pre>LabelledGeneric.Aux[ <br/> Foo, <br/> FieldType[String with KeyTag[Symbol with Tagged[{type s}], String], String] :: <br/> FieldType[Int with KeyTag[Symbol with Tagged[{type i}], Int], Int] :: <br/> FieldType[Boolean with KeyTag[Symbol with Tagged[{type b}], Boolean], Boolean] :: <br/> HNil <br/>]</pre>
      <p>Здесь страшные типы вроде <code>String with KeyTag[Symbol with Tagged[{type s}], String]</code> — это способ библиотеки Shapeless генерировать уникальные теги на уровне типов для полей классов.</p>
      <p>Для иерархии</p>
      <pre>sealed trait All <br/>case class Foo(s: String, i: Int, b: Boolean) extends All <br/>case class Bar(l: Long, f: Foo) extends All <br/>case class Baz(foos: List[Foo], bars: List[Bar]) extends All <br/></pre>
      <p>Мы получим выражение:</p>
      <pre>LabelledGeneric.Aux[ <br/>   All, <br/>   Bar with KeyTag[Symbol with Tagged[Symbol with Tagged[{type Bar}]], Bar] :+: <br/>   Baz with KeyTag[Symbol with Tagged[Symbol with Tagged[{type Baz}]], Baz] :+: <br/>   Foo with KeyTag[Symbol with Tagged[Symbol with Tagged[{type Foo}]], Foo] :+: <br/>   CNil <br/> ]</pre>
      <p>И снова, приписки <code>with KeyTag[_, _]</code> относятся к техническому аспекту shapeless выдавать уникальные типы на каждый класс. (Подробнее — Singleton types)</p>
      <p>Естественно, работать с этими типами вручную не нужно — с ними нужно работать при помощи рекурсии, и это мы рассмотрим чуть ниже.</p>
      <h3>Решение</h3>
      <p>Итак, объявим интерфейс и несколько вспомогательных классов. <code>ComparisonResult</code> для результата сравнения в виде <code>Success</code> и <code>Failure. FailEntry[T]</code> для представления различий. <code>Path</code> для определения местонахождения сравниваемого элемента.</p>
      <pre>package object genericComparators { <br/><br/> sealed trait ComparisonResult { <br/>   def append(fe: FailEntry[_]): ComparisonResult <br/><br/>   def &amp;&amp;(that: ComparisonResult): ComparisonResult <br/><br/>   def fails: Chain[FailEntry[_]] <br/><br/> } <br/><br/> object ComparisonResult { <br/><br/>   case object Success extends ComparisonResult { <br/>     override def append(fe: FailEntry[_]): ComparisonResult = Failure(Chain(fe)) <br/><br/>     override def &amp;&amp;(that: ComparisonResult): ComparisonResult = that <br/><br/>     override def fails: Chain[FailEntry[_]] = Chain.empty[FailEntry[_]] <br/><br/>   } <br/><br/>   case class Failure(fails: Chain[FailEntry[_]]) extends ComparisonResult { <br/>     override def append(fe: FailEntry[_]): ComparisonResult = Failure(fails :+ fe) <br/><br/>     override def &amp;&amp;(that: ComparisonResult): ComparisonResult = Failure(this.fails ++ that.fails) <br/><br/>   } <br/><br/> } <br/><br/> case class FailEntry[T](path: AdtPath, left: T, right: T) <br/><br/> object AdtPath { <br/>   val root = AdtPath(Chain.empty[PathElement]) <br/> } <br/><br/> sealed trait PathElement <br/><br/> case object Root extends PathElement <br/><br/> case class DownGeneric(generic: String) extends PathElement <br/> case class DownField(field: Symbol) extends PathElement <br/> case class DownCoproductElement(coproductType: Symbol) extends PathElement <br/> case class Primitive(field: String) extends PathElement <br/> case class DownIterable(index: Long) extends PathElement <br/> case class DownManual(tag: String) extends PathElement <br/><br/> case class AdtPath(steps: Chain[PathElement], last: PathElement = Root) { <br/>   def downHlist(fieldName: Symbol): AdtPath = <br/>     last match { <br/>       case DownField(_) =&gt; AdtPath(steps, DownField(fieldName)) <br/>       case Primitive(_) =&gt; throw new RuntimeException(s"should not never happen") <br/>       case _ =&gt; AdtPath(steps :+ last, DownField(fieldName)) <br/>     } <br/><br/>   def downCoproduct(element: Symbol): AdtPath = <br/>     last match { <br/>       case DownCoproductElement(_) =&gt; AdtPath(steps, DownCoproductElement(element)) <br/>       case Primitive(_) =&gt; throw new RuntimeException(s"should not never happen") <br/>       case _ =&gt; AdtPath(steps :+ last, DownCoproductElement(element)) <br/>     } <br/><br/>   def downGeneric(className: String): AdtPath = <br/>     last match { <br/>       case Primitive(_) =&gt; throw new RuntimeException(s"should not never happen") <br/>       case _ =&gt; AdtPath(steps :+ last, DownGeneric(className)) <br/>     } <br/><br/>   def downIterable(index: Long): AdtPath = last match { <br/>     case DownIterable(_) =&gt; AdtPath(steps, DownIterable(index)) <br/>     case Primitive(_) =&gt;throw new RuntimeException(s"should not never happen") <br/>     case _ =&gt; AdtPath(steps :+ last, DownIterable(index)) <br/>   } <br/><br/>   def downManual(manual: String): AdtPath = AdtPath( steps :+ last, DownManual(manual)) <br/><br/>   def primitive(primitiveTag: String): AdtPath = AdtPath( steps :+ last, Primitive(primitiveTag)) <br/> } <br/>}</pre>
      <p>Далее, определяем интерфейс нашего тайпкласса и несколько простых реализаций:</p>
      <pre>object GenericComparer { <br/> def compare[T](first: T, second: T)(implicit <br/>                                     compare: GenericComparer[T] <br/> ): ComparisonResult = <br/>   compare.apply(first, second)(AdtPath.root, ComparisonResult.Success) <br/><br/> def instance[U](f: (U, U) =&gt; Boolean)(tag: String = ""): GenericComparer[U] = new GenericComparer[U] { <br/>   override def apply(t1: U, t2: U)(implicit path: AdtPath, result: ComparisonResult): ComparisonResult = <br/>     if (f(t1, t2)) result <br/>     else result.append(FailEntry(path, t1, t2)) <br/> } <br/>} <br/><br/>trait GenericComparer[T] { <br/> def apply(t1: T, t2: T)(implicit path: AdtPath, result: ComparisonResult): ComparisonResult <br/>}</pre>
      <p>Неявный параметр <code>path</code> нужен для возможности «записывать» пройденный путь по структуре класса при рекурсивном применении этой функции. Неявный параметр <code>result</code> является аккумулятором в рекурсии.</p>
      <p>В компанион обджекте создан метод <code>def compare[T](first: T, second: T)(implicit compare: GenericComparer[T]): ComparisonResult</code>, который предоставляет интерфейс для использования тайпкласса как <code>GenericComparer.compare(a,b)</code>.</p>
      <p>Там же функция для создания реализации из функции сравнения <code>instance</code>.</p>
      <p>Пользуясь этой функцией, можно сделать набор реализаций для примитивов:</p>
      <pre>implicit val scompare: GenericComparer[String] = GenericComparer.instance[String] { _ == _ } {"string"} <br/>implicit val icompare: GenericComparer[Int] = GenericComparer.instance[Int] { _ == _ } {"int"} <br/>implicit val lcompare: GenericComparer[Long] = GenericComparer.instance[Long] { _ == _ } {"long"} <br/>implicit val bcompare: GenericComparer[Byte] = GenericComparer.instance[Byte] { _ == _ } {"byte"} <br/>implicit val boolcompare: GenericComparer[Boolean] = GenericComparer.instance[Boolean] { _ == _ } {"bool"} <br/>implicit val ccompare: GenericComparer[Char] = GenericComparer.instance[Char] { _ == _ } {"char"} <br/>implicit val shortcompare: GenericComparer[Short] = GenericComparer.instance[Short] { _ == _ } {"short"} <br/>implicit val bicompare: GenericComparer[BigInt] = GenericComparer.instance[BigInt] { _ == _ } {"bigInt"} <br/>implicit val dcompare: GenericComparer[Double] = GenericComparer.instance[Double] { _ == _ } {"double"} <br/></pre>
      <p>Далее, приступим к созданию операции для композитного объекта, который представим в виде <code>LabeledGeneric</code>.</p>
      <pre>//decompose sealed trait family <br/>implicit def lgenCompare[T, Repr]( <br/> implicit <br/> ctag: ClassTag[T], <br/> lgen: LabelledGeneric.Aux[T, Repr], <br/> reprCompare: Lazy[GenericComparer[Repr]]): GenericComparer[T] = new GenericComparer[T] { <br/> override def apply(t1: T, t2: T)(implicit path: AdtPath, result: ComparisonResult): ComparisonResult = { <br/>   reprCompare.value.apply( <br/>     lgen.to(t1), <br/>     lgen.to(t2))( <br/>     path.downGeneric(ctag.runtimeClass.getSimpleName), <br/>     result <br/>   ) <br/> } <br/>}</pre>
      <p>Эта реализация функции тайпкласса пытается «призвать» <code>LabelledGeneric</code> с каким-либо типом представления и вывести реализацию для обобщенного представления. Но сама по себе эта реализация бесполезна без реализаций для примитивов, случая с <code>HList</code> и <code>Coproduct</code>. Обратите внимание на то, что операция сравнения для обобщенного представления <code>Repr</code> обернута в <code>Lazy</code>, для того чтобы избежать ошибки <code>diverging implicit expansion</code>.</p>
      <p>Итак, сначала случай <code>HList</code>.</p>
      <p>Терминальная точка для рекурсии:</p>
      <pre>implicit val hnilCompare: GenericComparer[HNil] = <br/> GenericComparer.instance[HNil] { (_, _) =&gt; true }{"hnil"}</pre>
      <p>И сама рекурсия, метод который выводит операцию сравнения для непустого списка <code>Head :: Tail</code>:</p>
      <pre>implicit def hconsCompareKeyed[Key &lt;: Symbol, Head, Tail &lt;: HList]( <br/> implicit key: Witness.Aux[Key], <br/> compareHeads: GenericComparer[Head], <br/> compareTails: Lazy[GenericComparer[Tail]] <br/>): GenericComparer[FieldType[Key, Head] :: Tail] = <br/> new GenericComparer[FieldType[Key, Head] :: Tail] { <br/>   override def apply( <br/>     t1: FieldType[Key, Head] :: Tail, <br/>     t2: FieldType[Key, Head] :: Tail)( <br/>     implicit path: AdtPath, result: ComparisonResult <br/>   ): ComparisonResult = { <br/>     val newPath = path.downHlist(key.value) <br/><br/>     compareHeads.apply(t1.head, t2.head)(newPath, result) &amp;&amp; <br/>       compareTails.value.apply(t1.tail, t2.tail)(newPath, result) <br/>   } <br/> } <br/></pre>
      <p>Откуда такой набор типов и такая сигнатура? Во-первых, нам необходимо имя поля, его достаем при помощи типа <code>Key</code>, который является символом. Для «вызова» значения имени поля используем неявный параметр <code>key: Witness.Aux[Key]</code>, который и вызовет то значение, которое кодируют страшные типы из главы выше. Это и есть тот обещанный способ не работать напрямую с типом тега, который тегирует конкретное поле в классе — введя его как параметр функции, компилятор попытается его вывести автоматически.</p>
      <p>Далее, <code>Head</code> — это тип тегируемого при помощи <code>Key</code> поля в классе, нам необходимо иметь для него операцию сравнения, поэтому мы заявляем это как еще один неявный параметр — <code>compareHeads: GenericComparer[Head]</code>.</p>
      <p>И наконец, чтобы сделать рекурсивный вызов, мы вводим параметр типа хвоста списка <code>Tail</code>, который снова должен быть гетерогенным списком, и просим вывести для хвоста реализацию при помощи заявления еще одного неявного параметра: <code>compareTails: Lazy[GenericComparer[Tail]]</code>.</p>
      <p>Почему это будет рекурсивным вызовом? Потому что под тип <code>GenericComparer[Tail]</code> подпадает эта же реализация, или же терминальная точка рекурсии <code>hnilCompare</code>. При этом мы избавились от необходимости рассматривать все типы списка сразу, а рассматриваем их только по одному за вызов, что позволяет обрабатывать списки произвольной длины.</p>
      <p>Внутренности этой реализации довольно примитивные, основную работу делают неявные параметры.</p>
      <p>Теперь рассмотрим случай <code>Coproduct</code>. Терминирование рекурсии будем производить при помощи:</p>
      <pre>implicit val cnilCompare: GenericComparer[CNil] = <br/> GenericComparer.instance[CNil] { (a, b) =&gt; a.impossible <br/>}{"neverhappen"} <br/></pre>
      <p>Этот метод никогда не будет вызван, но необходим, чтобы остановить поиск неявных параметров. Теперь непосредственно реализация для непустого произведения, подобная той, что мы привели для <code>HList</code>.</p>
      <pre>implicit def cconsCompareKeyed[Key &lt;: Symbol, Head, Tail &lt;: Coproduct]( <br/> implicit key: Witness.Aux[Key], <br/> compareHeads: GenericComparer[Head], <br/> compareTails: Lazy[GenericComparer[Tail]] <br/>): GenericComparer[FieldType[Key, Head] :+: Tail] = <br/> new GenericComparer[FieldType[Key, Head] :+: Tail] { <br/>   override def apply( <br/>     t1: FieldType[Key, Head] :+: Tail, <br/>     t2: FieldType[Key, Head] :+: Tail)( <br/>     implicit path: AdtPath, result: ComparisonResult): ComparisonResult = { <br/>     val newPath = path.downCoproduct(key.value) <br/>     (t1, t2) match { <br/>       case (Inl(a), Inl(b)) =&gt; <br/>         compareHeads.apply(a, b)(newPath, result) <br/>       case (Inl(_), Inr(_)) | (Inr(_), Inl(_)) =&gt; <br/>         result.append(FailEntry(newPath, Coproduct.unsafeGet(t1), Coproduct.unsafeGet(t2))) <br/>       case (Inr(tail1), Inr(tail2)) =&gt; <br/>         compareTails.value.apply(tail1, tail2) <br/>     } <br/>   } <br/> }</pre>
      <p>В этой реализации мы проходим по всем возможным типам объектов, которые входят в произведение, и для случая, когда типы объектов совпадают, проводим сравнение содержимого. Механизм рекурсии и получения имени конкретного элемента-типа произведения — точно такой же, как и в случае с <code>HList</code>.</p>
      <p>Для завершенности приведем очень ограниченную базовую реализацию сравнения последовательностей (на самом деле, скрещивания алгоритма для диффов последовательностей и множества с иерархической структурой нетривиальны и достойны отдельной статьи, но все предложения по усовершенствованию принимаются).</p>
      <pre>def compareIterables[T: GenericComparer]: GenericComparer[Iterable[T]] = <br/> new GenericComparer[Iterable[T]] { <br/>   override def apply(t1: Iterable[T], t2: Iterable[T])(implicit path: AdtPath, result: ComparisonResult) <br/>   : ComparisonResult = { <br/>     if (t1.size == t2.size) { <br/>       (t1 zip t2).foldLeft((result, 0)) { case ((res, i), (el1, el2)) =&gt; <br/>         (implicitly[GenericComparer[T]].apply(el1, el2)(path.downIterable(i), res), i + 1) <br/>       }._1 <br/>     } <br/>     else result.append(FailEntry(path.downIterable(-1), t1, t2)) <br/>   } <br/> } <br/></pre>
      <h3>Объединение</h3>
      <p>Теперь необходимо соединить все в единую структуру, пригодную к использованию. Нам бы хотелось при всем том, что умеет эта библиотека, уметь заменять генерацию операции своей реализацией, иначе бы от такой библиотеки пользы было мало. Достичь этого можно при помощи механизма затенения неявных значений (implicit shadowing). Для этого нужно положить реализацию для <code>Labelled generic, HList</code> и <code>Coproduct</code> в трейт <code>GenericComparatorsLowestPriority</code>. Затем от него наследовать трейт <code>AllComparators</code> со всеми реализациями для примитивов. Далее — в любой точке применения наследовать<code> AllComparators</code> своим классом/обджектом/трейтом.</p>
      <p>При этом для одного и того же типа компилятор будет выбирать только тот имплисит, который находится наименее глубоко в иерархии наследования. Поэтому имплисит для <code>LabelledGeneric</code> будет легко перекрываться вашим собственным. При этом импортировать значение из <code>GenericComparatorsLowestPriority</code> категорически нельзя.</p>
      <p>Готовый результат можно посмотреть в репозитории на <a href="https://github.com/ivan71kmayshan27/ShapelesDerivationExample">GitHub</a>.</p>
      <p>Наиболее простой способ запустить этот код локально — установить intellij IDEA Community edition и Scala plugin к ней, далее просто открыть проект и импортировать — плагин и IDE сделают все сами.</p>
      <h3>Преимущества и недостатки</h3>
      <p>В итоге мы малыми усилиями добились способа получать операцию структурного сравнения без написания бойлерплейта, при этом написав совсем немного кода. При добавлении новых классов нам необходимо перегружать эту операцию только для типов-примитивов.</p>
      <p>Основным недостатком текущей реализации является то, что выяснение причины, по которой компилятор не может вывести операцию сравнения для чего-нибудь, может занимать определенное время, но опция компилятора «-Xlog-implicits» станет хорошим подспорьем — пройдясь по сообщениям, можно понять, чего именно не хватает. Единственное утешение — вы всегда узнаете об этом до запуска программы.</p>
      <p>Второй недостаток — не самая хорошая работа со множествами и коллекциями, но это как раз дело поправимое.</p>
      <h3>Послесловие</h3>
      <p>На самом деле продемонстрированным способом можно получать реализации для других тайпклассов, не только операции сравнения. Например, для процедуры кодирования/декодирования в разные форматы.</p>
      <p>Темы: <a href="https://dou.ua/lenta/tags/Scala/">Scala</a>, <a href="https://dou.ua/lenta/tags/tech/">tech</a>, <a href="https://dou.ua/lenta/tags/%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0/">разработка</a></p>
    </article>
  </body>
</html>