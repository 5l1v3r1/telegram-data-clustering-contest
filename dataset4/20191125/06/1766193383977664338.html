<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://www.heise.de/developer/artikel/C-20-Zwei-Extreme-und-die-Rettung-dank-Concepts-4594834.html"/>
    <meta property="og:site_name" content="Developer"/>
    <meta property="article:published_time" content="2019-11-25T06:25:00+00:00"/>
    <meta property="og:title" content="C++20: Zwei Extreme und die Rettung dank Concepts"/>
    <meta property="og:description" content="Nach dem groben Überblick zu C++20 ist es nun an der Zeit, die Features genauer unter die Lupe zu nehmen. Hierfür gibt es keinen besseren Einstieg als Concepts."/>
  </head>
  <body>
    <article>
      <h1>C++20: Zwei Extreme und die Rettung dank Concepts</h1>
      <address><time datetime="2019-11-25T06:25:00+00:00">25 Nov 2019, 06:25</time> by <a rel="author">Rainer Grimm</a></address>
      <p>
        <b><a href="https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Concurrency-4585408.html">Im letzten Blog-Artikel habe ich meinen Überblick zu C++20 abgeschlossen</a>. Jetzt ist es an der Zeit, die Features genauer unter die Lupe zu nehmen. Hierfür gibt es keinen besseren Einstieg als Concepts.</b>
      </p>
      <p>Zugegebenermaßen, bin ich ein großer Fan von Concepts und daher parteiisch. Zuerst möchte ich Concepts motivieren.</p>
      <h4>Zwei Extreme</h4>
      <p>Bis C++20 hatten wir in C++ zwei diametrale Optionen, mithilfe von Funktionen und Klassen Abstraktionen zu schaffen. Funktionen oder Klassen ließen sich für konkrete Datentypen oder generische Datentypen definieren. Im zweiten Fall nennen wir diese Funktions- oder Klassen-Templates. Warum sind beide Wege falsch?</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/TimelineCpp20Concepts-9322ecd618ebfafa.png"/>
      </figure>
      <h4>Zu spezifisch</h4>
      <p>Es ist nahezu eine Herkulesaufgabe, für jeden konkreten Datentyp eine Funktion oder Klasse zu definieren. Um diese Last von unseren Schultern zu nehmen, kommen Typkonvertierungen ins Spiel. Doch was wie eine Rettung scheint, entpuppt sich oft als Fluch:</p>
      <pre>// tooSpecific.cpp<br/><br/>#include &lt;iostream&gt;<br/><br/>void needInt(int i){<br/>    std::cout &lt;&lt; "int: " &lt;&lt; i &lt;&lt; std::endl;<br/>}<br/><br/>int main(){<br/><br/>    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br/><br/>    double d{1.234};                             // (1)<br/>    std::cout &lt;&lt; "double: " &lt;&lt; d &lt;&lt; std::endl;<br/>    needInt(d);                                  // (2)            <br/><br/>    std::cout &lt;&lt; std::endl;<br/><br/>    bool b{true};                                // (3)<br/>    std::cout &lt;&lt; "bool: " &lt;&lt; b &lt;&lt; std::endl;<br/>    needInt(b);                                  // (4)<br/><br/>    std::cout &lt;&lt; std::endl;<br/><br/>}</pre>
      <p>Im ersten Fall (Zeile 1), starte ich mit einem <code>double</code>- und ende mit einem <code>int</code>-Wert (Zeile 2). Im zweiten Fall (Zeile 3) starte ich mit einem <code>bool</code>- und ende wieder mit einem <code>int</code>-Wert (Zeile 4).</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/tooSpecific-595f1c51cd226c8a.png"/>
      </figure>
      <ul>
        <li>
          <b>Narrowing Conversion</b>
        </li>
      </ul>
      <p>Der Aufruf von <code>getInt(int a)</code> mit einem <code>double</code>-Wert verursacht "narrowing conversion". Dieses ist eine Konvertierung mit Verlust der Datengenauigkeit. Das war sicherlich nicht die Absicht des Autors.</p>
      <ul>
        <li>
          <b>Integral Promotion</b>
        </li>
      </ul>
      <p>Anders herum ist es aber auch nicht besser. Wird <code>getInt(int a)</code> mit einem <code>bool</code>-Wert aufgerufen, wird dieser auf einen <code>int</code>-Wert aufgeblasen. Überrascht? Viele C++ Entwickler wissen nicht, was passiert, wenn zwei Wahrheitswerte addiert werden:</p>
      <pre>template &lt;typename T&gt;<br/>auto add(T first, T second){<br/>    return first + second;<br/>}<br/><br/>int main(){<br/>    add(true, false);<br/>}</pre>
      <p><a href="https://cppinsights.io/s/22249b6a">C++ Insights</a> zeigt die ganze Wahrheit:</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/addGeneric-371acb44114d4b98.png"/>
      </figure>
      <p>Die Template-Instanziierung des Funktions-Templates <code>add</code> erzeugt eine vollständige Spezialisierung (Zeilen 6 bis 12), die den Rückgabetyp <code>int</code> besitzt.</p>
      <p>Meine feste Überzeugung ist es, dass wir nur aus praktischen Gründen die ganze Magie der Typkonvertierungen in C/C++ besitzen, um mit der Unzulänglichkeit umgehen zu können, dass Funktionen nur spezifische Datentypen annehmen können.</p>
      <p>Wenden wir nun die zweite Option an und nutzen keine spezifischen, sondern generische Datentypen. Vielleicht sind ja gerade Templates unsere Rettung.</p>
      <h4>Zu generisch</h4>
      <p>Hier ist mein erster Versuch: Sortieren ist ein ganz allgemeine Idee. Daher sollte sie auf jeden Container anwendbar sein, falls sich die Elemente des Containers sortieren lassen. Lasse mich <code>std::sort</code> auf eine <code>std::list</code> anwenden:</p>
      <pre>// sortList.cpp<br/><br/>#include &lt;algorithm&gt;<br/>#include &lt;list&gt;<br/><br/>int main(){<br/><br/>    std::list&lt;int&gt; myList{1, 10, 3, 2, 5};<br/><br/>    std::sort(myList.begin(), myList.end());<br/><br/>}</pre>
      <p>Wow! Dies passiert, wenn du versuchst, das kleine Programm zu übersetzen:</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/sortList-58a39faf5950f494.png"/>
      </figure>
      <p>Diese Fehlermeldung will ich nicht dechiffrieren. Was läuft hier falsch? Vielleicht hilft ein genauerer Blick auf die verwendete Überladung von <code>std::sort</code><i>.</i></p>
      <pre>template&lt; class RandomIt &gt;<br/>void sort( RandomIt first, RandomIt last );</pre>
      <p><code>std::sort </code>verwendet den seltsam klingenden Name <i>RandomIt. </i>Es steht für einen random access iterator. Dies ist der Grund für die überwältigende Fehlermeldung, für die Templates berühmt-berüchtigt sind. Eine <code>std::list</code> bietet nur einen bidirectional iterator an, aber <code>std::sort</code> benötigt einen random access iterator. Die Struktur einer <code>std::list</code> macht diese Einschränkung offensichtlich.</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/list-2e190a092ed0d7fd.png"/>
      </figure>
      <p>Wenn du genauer die Dokumentation zu <code>std::sort</code> auf <a href="https://en.cppreference.com/w/cpp/algorithm/sort">cppreference.com</a> studierst, findest du etwas sehr Interessantes: Typanforderungen an <code>std::sort</code>.</p>
      <h4>Concepte als Rettung</h4>
      <p>Concepts sind die Rettung, denn sie definieren semantische Einschränkungen auf Template-Parametern.</p>
      <p>Hier sind die bereits erwähnten Typanforderungen zu <code>std::sort</code><i>.</i></p>
      <ul>
        <li>RandomIt must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/ValueSwappable">ValueSwappable</a> and <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">LegacyRandomAccessIterator.</a></li>
        <li>The type of dereferenced RandomIt must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/MoveAssignable">MoveAssignable</a> and <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible">MoveConstructible</a>.</li>
        <li>Compare must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/Compare">Compare</a>.</li>
      </ul>
      <p>Die Typanforderungen an <code>std::sort</code> sind Concepte. Mein Artikel "<a href="https://www.heise.de/developer/artikel/C-20-Die-vier-grossen-Neuerungen-4568956.html">C++20: Die vier großen Neuerungen</a>" gibt eine kompakte Einführung zu Concepts. Insbesondere fordert <code>std::sort</code> einen <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator"><code>LegacyRandomAccessIterator</code>.</a> Darauf will ich gerne einen genaueren Blick werfen. Das Beispiel von <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">cppreference.com</a> habe ich ein wenig poliert:</p>
      <pre>template&lt;typename It&gt;<br/>concept LegacyRandomAccessIterator =<br/>  LegacyBidirectionalIterator&lt;It&gt; &amp;&amp;        // (1)<br/>  std::totally_ordered&lt;It&gt; &amp;&amp;<br/>  requires(It i, typename std::incrementable_traits&lt;It&gt;::difference_type n) {<br/>    { i += n } -&gt; std::same_as&lt;It&amp;&gt;;        // (2)<br/>    { i -= n } -&gt; std::same_as&lt;It&amp;&gt;;<br/>    { i +  n } -&gt; std::same_as&lt;It&gt;;<br/>    { n +  i } -&gt; std::same_as&lt;It&gt;;<br/>    { i -  n } -&gt; std::same_as&lt;It&gt;;<br/>    { i -  i } -&gt; std::same_as&lt;decltype(n)&gt;;<br/>    {  i[n]  } -&gt; std::convertible_to&lt;std::iter_reference_t&lt;It&gt;&gt;;<br/>  };</pre>
      <p>Dies ist die entscheidende Beobachtung. Ein Datentyp <code>It</code> unterstützt das Concept <code>LegacyRandomAccessIterator</code> genau dann, wenn er das Concept <code>LegacyBidirectionalIterator</code> (Zeile 1) und die weiteren Anforderungen unterstützt. Zum Beispiel sagt die Anforderung in Zeile 2 für einen Wert des Datentyps <code>It</code> aus: <code>{ i += n }</code> muss gültig sein und eine Referenz auf <code>It</code> zurückgeben. Um mit meiner Story zum Abschluss zu kommen. <code>std::list</code> unterstützt nur einen <code>LegacyBidirectionalIterator</code><i>.</i></p>
      <p>Zugegeben, dieser Abschnitt war sehr technisch. Jetzt folgt die Praxis. Mit Concepts wirst du eine einfache Fehlermeldung wie die folgende erhalten, wenn du <code>std::sort</code> mit einer <code>std::list</code> erhältst:</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/listError-b440d5cb61b30cb2.png"/>
      </figure>
      <p>Sorry, die Fehlermeldung war eine Ente, denn kein Compiler setzt zum jetzigen Zeitpunkt die C++20-Syntax für Concepts vollständig um. MSVC 19.23 unterstützt Concepts teilweise, GCC eine vorherige Version von Concepts. <a href="https://en.cppreference.com/w/cpp/compiler_support">cppreference.com</a> liefert mehr Details zur aktuellen Compilerunterstützung von Concepts.</p>
      <p>Habe ich gesagt, dass GCC ein vorherige Version von Conceps unterstützt?</p>
      <h4>Die lange, lange Geschichte</h4>
      <p>Das erste Mal, als ich um 2005/2006 mit Concepts in Berührung kam, erinnerten sie mich an Haskells Typklassen. Typklassen in Haskell sind Interface für ähnliche Datentypen. Das Bild zeigt einen Ausschnitt aus Haskells Typklassenhierachie:</p>
      <figure>
        <img src="https://www.heise.de/developer/imgs/06/2/7/9/4/2/4/2/haskellsTypeclasses-2006bad783a6f13d.png"/>
      </figure>
      <p>Doch C++ Concepts unterscheiden sich von Haskells Typklassen. Hier sind ein paar Beobachtungen.</p>
      <ul>
        <li>In Haskell muss ein Datentyp eine Instanz einer Typklasse sein. In C++20 muss ein Datentyp die Anforderungen eines Concepts erfüllen.</li>
        <li>Concepts lassen sich auch auf "non-type parameter" anwenden. Zum Beispiel kann die Zahl 5 als non-type parameter verwendet werden. Wenn du ein <code>std::array</code> von <code>int</code>s mit 5 Elementen haben möchtest, wendest du diesen non-type parameter an: <code>std::array&lt;int, 5&gt; myVec</code><i>.</i></li>
        <li>Concepts besitzen keine Laufzeitkosten.</li>
      </ul>
      <p>Ursprünlich sollten Concepts bereits das große Feature von C++11 sein. In dem Standardisierungsmeeting in Frankfurt wurden sie aber im Juli 2009 entfernt. Das Zitat von Bjarne Stroustrup spricht für sich selbst: "The C++Ox concept design evolved into a monster of complexity." Ein paar Jahre später war der nächste Versuch, Concepts zu standardisieren, wieder erfolglos. Concept lite wurden aus C++17 entfernt. Nun bekommen wir sie aber mit C++20.</p>
      <h3>Wie geht's weiter?</h3>
      <p>Mit meinem nächsten Artikel knüpfe ich natürlich an Concepts an. Ich werde viele Beispiele zu semantischen Einschränkungen auf Template-Parameter vorstellen.</p>
    </article>
  </body>
</html>